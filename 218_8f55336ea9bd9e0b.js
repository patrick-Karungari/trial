(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
  [218],
  {
    450973: function (e, t) {
      "use strict";
      var n;
      (t.FunctionDeclarationSchemaType = void 0),
        ((n =
          t.FunctionDeclarationSchemaType ||
          (t.FunctionDeclarationSchemaType = {})).STRING = "STRING"),
        (n.NUMBER = "NUMBER"),
        (n.INTEGER = "INTEGER"),
        (n.BOOLEAN = "BOOLEAN"),
        (n.ARRAY = "ARRAY"),
        (n.OBJECT = "OBJECT");
      const i = ["user", "model", "function", "system"];
      var r, o, a, s, l, c, p;
      (t.HarmCategory = void 0),
        ((r =
          t.HarmCategory || (t.HarmCategory = {})).HARM_CATEGORY_UNSPECIFIED =
          "HARM_CATEGORY_UNSPECIFIED"),
        (r.HARM_CATEGORY_HATE_SPEECH = "HARM_CATEGORY_HATE_SPEECH"),
        (r.HARM_CATEGORY_SEXUALLY_EXPLICIT = "HARM_CATEGORY_SEXUALLY_EXPLICIT"),
        (r.HARM_CATEGORY_HARASSMENT = "HARM_CATEGORY_HARASSMENT"),
        (r.HARM_CATEGORY_DANGEROUS_CONTENT = "HARM_CATEGORY_DANGEROUS_CONTENT"),
        (t.HarmBlockThreshold = void 0),
        ((o =
          t.HarmBlockThreshold ||
          (t.HarmBlockThreshold = {})).HARM_BLOCK_THRESHOLD_UNSPECIFIED =
          "HARM_BLOCK_THRESHOLD_UNSPECIFIED"),
        (o.BLOCK_LOW_AND_ABOVE = "BLOCK_LOW_AND_ABOVE"),
        (o.BLOCK_MEDIUM_AND_ABOVE = "BLOCK_MEDIUM_AND_ABOVE"),
        (o.BLOCK_ONLY_HIGH = "BLOCK_ONLY_HIGH"),
        (o.BLOCK_NONE = "BLOCK_NONE"),
        (t.HarmProbability = void 0),
        ((a =
          t.HarmProbability ||
          (t.HarmProbability = {})).HARM_PROBABILITY_UNSPECIFIED =
          "HARM_PROBABILITY_UNSPECIFIED"),
        (a.NEGLIGIBLE = "NEGLIGIBLE"),
        (a.LOW = "LOW"),
        (a.MEDIUM = "MEDIUM"),
        (a.HIGH = "HIGH"),
        (t.BlockReason = void 0),
        ((s =
          t.BlockReason || (t.BlockReason = {})).BLOCKED_REASON_UNSPECIFIED =
          "BLOCKED_REASON_UNSPECIFIED"),
        (s.SAFETY = "SAFETY"),
        (s.OTHER = "OTHER"),
        (t.FinishReason = void 0),
        ((l =
          t.FinishReason || (t.FinishReason = {})).FINISH_REASON_UNSPECIFIED =
          "FINISH_REASON_UNSPECIFIED"),
        (l.STOP = "STOP"),
        (l.MAX_TOKENS = "MAX_TOKENS"),
        (l.SAFETY = "SAFETY"),
        (l.RECITATION = "RECITATION"),
        (l.OTHER = "OTHER"),
        (t.TaskType = void 0),
        ((c = t.TaskType || (t.TaskType = {})).TASK_TYPE_UNSPECIFIED =
          "TASK_TYPE_UNSPECIFIED"),
        (c.RETRIEVAL_QUERY = "RETRIEVAL_QUERY"),
        (c.RETRIEVAL_DOCUMENT = "RETRIEVAL_DOCUMENT"),
        (c.SEMANTIC_SIMILARITY = "SEMANTIC_SIMILARITY"),
        (c.CLASSIFICATION = "CLASSIFICATION"),
        (c.CLUSTERING = "CLUSTERING"),
        (t.FunctionCallingMode = void 0),
        ((p =
          t.FunctionCallingMode ||
          (t.FunctionCallingMode = {})).MODE_UNSPECIFIED = "MODE_UNSPECIFIED"),
        (p.AUTO = "AUTO"),
        (p.ANY = "ANY"),
        (p.NONE = "NONE");
      class u extends Error {
        constructor(e) {
          super(`[GoogleGenerativeAI Error]: ${e}`);
        }
      }
      class d extends u {
        constructor(e, t) {
          super(e), (this.response = t);
        }
      }
      class m extends u {
        constructor(e, t, n, i) {
          super(e),
            (this.status = t),
            (this.statusText = n),
            (this.errorDetails = i);
        }
      }
      class h extends u {}
      var f;
      !(function (e) {
        (e.GENERATE_CONTENT = "generateContent"),
          (e.STREAM_GENERATE_CONTENT = "streamGenerateContent"),
          (e.COUNT_TOKENS = "countTokens"),
          (e.EMBED_CONTENT = "embedContent"),
          (e.BATCH_EMBED_CONTENTS = "batchEmbedContents");
      })(f || (f = {}));
      class g {
        constructor(e, t, n, i, r) {
          (this.model = e),
            (this.task = t),
            (this.apiKey = n),
            (this.stream = i),
            (this.requestOptions = r);
        }
        toString() {
          var e, t;
          const n =
            (null === (e = this.requestOptions) || void 0 === e
              ? void 0
              : e.apiVersion) || "v1beta";
          let i = `${
            (null === (t = this.requestOptions) || void 0 === t
              ? void 0
              : t.baseUrl) || "https://generativelanguage.googleapis.com"
          }/${n}/${this.model}:${this.task}`;
          return this.stream && (i += "?alt=sse"), i;
        }
      }
      async function y(e) {
        var t;
        const n = new Headers();
        n.append("Content-Type", "application/json"),
          n.append(
            "x-goog-api-client",
            (function (e) {
              const t = [];
              return (
                (null === e || void 0 === e ? void 0 : e.apiClient) &&
                  t.push(e.apiClient),
                t.push("genai-js/0.13.0"),
                t.join(" ")
              );
            })(e.requestOptions)
          ),
          n.append("x-goog-api-key", e.apiKey);
        let i =
          null === (t = e.requestOptions) || void 0 === t
            ? void 0
            : t.customHeaders;
        if (i) {
          if (!(i instanceof Headers))
            try {
              i = new Headers(i);
            } catch (r) {
              throw new h(
                `unable to convert customHeaders value ${JSON.stringify(
                  i
                )} to Headers: ${r.message}`
              );
            }
          for (const [e, t] of i.entries()) {
            if ("x-goog-api-key" === e)
              throw new h(`Cannot set reserved header name ${e}`);
            if ("x-goog-api-client" === e)
              throw new h(
                `Header name ${e} can only be set using the apiClient field`
              );
            n.append(e, t);
          }
        }
        return n;
      }
      async function b(e, t, n, i, r, o, a = fetch) {
        const { url: s, fetchOptions: l } = await (async function (
          e,
          t,
          n,
          i,
          r,
          o
        ) {
          const a = new g(e, t, n, i, o);
          return {
            url: a.toString(),
            fetchOptions: Object.assign(Object.assign({}, T(o)), {
              method: "POST",
              headers: await y(a),
              body: r,
            }),
          };
        })(e, t, n, i, r, o);
        return (async function (e, t, n = fetch) {
          let i;
          try {
            i = await n(e, t);
          } catch (r) {
            !(function (e, t) {
              let n = e;
              e instanceof m ||
                e instanceof h ||
                ((n = new u(
                  `Error fetching from ${t.toString()}: ${e.message}`
                )),
                (n.stack = e.stack));
              throw n;
            })(r, e);
          }
          i.ok ||
            (await (async function (e, t) {
              let n,
                i = "";
              try {
                const t = await e.json();
                (i = t.error.message),
                  t.error.details &&
                    ((i += ` ${JSON.stringify(t.error.details)}`),
                    (n = t.error.details));
              } catch (r) {}
              throw new m(
                `Error fetching from ${t.toString()}: [${e.status} ${
                  e.statusText
                }] ${i}`,
                e.status,
                e.statusText,
                n
              );
            })(i, e));
          return i;
        })(s, l, a);
      }
      function T(e) {
        const t = {};
        if ((null === e || void 0 === e ? void 0 : e.timeout) >= 0) {
          const n = new AbortController(),
            i = n.signal;
          setTimeout(() => n.abort(), e.timeout), (t.signal = i);
        }
        return t;
      }
      function _(e) {
        return (
          (e.text = () => {
            if (e.candidates && e.candidates.length > 0) {
              if (
                (e.candidates.length > 1 &&
                  console.warn(
                    `This response had ${e.candidates.length} candidates. Returning text from the first candidate only. Access response.candidates directly to use the other candidates.`
                  ),
                C(e.candidates[0]))
              )
                throw new d(`${I(e)}`, e);
              return (function (e) {
                var t, n, i, r;
                const o = [];
                if (
                  null ===
                    (n =
                      null === (t = e.candidates) || void 0 === t
                        ? void 0
                        : t[0].content) || void 0 === n
                    ? void 0
                    : n.parts
                )
                  for (const a of null ===
                    (r =
                      null === (i = e.candidates) || void 0 === i
                        ? void 0
                        : i[0].content) || void 0 === r
                    ? void 0
                    : r.parts)
                    a.text && o.push(a.text);
                return o.length > 0 ? o.join("") : "";
              })(e);
            }
            if (e.promptFeedback) throw new d(`Text not available. ${I(e)}`, e);
            return "";
          }),
          (e.functionCall = () => {
            if (e.candidates && e.candidates.length > 0) {
              if (
                (e.candidates.length > 1 &&
                  console.warn(
                    `This response had ${e.candidates.length} candidates. Returning function calls from the first candidate only. Access response.candidates directly to use the other candidates.`
                  ),
                C(e.candidates[0]))
              )
                throw new d(`${I(e)}`, e);
              return (
                console.warn(
                  "response.functionCall() is deprecated. Use response.functionCalls() instead."
                ),
                S(e)[0]
              );
            }
            if (e.promptFeedback)
              throw new d(`Function call not available. ${I(e)}`, e);
          }),
          (e.functionCalls = () => {
            if (e.candidates && e.candidates.length > 0) {
              if (
                (e.candidates.length > 1 &&
                  console.warn(
                    `This response had ${e.candidates.length} candidates. Returning function calls from the first candidate only. Access response.candidates directly to use the other candidates.`
                  ),
                C(e.candidates[0]))
              )
                throw new d(`${I(e)}`, e);
              return S(e);
            }
            if (e.promptFeedback)
              throw new d(`Function call not available. ${I(e)}`, e);
          }),
          e
        );
      }
      function S(e) {
        var t, n, i, r;
        const o = [];
        if (
          null ===
            (n =
              null === (t = e.candidates) || void 0 === t
                ? void 0
                : t[0].content) || void 0 === n
            ? void 0
            : n.parts
        )
          for (const a of null ===
            (r =
              null === (i = e.candidates) || void 0 === i
                ? void 0
                : i[0].content) || void 0 === r
            ? void 0
            : r.parts)
            a.functionCall && o.push(a.functionCall);
        return o.length > 0 ? o : void 0;
      }
      const v = [t.FinishReason.RECITATION, t.FinishReason.SAFETY];
      function C(e) {
        return !!e.finishReason && v.includes(e.finishReason);
      }
      function I(e) {
        var t, n, i;
        let r = "";
        if ((e.candidates && 0 !== e.candidates.length) || !e.promptFeedback) {
          if (null === (i = e.candidates) || void 0 === i ? void 0 : i[0]) {
            const t = e.candidates[0];
            C(t) &&
              ((r += `Candidate was blocked due to ${t.finishReason}`),
              t.finishMessage && (r += `: ${t.finishMessage}`));
          }
        } else
          (r += "Response was blocked"),
            (null === (t = e.promptFeedback) || void 0 === t
              ? void 0
              : t.blockReason) &&
              (r += ` due to ${e.promptFeedback.blockReason}`),
            (null === (n = e.promptFeedback) || void 0 === n
              ? void 0
              : n.blockReasonMessage) &&
              (r += `: ${e.promptFeedback.blockReasonMessage}`);
        return r;
      }
      function R(e) {
        return this instanceof R ? ((this.v = e), this) : new R(e);
      }
      function x(e, t, n) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var i,
          r = n.apply(e, t || []),
          o = [];
        return (
          (i = {}),
          a("next"),
          a("throw"),
          a("return"),
          (i[Symbol.asyncIterator] = function () {
            return this;
          }),
          i
        );
        function a(e) {
          r[e] &&
            (i[e] = function (t) {
              return new Promise(function (n, i) {
                o.push([e, t, n, i]) > 1 || s(e, t);
              });
            });
        }
        function s(e, t) {
          try {
            (n = r[e](t)).value instanceof R
              ? Promise.resolve(n.value.v).then(l, c)
              : p(o[0][2], n);
          } catch (i) {
            p(o[0][3], i);
          }
          var n;
        }
        function l(e) {
          s("next", e);
        }
        function c(e) {
          s("throw", e);
        }
        function p(e, t) {
          e(t), o.shift(), o.length && s(o[0][0], o[0][1]);
        }
      }
      "function" === typeof SuppressedError && SuppressedError;
      const L = /^data\: (.*)(?:\n\n|\r\r|\r\n\r\n)/;
      function w(e) {
        const t = (function (e) {
            const t = e.getReader();
            return new ReadableStream({
              start(e) {
                let n = "";
                return i();
                function i() {
                  return t.read().then(({ value: t, done: r }) => {
                    if (r)
                      return n.trim()
                        ? void e.error(new u("Failed to parse stream"))
                        : void e.close();
                    n += t;
                    let o,
                      a = n.match(L);
                    for (; a; ) {
                      try {
                        o = JSON.parse(a[1]);
                      } catch (s) {
                        return void e.error(
                          new u(`Error parsing JSON response: "${a[1]}"`)
                        );
                      }
                      e.enqueue(o),
                        (n = n.substring(a[0].length)),
                        (a = n.match(L));
                    }
                    return i();
                  });
                }
              },
            });
          })(e.body.pipeThrough(new TextDecoderStream("utf8", { fatal: !0 }))),
          [n, i] = t.tee();
        return { stream: E(n), response: P(i) };
      }
      async function P(e) {
        const t = [],
          n = e.getReader();
        for (;;) {
          const { done: e, value: i } = await n.read();
          if (e) return _(A(t));
          t.push(i);
        }
      }
      function E(e) {
        return x(this, arguments, function* () {
          const t = e.getReader();
          for (;;) {
            const { value: e, done: n } = yield R(t.read());
            if (n) break;
            yield yield R(_(e));
          }
        });
      }
      function A(e) {
        const t = e[e.length - 1],
          n = {
            promptFeedback:
              null === t || void 0 === t ? void 0 : t.promptFeedback,
          };
        for (const i of e) {
          if (i.candidates)
            for (const e of i.candidates) {
              const t = e.index;
              if (
                (n.candidates || (n.candidates = []),
                n.candidates[t] || (n.candidates[t] = { index: e.index }),
                (n.candidates[t].citationMetadata = e.citationMetadata),
                (n.candidates[t].finishReason = e.finishReason),
                (n.candidates[t].finishMessage = e.finishMessage),
                (n.candidates[t].safetyRatings = e.safetyRatings),
                e.content && e.content.parts)
              ) {
                n.candidates[t].content ||
                  (n.candidates[t].content = {
                    role: e.content.role || "user",
                    parts: [],
                  });
                const i = {};
                for (const r of e.content.parts)
                  r.text && (i.text = r.text),
                    r.functionCall && (i.functionCall = r.functionCall),
                    0 === Object.keys(i).length && (i.text = ""),
                    n.candidates[t].content.parts.push(i);
              }
            }
          i.usageMetadata && (n.usageMetadata = i.usageMetadata);
        }
        return n;
      }
      async function k(e, t, n, i) {
        return w(
          await b(t, f.STREAM_GENERATE_CONTENT, e, !0, JSON.stringify(n), i)
        );
      }
      async function O(e, t, n, i) {
        const r = await b(t, f.GENERATE_CONTENT, e, !1, JSON.stringify(n), i);
        return { response: _(await r.json()) };
      }
      function M(e) {
        if (null != e)
          return "string" === typeof e
            ? { role: "system", parts: [{ text: e }] }
            : e.text
            ? { role: "system", parts: [e] }
            : e.parts
            ? e.role
              ? e
              : { role: "system", parts: e.parts }
            : void 0;
      }
      function N(e) {
        let t = [];
        if ("string" === typeof e) t = [{ text: e }];
        else
          for (const n of e)
            "string" === typeof n ? t.push({ text: n }) : t.push(n);
        return (function (e) {
          const t = { role: "user", parts: [] },
            n = { role: "function", parts: [] };
          let i = !1,
            r = !1;
          for (const o of e)
            "functionResponse" in o
              ? (n.parts.push(o), (r = !0))
              : (t.parts.push(o), (i = !0));
          if (i && r)
            throw new u(
              "Within a single message, FunctionResponse cannot be mixed with other type of part in the request for sending chat message."
            );
          if (!i && !r)
            throw new u("No content is provided for sending chat message.");
          if (i) return t;
          return n;
        })(t);
      }
      function z(e) {
        let t;
        if (e.contents) t = e;
        else {
          t = { contents: [N(e)] };
        }
        return (
          e.systemInstruction && (t.systemInstruction = M(e.systemInstruction)),
          t
        );
      }
      const j = ["text", "inlineData", "functionCall", "functionResponse"],
        D = {
          user: ["text", "inlineData"],
          function: ["functionResponse"],
          model: ["text", "functionCall"],
          system: ["text"],
        };
      const F = "SILENT_ERROR";
      class U {
        constructor(e, t, n, r) {
          (this.model = t),
            (this.params = n),
            (this.requestOptions = r),
            (this._history = []),
            (this._sendPromise = Promise.resolve()),
            (this._apiKey = e),
            (null === n || void 0 === n ? void 0 : n.history) &&
              (!(function (e) {
                let t = !1;
                for (const n of e) {
                  const { role: e, parts: r } = n;
                  if (!t && "user" !== e)
                    throw new u(
                      `First content should be with role 'user', got ${e}`
                    );
                  if (!i.includes(e))
                    throw new u(
                      `Each item should include role field. Got ${e} but valid roles are: ${JSON.stringify(
                        i
                      )}`
                    );
                  if (!Array.isArray(r))
                    throw new u(
                      "Content should have 'parts' property with an array of Parts"
                    );
                  if (0 === r.length)
                    throw new u("Each Content should have at least one part");
                  const o = {
                    text: 0,
                    inlineData: 0,
                    functionCall: 0,
                    functionResponse: 0,
                    fileData: 0,
                  };
                  for (const t of r) for (const e of j) e in t && (o[e] += 1);
                  const a = D[e];
                  for (const t of j)
                    if (!a.includes(t) && o[t] > 0)
                      throw new u(
                        `Content with role '${e}' can't contain '${t}' part`
                      );
                  t = !0;
                }
              })(n.history),
              (this._history = n.history));
        }
        async getHistory() {
          return await this._sendPromise, this._history;
        }
        async sendMessage(e) {
          var t, n, i, r, o, a;
          await this._sendPromise;
          const s = N(e),
            l = {
              safetySettings:
                null === (t = this.params) || void 0 === t
                  ? void 0
                  : t.safetySettings,
              generationConfig:
                null === (n = this.params) || void 0 === n
                  ? void 0
                  : n.generationConfig,
              tools:
                null === (i = this.params) || void 0 === i ? void 0 : i.tools,
              toolConfig:
                null === (r = this.params) || void 0 === r
                  ? void 0
                  : r.toolConfig,
              systemInstruction:
                null === (o = this.params) || void 0 === o
                  ? void 0
                  : o.systemInstruction,
              cachedContent:
                null === (a = this.params) || void 0 === a
                  ? void 0
                  : a.cachedContent,
              contents: [...this._history, s],
            };
          let c;
          return (
            (this._sendPromise = this._sendPromise
              .then(() => O(this._apiKey, this.model, l, this.requestOptions))
              .then((e) => {
                var t;
                if (e.response.candidates && e.response.candidates.length > 0) {
                  this._history.push(s);
                  const n = Object.assign(
                    { parts: [], role: "model" },
                    null === (t = e.response.candidates) || void 0 === t
                      ? void 0
                      : t[0].content
                  );
                  this._history.push(n);
                } else {
                  const t = I(e.response);
                  t &&
                    console.warn(
                      `sendMessage() was unsuccessful. ${t}. Inspect response object for details.`
                    );
                }
                c = e;
              })),
            await this._sendPromise,
            c
          );
        }
        async sendMessageStream(e) {
          var t, n, i, r, o, a;
          await this._sendPromise;
          const s = N(e),
            l = {
              safetySettings:
                null === (t = this.params) || void 0 === t
                  ? void 0
                  : t.safetySettings,
              generationConfig:
                null === (n = this.params) || void 0 === n
                  ? void 0
                  : n.generationConfig,
              tools:
                null === (i = this.params) || void 0 === i ? void 0 : i.tools,
              toolConfig:
                null === (r = this.params) || void 0 === r
                  ? void 0
                  : r.toolConfig,
              systemInstruction:
                null === (o = this.params) || void 0 === o
                  ? void 0
                  : o.systemInstruction,
              cachedContent:
                null === (a = this.params) || void 0 === a
                  ? void 0
                  : a.cachedContent,
              contents: [...this._history, s],
            },
            c = k(this._apiKey, this.model, l, this.requestOptions);
          return (
            (this._sendPromise = this._sendPromise
              .then(() => c)
              .catch((e) => {
                throw new Error(F);
              })
              .then((e) => e.response)
              .then((e) => {
                if (e.candidates && e.candidates.length > 0) {
                  this._history.push(s);
                  const t = Object.assign({}, e.candidates[0].content);
                  t.role || (t.role = "model"), this._history.push(t);
                } else {
                  const t = I(e);
                  t &&
                    console.warn(
                      `sendMessageStream() was unsuccessful. ${t}. Inspect response object for details.`
                    );
                }
              })
              .catch((e) => {
                e.message !== F && console.error(e);
              })),
            c
          );
        }
      }
      class $ {
        constructor(e, t, n) {
          (this.apiKey = e),
            t.model.includes("/")
              ? (this.model = t.model)
              : (this.model = `models/${t.model}`),
            (this.generationConfig = t.generationConfig || {}),
            (this.safetySettings = t.safetySettings || []),
            (this.tools = t.tools),
            (this.toolConfig = t.toolConfig),
            (this.systemInstruction = M(t.systemInstruction)),
            (this.cachedContent = t.cachedContent),
            (this.requestOptions = n || {});
        }
        async generateContent(e) {
          var t;
          const n = z(e);
          return O(
            this.apiKey,
            this.model,
            Object.assign(
              {
                generationConfig: this.generationConfig,
                safetySettings: this.safetySettings,
                tools: this.tools,
                toolConfig: this.toolConfig,
                systemInstruction: this.systemInstruction,
                cachedContent:
                  null === (t = this.cachedContent) || void 0 === t
                    ? void 0
                    : t.name,
              },
              n
            ),
            this.requestOptions
          );
        }
        async generateContentStream(e) {
          var t;
          const n = z(e);
          return k(
            this.apiKey,
            this.model,
            Object.assign(
              {
                generationConfig: this.generationConfig,
                safetySettings: this.safetySettings,
                tools: this.tools,
                toolConfig: this.toolConfig,
                systemInstruction: this.systemInstruction,
                cachedContent:
                  null === (t = this.cachedContent) || void 0 === t
                    ? void 0
                    : t.name,
              },
              n
            ),
            this.requestOptions
          );
        }
        startChat(e) {
          var t;
          return new U(
            this.apiKey,
            this.model,
            Object.assign(
              {
                generationConfig: this.generationConfig,
                safetySettings: this.safetySettings,
                tools: this.tools,
                toolConfig: this.toolConfig,
                systemInstruction: this.systemInstruction,
                cachedContent:
                  null === (t = this.cachedContent) || void 0 === t
                    ? void 0
                    : t.name,
              },
              e
            ),
            this.requestOptions
          );
        }
        async countTokens(e) {
          const t = (function (e, t) {
            let n = {};
            const i = null != e.generateContentRequest;
            if (e.contents) {
              if (i)
                throw new h(
                  "CountTokensRequest must have one of contents or generateContentRequest, not both."
                );
              n = Object.assign({}, e);
            } else if (i)
              (n = Object.assign({}, e)), (n.generateContentRequest.model = t);
            else {
              const t = N(e);
              n.contents = [t];
            }
            return n;
          })(e, this.model);
          return (async function (e, t, n, i) {
            return (
              await b(t, f.COUNT_TOKENS, e, !1, JSON.stringify(n), i)
            ).json();
          })(this.apiKey, this.model, t, this.requestOptions);
        }
        async embedContent(e) {
          const t = (function (e) {
            if ("string" === typeof e || Array.isArray(e))
              return { content: N(e) };
            return e;
          })(e);
          return (async function (e, t, n, i) {
            return (
              await b(t, f.EMBED_CONTENT, e, !1, JSON.stringify(n), i)
            ).json();
          })(this.apiKey, this.model, t, this.requestOptions);
        }
        async batchEmbedContents(e) {
          return (async function (e, t, n, i) {
            const r = n.requests.map((e) =>
              Object.assign(Object.assign({}, e), { model: t })
            );
            return (
              await b(
                t,
                f.BATCH_EMBED_CONTENTS,
                e,
                !1,
                JSON.stringify({ requests: r }),
                i
              )
            ).json();
          })(this.apiKey, this.model, e, this.requestOptions);
        }
      }
      (t.ChatSession = U),
        (t.GenerativeModel = $),
        (t.GoogleGenerativeAI = class {
          constructor(e) {
            this.apiKey = e;
          }
          getGenerativeModel(e, t) {
            if (!e.model)
              throw new u(
                "Must provide a model name. Example: genai.getGenerativeModel({ model: 'my-model-name' })"
              );
            return new $(this.apiKey, e, t);
          }
          getGenerativeModelFromCachedContent(e, t) {
            if (!e.name)
              throw new h("Cached content must contain a `name` field.");
            if (!e.model)
              throw new h("Cached content must contain a `model` field.");
            const n = {
              model: e.model,
              tools: e.tools,
              toolConfig: e.toolConfig,
              systemInstruction: e.systemInstruction,
              cachedContent: e,
            };
            return new $(this.apiKey, n, t);
          }
        }),
        (t.GoogleGenerativeAIError = u),
        (t.GoogleGenerativeAIFetchError = m),
        (t.GoogleGenerativeAIRequestInputError = h),
        (t.GoogleGenerativeAIResponseError = d),
        (t.POSSIBLE_ROLES = i);
    },
    924190: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.parseSupportedAudioFormatFromMimeType =
          t.isSupportedAudioFormat =
          t.SUPPORTED_AUDIO_FORMATS =
            void 0);
      const i = n(312093);
      t.SUPPORTED_AUDIO_FORMATS = ["webm", "wav", "mp4"];
      t.isSupportedAudioFormat = (e) => t.SUPPORTED_AUDIO_FORMATS.includes(e);
      t.parseSupportedAudioFormatFromMimeType = (e) => {
        var n;
        if (i.G.isNullable(e)) return null;
        const r =
          null === (n = /^audio\/(.+)$/.exec(e)) || void 0 === n
            ? void 0
            : n[1];
        return (0, t.isSupportedAudioFormat)(r) ? r : null;
      };
    },
    558287: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.CoerceStrippedUrlZodSchema = t.CoerceUrlZodSchema = void 0);
      const i = n(689510);
      (t.CoerceUrlZodSchema = i.z.coerce
        .string()
        .transform((e) => (e.includes("://") ? e : "http://" + e))
        .superRefine((e, t) => {
          try {
            const n = new URL(e);
            "https:" !== n.protocol &&
              "http:" !== n.protocol &&
              t.addIssue({
                code: i.z.ZodIssueCode.custom,
                message: "unexpected protocol",
              });
          } catch (n) {
            t.addIssue({
              code: i.z.ZodIssueCode.custom,
              message: "not a valid URL",
            });
          }
        })),
        (t.CoerceStrippedUrlZodSchema = i.z.coerce
          .string()
          .transform((e, t) => {
            try {
              return new URL(e.includes("://") ? e : "http://" + e);
            } catch (n) {
              return (
                t.addIssue({
                  code: i.z.ZodIssueCode.custom,
                  message: "not a valid URL",
                  fatal: !0,
                }),
                i.z.NEVER
              );
            }
          })
          .refine((e) => "https:" === e.protocol || "http:" === e.protocol, {
            message: "unexpected protocol",
          })
          .transform((e) => e.hostname + e.pathname)
          .transform((e) =>
            e.endsWith("/") ? e.substring(0, e.length - 1) : e
          ));
    },
    790767: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.ALL_AI_USER_AGENT_TOKENS =
          t.CustomerToUserAgentTokensMap =
          t.MmCustomer =
          t.SCALE_BOT_USER_AGENT =
          t.COMMON_CRAWL_BOT_USER_AGENT_TOKEN =
          t.SCALE_BOT_USER_AGENT_TOKEN =
            void 0);
      const i = n(312093);
      var r;
      (t.SCALE_BOT_USER_AGENT_TOKEN = "Remo"),
        (t.COMMON_CRAWL_BOT_USER_AGENT_TOKEN = "CCBot"),
        (t.SCALE_BOT_USER_AGENT = `Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36 (compatible: ${t.SCALE_BOT_USER_AGENT_TOKEN}/0.1; +https://www.remotasks.com/en/info.txt)`),
        (function (e) {
          (e.Abra = "abra"),
            (e.Alpaca = "alpaca"),
            (e.Bulbasaur = "bulbasaur"),
            (e.Crab = "crab"),
            (e.Flamingo = "flamingo"),
            (e.Gorilla = "gorilla"),
            (e.Ostrich = "ostrich");
        })(r || (t.MmCustomer = r = {})),
        (t.CustomerToUserAgentTokensMap = {
          [r.Abra]: ["ClaudeBot"],
          [r.Alpaca]: ["Amazonbot"],
          [r.Bulbasaur]: ["Google-Extended"],
          [r.Crab]: ["cohere-ai"],
          [r.Flamingo]: ["FacebookBot"],
          [r.Gorilla]: ["Google-Extended"],
          [r.Ostrich]: ["GPTBot"],
        }),
        (t.ALL_AI_USER_AGENT_TOKENS = i.A.uniq([
          t.COMMON_CRAWL_BOT_USER_AGENT_TOKEN,
          t.SCALE_BOT_USER_AGENT_TOKEN,
          ...Object.values(t.CustomerToUserAgentTokensMap).flat(),
        ]));
    },
    68442: function (e, t) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.ImageValidationError = void 0);
      class n extends Error {
        constructor() {
          super(), (this.name = "ImageValidationError");
        }
      }
      t.ImageValidationError = n;
    },
    211870: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.MAXIMUM_MS_THAT_FRONTEND_SHOULD_WAIT_FOR_RESPONSE_FROM_SERVER =
          t.convertImageExtensionToMimeType =
          t.convertImageMimeTypeToExtension =
          t.isSupportedImageMimeType =
          t.SUPPORTED_IMAGE_MIME_TYPES =
          t.MAX_PER_REQUEST_INGESTION_COUNT =
          t.ImageQueryFiltersSchema =
          t.ImageSearchType =
          t.BatchOperationType =
          t.DEFAULT_DOMAIN_BLOCKLIST =
          t.DEFAULT_CATEGORY_BLOCKLIST =
          t.MultimodalAssetEntitySchema =
          t.ImageExtension =
          t.ImageCategory =
          t.ImageLicense =
          t.HashType =
            void 0);
      const i = n(689510);
      var r, o, a, s;
      !(function (e) {
        (e.SHA256 = "sha256"), (e.BBMV256 = "bbmv256");
      })(r || (t.HashType = r = {})),
        (function (e) {
          (e.CC0 = "CC0"),
            (e.CC_BY = "CC BY"),
            (e.CC_BY_SA = "CC BY-SA"),
            (e.PD = "PD");
        })(o || (t.ImageLicense = o = {})),
        (function (e) {
          (e.NATURAL = "natural"),
            (e.QUANTITATIVE = "quantitative"),
            (e.MMMU = "mmmu"),
            (e.UNVALIDATED = "unvalidated"),
            (e.ART = "art"),
            (e.BUSINESS = "business"),
            (e.SCIENCE = "science"),
            (e.HEALTH = "health"),
            (e.HUMANITIES = "humanities"),
            (e.TECH = "tech");
        })(a || (t.ImageCategory = a = {})),
        (function (e) {
          (e.PNG = "png"),
            (e.JPEG = "jpeg"),
            (e.WEBP = "webp"),
            (e.SVG = "svg");
        })(s || (t.ImageExtension = s = {}));
      const l = i.z.object({
        task_id: i.z.string(),
        project_id: i.z.string(),
        assigned_to_task: i.z.coerce.date(),
      });
      var c, p;
      (t.MultimodalAssetEntitySchema = i.z.object({
        image_url: i.z.string(),
        image_domain: i.z.string(),
        image_size: i.z.number(),
        image_dimensions: i.z.object({
          width: i.z.number(),
          height: i.z.number(),
        }),
        image_extension: i.z.nativeEnum(s),
        image_hashes: i.z.record(i.z.string()),
        image_licenses: i.z.array(i.z.nativeEnum(o)),
        image_category: i.z.array(i.z.nativeEnum(a)),
        ingestion_date: i.z.coerce.date(),
        tasks: i.z.array(l),
        invalid_hash: i.z.boolean(),
        image_embedding: i.z.optional(i.z.array(i.z.number())),
        image_description: i.z.optional(i.z.string()),
        language: i.z.optional(i.z.string()),
        clicked_on_count: i.z.optional(i.z.number()),
        added_to_task_count: i.z.optional(i.z.number()),
        flagged_low_quality_count: i.z.optional(i.z.number()),
      })),
        (t.DEFAULT_CATEGORY_BLOCKLIST = [a.MMMU, a.UNVALIDATED]),
        (t.DEFAULT_DOMAIN_BLOCKLIST = []),
        (function (e) {
          e.CREATE = "create";
        })(c || (t.BatchOperationType = c = {})),
        (function (e) {
          (e.CLIP = "clip"), (e.LEXICAL = "lexical");
        })(p || (t.ImageSearchType = p = {})),
        (t.ImageQueryFiltersSchema = i.z.object({
          numResults: i.z.number(),
          projectId: i.z.string(),
          searchType: i.z.nativeEnum(p),
          from: i.z.number().optional(),
          queryText: i.z.string().optional(),
          minDimensionsPx: i.z.number().optional(),
          maxDimensionsPx: i.z.number().optional(),
          minFileSizeKB: i.z.number().optional(),
          maxFileSizeKB: i.z.number().optional(),
          blockedDomainsList: i.z.string().array().optional(),
          allowedDomainsList: i.z.string().array().optional(),
          allowedLicenses: i.z.nativeEnum(o).array().optional(),
          allowedCategories: i.z.nativeEnum(a).array().optional(),
          allowedExtensions: i.z.nativeEnum(s).array().optional(),
          allowedLanguages: i.z.string().array().optional(),
        })),
        (t.MAX_PER_REQUEST_INGESTION_COUNT = 1e5),
        (t.SUPPORTED_IMAGE_MIME_TYPES = [
          "image/jpg",
          "image/jpeg",
          "image/png",
          "image/svg+xml",
          "image/webp",
        ]);
      t.isSupportedImageMimeType = (e) =>
        t.SUPPORTED_IMAGE_MIME_TYPES.includes(e);
      t.convertImageMimeTypeToExtension = (e) => {
        switch (e) {
          case "image/jpg":
          case "image/jpeg":
            return s.JPEG;
          case "image/png":
            return s.PNG;
          case "image/svg+xml":
            return s.SVG;
          case "image/webp":
            return s.WEBP;
        }
      };
      (t.convertImageExtensionToMimeType = (e) => {
        switch (e) {
          case s.JPEG:
            return "image/jpeg";
          case s.PNG:
            return "image/png";
          case s.SVG:
            return "image/svg+xml";
          case s.WEBP:
            return "image/webp";
        }
      }),
        (t.MAXIMUM_MS_THAT_FRONTEND_SHOULD_WAIT_FOR_RESPONSE_FROM_SERVER = 3e4);
    },
    64371: function (e, t, n) {
      "use strict";
      var i =
          (this && this.__createBinding) ||
          (Object.create
            ? function (e, t, n, i) {
                void 0 === i && (i = n);
                var r = Object.getOwnPropertyDescriptor(t, n);
                (r &&
                  !("get" in r
                    ? !t.__esModule
                    : r.writable || r.configurable)) ||
                  (r = {
                    enumerable: !0,
                    get: function () {
                      return t[n];
                    },
                  }),
                  Object.defineProperty(e, i, r);
              }
            : function (e, t, n, i) {
                void 0 === i && (i = n), (e[i] = t[n]);
              }),
        r =
          (this && this.__exportStar) ||
          function (e, t) {
            for (var n in e)
              "default" === n ||
                Object.prototype.hasOwnProperty.call(t, n) ||
                i(t, e, n);
          };
      Object.defineProperty(t, "__esModule", { value: !0 }),
        r(n(924190), t),
        r(n(558287), t),
        r(n(790767), t),
        r(n(68442), t),
        r(n(211870), t);
    },
    687449: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.AudioAttachmentDtoSchema =
          t.AUDIO_PROCESSING_STATES =
          t.AudioMetadataSchema =
            void 0);
      const i = n(924190),
        r = n(689510);
      (t.AudioMetadataSchema = r.z.object({
        duration: r.z.coerce.number().nonnegative(),
      })),
        (t.AUDIO_PROCESSING_STATES = [
          "not_started",
          "processing",
          "completed",
          "failed",
        ]),
        (t.AudioAttachmentDtoSchema = r.z.object({
          url: r.z.string().url(),
          format: r.z.enum(i.SUPPORTED_AUDIO_FORMATS),
          processingState: r.z.enum(t.AUDIO_PROCESSING_STATES),
          processingWorkflowId: r.z.string().optional(),
          workerId: r.z.string().optional(),
          userGeneratedAudio: r.z.boolean().optional(),
          duration: r.z.number().nonnegative().optional(),
          transcriptUrl: r.z.string().url().optional(),
          transcriptText: r.z.string().optional(),
          transcriptJsonUrl: r.z.string().url().optional(),
          transcriptStart: r.z.number().nonnegative().optional(),
          transcriptEnd: r.z.number().nonnegative().optional(),
          metadata: r.z.any(),
        }));
    },
    465245: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.ImageServiceAggregationsKeys =
          t.MECEAggregations =
          t.ImageServiceAggregationsAndHitsSchema =
          t.ImageServiceAggregationsSchema =
          t.ImageServiceAggregationEntrySchema =
            void 0);
      const i = n(689510);
      (t.ImageServiceAggregationEntrySchema = i.z.object({
        key: i.z.string(),
        doc_count: i.z.number(),
        fill: i.z.optional(i.z.string()),
      })),
        (t.ImageServiceAggregationsSchema = i.z.object({
          category_counts: i.z.array(t.ImageServiceAggregationEntrySchema),
          image_extension_count: i.z.array(
            t.ImageServiceAggregationEntrySchema
          ),
          language_counts: i.z.array(t.ImageServiceAggregationEntrySchema),
          licenses_count: i.z.array(t.ImageServiceAggregationEntrySchema),
          height_ranges: i.z.array(t.ImageServiceAggregationEntrySchema),
          width_ranges: i.z.array(t.ImageServiceAggregationEntrySchema),
          image_domain: i.z.array(t.ImageServiceAggregationEntrySchema),
        })),
        (t.ImageServiceAggregationsAndHitsSchema = i.z.object({
          metrics: t.ImageServiceAggregationsSchema,
          totalHits: i.z.number(),
        })),
        (t.MECEAggregations = [
          "image_extension_count",
          "licenses_count",
          "image_domain",
        ]),
        (t.ImageServiceAggregationsKeys = Object.keys(
          t.ImageServiceAggregationsSchema.shape
        ));
    },
    242625: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.FetchImageMetadataRequestPayloadSchema =
          t.ValidateAndMirrorUrlRequestPayloadSchema =
          t.ValidateImageUrlRequestPayloadSchema =
          t.MultimodalAssetDtoSchema =
            void 0);
      const i = n(689510),
        r = n(64371);
      (t.MultimodalAssetDtoSchema = r.MultimodalAssetEntitySchema.omit({
        tasks: !0,
      })),
        (t.ValidateImageUrlRequestPayloadSchema = i.z.object({
          url: r.CoerceUrlZodSchema,
          config: i.z.any(),
          projectId: i.z.string().optional(),
        })),
        (t.ValidateAndMirrorUrlRequestPayloadSchema = i.z.object({
          url: r.CoerceUrlZodSchema,
          assignmentId: i.z.string(),
        })),
        (t.FetchImageMetadataRequestPayloadSchema = i.z.object({
          url: r.CoerceUrlZodSchema,
          projectId: i.z.string().optional(),
        }));
    },
    416057: function (e, t, n) {
      "use strict";
      var i =
          (this && this.__createBinding) ||
          (Object.create
            ? function (e, t, n, i) {
                void 0 === i && (i = n);
                var r = Object.getOwnPropertyDescriptor(t, n);
                (r &&
                  !("get" in r
                    ? !t.__esModule
                    : r.writable || r.configurable)) ||
                  (r = {
                    enumerable: !0,
                    get: function () {
                      return t[n];
                    },
                  }),
                  Object.defineProperty(e, i, r);
              }
            : function (e, t, n, i) {
                void 0 === i && (i = n), (e[i] = t[n]);
              }),
        r =
          (this && this.__exportStar) ||
          function (e, t) {
            for (var n in e)
              "default" === n ||
                Object.prototype.hasOwnProperty.call(t, n) ||
                i(t, e, n);
          };
      Object.defineProperty(t, "__esModule", { value: !0 }),
        r(n(687449), t),
        r(n(242625), t),
        r(n(986096), t),
        r(n(618348), t),
        r(n(465245), t),
        r(n(823656), t);
    },
    618348: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.SerpImageSearchResponseSchema = t.SerpImageResultSchema = void 0);
      const i = n(689510);
      (t.SerpImageResultSchema = i.z.object({ original: i.z.string().url() })),
        (t.SerpImageSearchResponseSchema = i.z.object({
          images_results: t.SerpImageResultSchema.array().default([]),
        }));
    },
    986096: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.SpawningApiOptsApiQueryDomainsResponseDtoSchema =
          t.SpawningApiOptsApiQueryUrlsResponseDtoSchema =
            void 0);
      const i = n(689510);
      (t.SpawningApiOptsApiQueryUrlsResponseDtoSchema = i.z.object({
        urls: i.z.array(
          i.z.object({
            url: i.z.string(),
            optOut: i.z.boolean().optional(),
            optIn: i.z.boolean().optional(),
            details: i.z.unknown().optional(),
          })
        ),
      })),
        (t.SpawningApiOptsApiQueryDomainsResponseDtoSchema = i.z.object({
          domains: i.z.array(
            i.z.object({
              domain: i.z.string(),
              optOut: i.z.boolean().optional(),
              optIn: i.z.boolean().optional(),
            })
          ),
        }));
    },
    823656: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.TinEyeSearchUrlResponseDtoSchema = void 0);
      const i = n(689510);
      t.TinEyeSearchUrlResponseDtoSchema = i.z.object({
        stats: i.z
          .object({
            timestamp: i.z.coerce.number().optional(),
            query_time: i.z.coerce.number().optional(),
            total_backlinks: i.z.coerce.number().optional(),
            total_collection: i.z.coerce.number().optional(),
            total_results: i.z.coerce.number().optional(),
            total_stock: i.z.coerce.number().optional(),
            total_filtered_results: i.z.coerce.number().optional(),
          })
          .optional(),
        code: i.z.unknown().optional(),
        messages: i.z.unknown().optional(),
        matches: i.z.unknown(),
      });
    },
    561630: function (e, t, n) {
      "use strict";
      var i =
          (this && this.__createBinding) ||
          (Object.create
            ? function (e, t, n, i) {
                void 0 === i && (i = n);
                var r = Object.getOwnPropertyDescriptor(t, n);
                (r &&
                  !("get" in r
                    ? !t.__esModule
                    : r.writable || r.configurable)) ||
                  (r = {
                    enumerable: !0,
                    get: function () {
                      return t[n];
                    },
                  }),
                  Object.defineProperty(e, i, r);
              }
            : function (e, t, n, i) {
                void 0 === i && (i = n), (e[i] = t[n]);
              }),
        r =
          (this && this.__exportStar) ||
          function (e, t) {
            for (var n in e)
              "default" === n ||
                Object.prototype.hasOwnProperty.call(t, n) ||
                i(t, e, n);
          };
      Object.defineProperty(t, "__esModule", { value: !0 }),
        r(n(64371), t),
        r(n(416057), t),
        r(n(421114), t),
        r(n(92904), t);
    },
    582462: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.AudioServiceGetAudioMetricsRequestBodySchema =
          t.AudioServiceSplitAudioChannelsRequestBodySchema =
          t.AudioServiceCombineAudioRequestBodySchema =
          t.AudioServiceGetSourceRequestBodySchema =
          t.AudioServiceGetTranscriptRequestBodySchema =
          t.AudioServiceGetMetadataRequestBodySchema =
          t.ProcessAudioAttachmentRequestBodySchema =
            void 0);
      const i = n(64371),
        r = n(689510);
      (t.ProcessAudioAttachmentRequestBodySchema = r.z.object({
        audioUrl: r.z.coerce.string().url(),
        audioFormat: r.z.enum(i.SUPPORTED_AUDIO_FORMATS).optional(),
        assignmentId: r.z.coerce.string().optional(),
        workerId: r.z.coerce.string().optional(),
        userGeneratedAudio: r.z.boolean(),
      })),
        (t.AudioServiceGetMetadataRequestBodySchema = r.z.object({
          audioUrl: r.z.coerce.string().url(),
          audioFormat: r.z.enum(i.SUPPORTED_AUDIO_FORMATS),
        })),
        (t.AudioServiceGetTranscriptRequestBodySchema = r.z.object({
          audioUrl: r.z.coerce.string().url(),
        })),
        (t.AudioServiceGetSourceRequestBodySchema = r.z.object({
          audioUrl: r.z.coerce.string().url(),
        })),
        (t.AudioServiceCombineAudioRequestBodySchema = r.z.object({
          audioUrl1: r.z.coerce.string().url(),
          audioUrl2: r.z.coerce.string().url(),
          assignmentId: r.z.coerce.string().optional(),
          workerId: r.z.coerce.string().optional(),
          projectId: r.z.coerce.string().optional(),
        })),
        (t.AudioServiceSplitAudioChannelsRequestBodySchema = r.z.object({
          audioUrl: r.z.coerce.string().url(),
          assignmentId: r.z.coerce.string().optional(),
          workerId: r.z.coerce.string().optional(),
          projectId: r.z.coerce.string().optional(),
        })),
        (t.AudioServiceGetAudioMetricsRequestBodySchema = r.z.object({
          audioUrl: r.z.coerce.string().url(),
        }));
    },
    921244: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.ContentUnderstandingUploadResponseBodySchema =
          t.ContentUnderstandingUploadResponseErrorSchema =
          t.ContentUnderstandingUploadResponseSuccessSchema =
            void 0);
      const i = n(689510);
      (t.ContentUnderstandingUploadResponseSuccessSchema = i.z.object({
        s3Url: i.z.string().url(),
        url: i.z.string().url(),
        type: i.z.literal("success"),
      })),
        (t.ContentUnderstandingUploadResponseErrorSchema = i.z.object({
          type: i.z.literal("error"),
          errors: i.z.array(i.z.string()),
        })),
        (t.ContentUnderstandingUploadResponseBodySchema =
          i.z.discriminatedUnion("type", [
            t.ContentUnderstandingUploadResponseSuccessSchema,
            t.ContentUnderstandingUploadResponseErrorSchema,
          ]));
    },
    421114: function (e, t, n) {
      "use strict";
      var i =
          (this && this.__createBinding) ||
          (Object.create
            ? function (e, t, n, i) {
                void 0 === i && (i = n);
                var r = Object.getOwnPropertyDescriptor(t, n);
                (r &&
                  !("get" in r
                    ? !t.__esModule
                    : r.writable || r.configurable)) ||
                  (r = {
                    enumerable: !0,
                    get: function () {
                      return t[n];
                    },
                  }),
                  Object.defineProperty(e, i, r);
              }
            : function (e, t, n, i) {
                void 0 === i && (i = n), (e[i] = t[n]);
              }),
        r =
          (this && this.__exportStar) ||
          function (e, t) {
            for (var n in e)
              "default" === n ||
                Object.prototype.hasOwnProperty.call(t, n) ||
                i(t, e, n);
          };
      Object.defineProperty(t, "__esModule", { value: !0 }),
        r(n(582462), t),
        r(n(921244), t);
    },
    780682: function (e, t, n) {
      "use strict";
      var i =
        (this && this.__importDefault) ||
        function (e) {
          return e && e.__esModule ? e : { default: e };
        };
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.mapErrorToGoogleDocLink =
          t.getAudioMetricsErrors =
          t.hasRequiredAudioMetrics =
          t.formatMaybeErrorForLogging =
          t.ErrorType =
            void 0);
      const r = n(312093),
        o = i(n(298784));
      var a;
      !(function (e) {
        (e.BackgroundNoise =
          "Background noise is too high -- make sure you're in a quiet environment"),
          (e.Clipping =
            "Speech volume is clipping -- make sure you're far enough away from your microphone"),
          (e.AverageSpeechVolumeTooLow =
            "Average speech volume is low -- make sure you're close enough to your microphone"),
          (e.AverageSpeechVolumeTooHigh =
            "Average speech volume is high -- make sure you're far enough away from your microphone"),
          (e.SpeechQualityTooLow =
            "Speech quality is low -- make sure you're in a quiet environment and speaking clearly");
      })(a || (t.ErrorType = a = {}));
      t.formatMaybeErrorForLogging = (e) =>
        r.G.isString(e) || r.G.isNumber(e) || r.G.isBoolean(e)
          ? e
          : r.G.isArray(e)
          ? e.map(t.formatMaybeErrorForLogging)
          : r.G.isObject(e)
          ? r.G.isError(e)
            ? { name: e.name, message: e.message, stack: e.stack }
            : e instanceof Date
            ? e.toISOString()
            : r.D.fromPairs(
                r.D.toPairs(e).map(([e, n]) => [
                  r.S.make(e),
                  (0, t.formatMaybeErrorForLogging)(n),
                ])
              )
          : void 0;
      t.hasRequiredAudioMetrics = (e, t) => {
        var n, i;
        const {
          minBackgroundNoiseScore: r,
          minOverallSpeechScore: a,
          minAverageVolume: s,
          maxAverageVolume: l,
          maxVolume: c,
          maxAmbientNoiseVolume: p,
        } = null !== t && void 0 !== t ? t : {};
        return (
          !(
            !o.default.isNil(null !== r && void 0 !== r ? r : a) &&
            o.default.isNil(
              null === e || void 0 === e ? void 0 : e.speechQualityScores
            )
          ) &&
          !(
            !o.default.isNil(
              null !==
                (i =
                  null !== (n = null !== s && void 0 !== s ? s : l) &&
                  void 0 !== n
                    ? n
                    : c) && void 0 !== i
                ? i
                : p
            ) &&
            o.default.isNil(
              null === e || void 0 === e ? void 0 : e.volumeMetrics
            )
          )
        );
      };
      t.getAudioMetricsErrors = (e, n) => {
        if (!(0, t.hasRequiredAudioMetrics)(e, n)) return [];
        const {
            minBackgroundNoiseScore: i,
            minOverallSpeechScore: r,
            minAverageVolume: s,
            maxAverageVolume: l,
            maxVolume: c,
            maxAmbientNoiseVolume: p,
          } = null !== n && void 0 !== n ? n : {},
          u = null === e || void 0 === e ? void 0 : e.volumeMetrics,
          d = null === e || void 0 === e ? void 0 : e.speechQualityScores,
          m = [];
        return (
          ((!o.default.isNil(p) &&
            void 0 !==
              (null === u || void 0 === u ? void 0 : u.averageAmbientVolume) &&
            (null === u || void 0 === u ? void 0 : u.averageAmbientVolume) >
              p) ||
            (!o.default.isNil(i) &&
              void 0 !== (null === d || void 0 === d ? void 0 : d.bgNoise) &&
              (null === d || void 0 === d ? void 0 : d.bgNoise) < i)) &&
            m.push(a.BackgroundNoise),
          !o.default.isNil(c) &&
            void 0 !==
              (null === u || void 0 === u ? void 0 : u.maxSpeechVolume) &&
            (null === u || void 0 === u ? void 0 : u.maxSpeechVolume) > c &&
            m.push(a.Clipping),
          !o.default.isNil(s) &&
            void 0 !==
              (null === u || void 0 === u ? void 0 : u.averageSpeechVolume) &&
            (null === u || void 0 === u ? void 0 : u.averageSpeechVolume) < s &&
            m.push(a.AverageSpeechVolumeTooLow),
          !o.default.isNil(l) &&
            void 0 !==
              (null === u || void 0 === u ? void 0 : u.averageSpeechVolume) &&
            (null === u || void 0 === u ? void 0 : u.averageSpeechVolume) > l &&
            m.push(a.AverageSpeechVolumeTooHigh),
          !o.default.isNil(r) &&
            void 0 !== (null === d || void 0 === d ? void 0 : d.overall) &&
            (null === d || void 0 === d ? void 0 : d.overall) < r &&
            m.push(a.SpeechQualityTooLow),
          m
        );
      };
      t.mapErrorToGoogleDocLink = (e) =>
        e === a.BackgroundNoise
          ? "https://docs.google.com/document/d/1N1OGF6Uk7axqbYQyMfZHjWQaiaBGYKRIKd2hzXRx7gQ/edit?tab=t.0"
          : e === a.Clipping
          ? "https://docs.google.com/document/d/1rpOdMg_82Cgu5EmOdLklK0AZRobcu4DpgPbaVW5w-As/edit?tab=t.0"
          : e === a.AverageSpeechVolumeTooLow
          ? "https://docs.google.com/document/d/1uZ734Wxn53gfhURRpNiTqyUJ52ITBcQ47KZsSCLvZaE/edit?tab=t.0"
          : e === a.AverageSpeechVolumeTooHigh
          ? "https://docs.google.com/document/d/1UYxcyZ1G_Kt6lqtP7QhmwresJQePu_wXaFZiw6Kc4iY/edit?tab=t.0"
          : void 0;
    },
    126855: function (e, t, n) {
      "use strict";
      var i =
        (this && this.__importDefault) ||
        function (e) {
          return e && e.__esModule ? e : { default: e };
        };
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.checkRobotsIfCrawlingDisallowed =
          t.getShortedDisallowedPathFromRobots =
          t.createAxiosInstance =
            void 0);
      const r = n(312093),
        o = i(n(514206)),
        a = i(n(991790)),
        s = n(64371);
      t.createAxiosInstance = () =>
        o.default.create({ headers: { "User-Agent": s.SCALE_BOT_USER_AGENT } });
      t.getShortedDisallowedPathFromRobots = async (e, n) => {
        var i;
        const { timeout: o } = null !== n && void 0 !== n ? n : {},
          { hostname: l, pathname: c } = new URL(e),
          p =
            null !== (i = null === n || void 0 === n ? void 0 : n.client) &&
            void 0 !== i
              ? i
              : (0, t.createAxiosInstance)(),
          u = `http://${l}/robots.txt`,
          d = await (async () => {
            try {
              const e = await p.get(
                u,
                Object.assign({}, o ? { timeout: o } : {})
              );
              if (e.status >= 200 && e.status < 300)
                return (0, a.default)(u, e.data);
            } catch (i) {}
            return null;
          })();
        if (null === d) return null;
        let m = c,
          h = null;
        for (
          ;
          "" !== h &&
          "/" !== h &&
          s.ALL_AI_USER_AGENT_TOKENS.some((e) =>
            d.isDisallowed(`http://${l}${m}`, e)
          );

        )
          (h = m),
            (m = m.substring(
              0,
              (0, r.pipe)(m.lastIndexOf("/"), (e) => (e < 0 ? 0 : e))
            ));
        return h;
      };
      t.checkRobotsIfCrawlingDisallowed = async (e, n) => {
        var i;
        const { timeout: r } = null !== n && void 0 !== n ? n : {},
          { hostname: o, pathname: l } = new URL(e),
          c =
            null !== (i = null === n || void 0 === n ? void 0 : n.client) &&
            void 0 !== i
              ? i
              : (0, t.createAxiosInstance)(),
          p = `http://${o}/robots.txt`,
          u = `http://${o}${l}`,
          d = await (async () => {
            try {
              const e = await c.get(
                p,
                Object.assign({}, r ? { timeout: r } : {})
              );
              if (e.status >= 200 && e.status < 300)
                return (0, a.default)(p, e.data);
            } catch (i) {}
            return null;
          })();
        return (
          null !== d &&
          s.ALL_AI_USER_AGENT_TOKENS.some((e) => d.isDisallowed(u, e))
        );
      };
    },
    92904: function (e, t, n) {
      "use strict";
      var i =
          (this && this.__createBinding) ||
          (Object.create
            ? function (e, t, n, i) {
                void 0 === i && (i = n);
                var r = Object.getOwnPropertyDescriptor(t, n);
                (r &&
                  !("get" in r
                    ? !t.__esModule
                    : r.writable || r.configurable)) ||
                  (r = {
                    enumerable: !0,
                    get: function () {
                      return t[n];
                    },
                  }),
                  Object.defineProperty(e, i, r);
              }
            : function (e, t, n, i) {
                void 0 === i && (i = n), (e[i] = t[n]);
              }),
        r =
          (this && this.__exportStar) ||
          function (e, t) {
            for (var n in e)
              "default" === n ||
                Object.prototype.hasOwnProperty.call(t, n) ||
                i(t, e, n);
          };
      Object.defineProperty(t, "__esModule", { value: !0 }),
        r(n(780682), t),
        r(n(126855), t);
    },
    120593: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.extractVariablesFromString = function (e) {
          const t = /{%\s*(if|elsif)\s+(\w+)\s*(==|>|<|>=|<=|!=)/g,
            n = e.match(/{{(.*?)}}/g),
            i = n
              ? r.default.uniq(n.map((e) => e.replace(/{{|}}/g, "").trim()))
              : [];
          return (
            e.match(t)?.forEach((e) => {
              const t = e.match(/\b\w+\b/g);
              t &&
                t.forEach((e) => {
                  ["if", "elsif"].includes(e) || i.includes(e) || i.push(e);
                });
            }),
            r.default.uniq(i)
          );
        }),
        (t.fillTemplate = function ({ template: e, variableMapping: t }) {
          try {
            const n = (function (e) {
              const t = {};
              for (const n in e) {
                const i = e[n];
                t[n] = "string" === typeof i ? a(i) : i;
              }
              return t;
            })(t);
            return o.parseAndRenderSync(e, n) ?? "";
          } catch {
            return "";
          }
        });
      var i,
        r = (i = n(298784)) && i.__esModule ? i : { default: i };
      const o = new (n(284040).Liquid)({
        strictFilters: !0,
        strictVariables: !1,
      });
      function a(e) {
        return e
          .replace(/"/g, '\\"')
          .replace(/\n/g, "\\n")
          .replace(/\t/g, "\\t");
      }
    },
    900218: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.isVisibleInLowerReviewLevel = function (e, t) {
          const n = i.default.filter(
            i.default.values(s.ReviewLevel),
            (e) => e <= t
          );
          return i.default.some(n, (t) => h(e, t));
        }),
        (t.producePromptWithReferenceTexts = g),
        (t.getMostRecentModelSelectorResponseForTurn = y),
        (t.getTurnCount =
          t.constructChatHistory =
          t.isConditionallyVisible =
          t.isStepVisible =
          t.isStepSequentiallySkippedAndVisible =
          t.getEmptyContextForStepType =
          t.getNullContextForStepType =
            void 0);
      var i = d(n(298784)),
        r = d(n(711719)),
        o = n(854358),
        a = n(963494),
        s = n(599789),
        l = n(907777),
        c = n(959944),
        p = n(844159),
        u = (function (e) {
          if (e && e.__esModule) return e;
          var t = {};
          if (null != e)
            for (var n in e)
              if (Object.prototype.hasOwnProperty.call(e, n)) {
                var i =
                  Object.defineProperty && Object.getOwnPropertyDescriptor
                    ? Object.getOwnPropertyDescriptor(e, n)
                    : {};
                i.get || i.set ? Object.defineProperty(t, n, i) : (t[n] = e[n]);
              }
          return (t.default = e), t;
        })(n(120593));
      function d(e) {
        return e && e.__esModule ? e : { default: e };
      }
      Object.keys(u).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          ((e in t && t[e] === u[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return u[e];
              },
            }));
      });
      const m = (e) => {
        switch (e) {
          case o.InteractionStepType.MetadataViewer:
          case o.InteractionStepType.ContextDirections:
          case o.InteractionStepType.Instruction:
          case o.InteractionStepType.PromptInput:
            return {};
          case o.InteractionStepType.MultiTurnContinue:
            return { message: "", shouldContinue: !0 };
          case o.InteractionStepType.ModelResponseSelector:
            return {
              messages: [],
              candidates: [],
              displayOrder: [],
              selectedIndex: -1,
              selectedId: "",
            };
          case o.InteractionStepType.QuantitativeModelResponseSelector:
            return {
              candidates: [],
              selectedId: "",
              response: { annotations: {} },
            };
          case o.InteractionStepType.ModelResponseEditor:
            return { baseResponse: "", originalText: "" };
          case o.InteractionStepType.MetadataEditor:
            return { baseMetadata: "", metadataType: "plaintext" };
          case o.InteractionStepType.ModelResponseRanking:
            return { rankedCandidates: [] };
          case o.InteractionStepType.PromptTextCollection:
          case o.InteractionStepType.QIRTextCollection:
          case o.InteractionStepType.QualityMeasurement:
          case o.InteractionStepType.TextCollection:
            return { response: { annotations: {} } };
          case o.InteractionStepType.TextCollectionPerResponse:
            return { candidates: [], annotations: {} };
          case o.InteractionStepType.ProcessSupervision:
            return { chunks: [] };
          case o.InteractionStepType.SpanFeedback:
            return { comments: [] };
          case o.InteractionStepType.ExperimentalToolUse:
            return { chunks: [], shouldContinue: !1 };
          default:
            return {};
        }
      };
      t.getNullContextForStepType = m;
      t.getEmptyContextForStepType = (e) => {
        switch (e.type) {
          case o.InteractionStepType.ContextDirections:
          case o.InteractionStepType.Instruction:
            return {};
          case o.InteractionStepType.ModelResponseSelector:
            return {
              messages: [],
              candidates: [],
              displayOrder: [],
              selectedIndex: e.params.skip_selection ? -1 : 0,
              selectedId: "",
            };
          case o.InteractionStepType.MultiTurnContinue:
            return { message: "", shouldContinue: !0 };
          case o.InteractionStepType.NER:
            return { response: { annotations: [] } };
          case o.InteractionStepType.PromptInput:
            return {};
          case o.InteractionStepType.QIRTextCollection:
            return { response: { annotations: {} } };
          case o.InteractionStepType.SearchAutoComplete:
            return {
              prompt: "",
              candidates: [],
              searchHistory: [],
              additionalReferences: [],
            };
          case o.InteractionStepType.SearchReferences:
            return { prompt: "", candidates: [], additionalReferences: [] };
          case o.InteractionStepType.ProcessSupervision:
          case o.InteractionStepType.ExperimentalToolUse:
          case o.InteractionStepType.ToolUseProcessSupervision:
            return { chunks: [] };
          case o.InteractionStepType.SpanFeedback:
            return { comments: [] };
          case o.InteractionStepType.ChainOfThought:
            return { responses: [] };
          default:
            return {};
        }
      };
      t.isStepSequentiallySkippedAndVisible = (e, t, n, i) => {
        const r = t.at(n),
          a = e.at(n);
        if (!r || !a) return !1;
        if (r?.contextType !== o.ContextType.Skipped || !h(a, i)) return !1;
        return e
          .filter(
            (e) =>
              e.stage === a.stage &&
              e.turn === a.turn &&
              e.responseIndex < a.responseIndex
          )
          .map((e) => [e, t.at(e.responseIndex)])
          .some(
            ([e, n]) =>
              !(!e || !n) &&
              n.contextType === o.ContextType.Skipped &&
              h(e, i) &&
              f(e, t, e.responseIndex)
          );
      };
      const h = (e, t) =>
        !!i.default.isNil(t) ||
        !![s.ReviewLevel.CorpFlagged, s.ReviewLevel.Deliverable].includes(t) ||
        !(
          e.params.visibility_restricted &&
          !e.params.visibility_restricted.includes(t)
        );
      t.isStepVisible = h;
      const f = (e, t, n, i) => {
        const r = e.params.conditional_visibility;
        if (!r) return !0;
        const o = t.slice(0, n);
        return c.conditionalVisibilityCheckerStrategy(r, o, e.turn + 1, i);
      };
      function g(e) {
        const t = e.context?.referenceTexts;
        if (t && t.length > 0) {
          let n = "";
          for (const e in t) {
            n += `Reference text: "${t[e].content}"\n\n`;
          }
          return n + `Prompt: ${e.output}`;
        }
        return e.output;
      }
      function y(e, t, n) {
        const i = e
            .filter((e) => n[e.index]?.turn === t)
            .filter(
              (e) =>
                e.type === o.InteractionStepType.ModelResponseSelector &&
                e.contextType !== o.ContextType.Skipped
            )
            .at(-1),
          r = i?.context?.selectedId,
          a = i?.context?.candidates?.find((e) => e.id === r);
        return a
          ? a.message.content ?? ""
          : i?.context?.candidates?.[0]?.message.content ?? "";
      }
      t.isConditionallyVisible = f;
      t.constructChatHistory = ({
        responses: e,
        config: t,
        stepParamsWithStage: n,
        responseIndex: r,
      }) => {
        e = i.default.isNil(r) ? e : e.slice(0, r);
        const { prevMessages: s } = l.extractPrefilledMessages(
            t.initialMessages
          ),
          c = s.map((e) => ({ role: e.role, content: e.content || "" })),
          u = e
            .slice(0, t.before.length)
            .find((e) => e.type === o.InteractionStepType.PromptInput);
        if (!u) return [];
        const d = {
            role: o.MessageRole.User,
            content: g(u),
            attachments: u.context?.attachments,
          },
          m = [];
        n.slice(0, r)
          .filter(
            (e) =>
              e.stage === p.ChatTaskParamsStages.Turn &&
              e.type === o.InteractionStepType.MultiTurnContinue
          )
          ?.forEach((t) => {
            const i = e.at(t.responseIndex);
            if (!i) return;
            const r = i.context,
              a = r.message.length ? r.message : y(e, t.turn, n),
              s = {
                role: o.MessageRole.Assistant,
                content: a,
                attachments: r.modelResponseAttachments,
                messageMetadata: r.modelResponseMetadata,
              };
            if (!r.shouldContinue) return void m.push(s);
            const l = {
              role: r.role || o.MessageRole.User,
              content: g(i),
              attachments: r.attachments,
              skipMessage: r.skipPromptInput || !1,
            };
            return m.push(s, l);
          });
        let h = [];
        for (const i of n) {
          if (
            i.type !== o.InteractionStepType.TextCollection ||
            !i.params.save_as_system_message
          )
            continue;
          const t = i.params.fields.filter(
            (e) => e.type === a.TextCollectionFieldType.Text
          );
          if (1 !== t.length) break;
          const n = t[0].field_id,
            r =
              e[i.responseIndex].context.response.annotations[n]?.response?.[0];
          r && h.push({ role: o.MessageRole.System, content: r });
        }
        h.length > 1 && (h = []);
        return [...h, ...c, d, ...m];
      };
      t.getTurnCount = (e) =>
        (e ?? []).filter(
          (e) => e?.type === o.InteractionStepType.MultiTurnContinue
        ).length;
      t.ChatHistory = class {
        createNewTurnStepParams(e, t) {
          return [
            ...this.params.turn,
            {
              id: r.default.v4(),
              type: o.InteractionStepType.MultiTurnContinue,
              params: {
                instructions: "Continue with the prompt or end your session.",
              },
            },
          ].map((n, i) => ({
            ...n,
            stage: p.ChatTaskParamsStages.Turn,
            turn: e,
            responseIndex: t + i,
          }));
        }
        getNullContext(e) {
          return m(e.type);
        }
        getStepsWithResponses() {
          let e = [...this.response.responses];
          const t = this.params.before.map((e, t) => ({
              ...e,
              stage: p.ChatTaskParamsStages.Before,
              turn: -1,
              responseIndex: t,
            })),
            n = e.slice(0, t.length);
          if (!l.validateStepTypes(t.map((e) => e.type).slice(0, n.length), n))
            throw new Error("[ChatHistory] Invalid before step responses");
          e = e.slice(t.length);
          const r = this.params.turn.length + 1,
            a = [];
          let s = [];
          const c = [];
          let u = 0;
          for (; e.length > 0; ) {
            const n = this.createNewTurnStepParams(u, t.length + a.length * r),
              i = e.slice(0, n.length);
            if (
              !l.validateStepTypes(n.map((e) => e.type).slice(0, i.length), i)
            )
              throw new Error("[ChatHistory] Invalid turn step responses");
            if (
              (a.push({ stepParams: n, responses: i }),
              (e = e.slice(n.length)),
              i.length !== r)
            )
              break;
            u += 1;
            const d = i[i.length - 1];
            if (d.type !== o.InteractionStepType.MultiTurnContinue)
              throw new Error("[ChatHistory] Invalid last step in a turn");
            if (!d.context.shouldContinue) {
              const n = t.length + a.length * r;
              (s = this.params.after.map((e, t) => ({
                ...e,
                stage: p.ChatTaskParamsStages.After,
                turn: -1,
                responseIndex: n + t,
              }))),
                c.push(...e);
              if (
                !l.validateStepTypes(s.map((e) => e.type).slice(0, c.length), c)
              )
                throw new Error("[ChatHistory] Invalid after step responses");
              break;
            }
          }
          return {
            before: i.default.zip(t, n),
            turns: a,
            after: i.default.zip(s, c),
          };
        }
        getFlattenedStepsWithResponses() {
          const {
            before: e,
            turns: t,
            after: n,
          } = this.getStepsWithResponses();
          return [
            ...e,
            ...t.flatMap((e) => i.default.zip(e.stepParams, e.responses)),
            ...n,
          ];
        }
        getCompletedSteps(e) {
          const t = this.getFlattenedStepsWithResponses(),
            n = {};
          for (let i = 0; i < t.length; i++) {
            const [r, a] = t[i];
            if (!r || !a) break;
            a.contextType === o.ContextType.Skipped &&
            h(r, e) &&
            f(r, this.response.responses, i)
              ? (n[i] = !1)
              : (n[i] = !0);
          }
          return n;
        }
        constructor(e, t) {
          (this.params = e),
            (this.response = t),
            (this.findTurnParamsByStepType = (e) =>
              this.params.turn.filter((t) => t.type === e)),
            (this.findTurnTextCollectionUnitFieldByFieldId = (e) => {
              const t = this.findTurnParamsByStepType(
                o.InteractionStepType.TextCollection
              )?.find((t) => t.params.fields.find((t) => t.field_id === e));
              return t?.params.fields.find((t) => t.field_id === e);
            }),
            (this.findTurnTextCollectionUnitFieldResponseByFieldId = (e) => {
              const t = this.findResponsesByStepType(
                o.InteractionStepType.TextCollection
              )?.find((t) => t.context.response.annotations[e]?.response);
              return t?.context.response.annotations[e];
            }),
            (this.findResponsesByStepType = (e) =>
              this.response.responses.filter((t) => t.type === e)),
            (this.findModelResponseSelectorResponseSelectedCandidateByIndex = (
              e
            ) =>
              this.response.responses[e].context?.candidates?.find(
                (t) =>
                  t.index === this.response.responses[e].context?.selectedIndex
              )),
            (this.params = e),
            (this.response = t);
        }
      };
    },
    108305: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.maybeSanitizeResponseV2Impl = function (e, t) {
          const n = [
              ...t.before.map((t) => p(t, e, "before")),
              ...h(t, e),
              ...t.after.map((t) => p(t, e, "after")),
            ],
            i = b(T(n.map((e) => e.matching_response)));
          return { newResponse: { ...e, responses: i }, matchResults: n };
        }),
        (t.getMatchedOrSkippedStepResponse = p),
        (t.maybeSanitizeWithinStepResponse = u),
        (t.getMatchedOrSkippedTurnStepResponses = m),
        (t.getSkippedStepResponse = y),
        (t.fixMTCContext = b),
        (t.propagateOutputAndIndexes = T),
        (t.populateTemplateVariables = function (e, t) {
          if (t) {
            e.templateVariables = t;
            return _(e, t);
          }
          return e;
        }),
        (t.OUTPUT_PLACEHOLDER = void 0);
      var i,
        r = (i = n(298784)) && i.__esModule ? i : { default: i },
        o = n(854358),
        a = n(147460),
        s = n(900218);
      class l extends Error {
        constructor(e) {
          super(e), (this.name = "SanitizationError");
        }
      }
      t.SanitizationError = l;
      const c = "[[__OUTPUT_PLACEHOLDER__]]";
      function p(e, t, n) {
        const i = {
            step_id: e.id,
            step_type: e.type,
            turn_number: n,
            matching_response: y(e),
          },
          r = t.responses.filter(
            (e) => e.step_id === i.step_id && e.type === i.step_type
          );
        if (0 === r.length) i.empty_reason = a.EmptyStepReason.NewStep;
        else {
          if (r.length > 1)
            throw new l(a.UnsupportedTaskReason.DuplicateStepId);
          i.matching_response = u(e, r[0]);
        }
        return i;
      }
      function u(e, t) {
        if (e.type === o.InteractionStepType.TextCollectionPerResponse) {
          const n = e.params.fields.map((e) => e.field_id),
            i = Object.keys(t.context.annotations);
          for (const e of i)
            t.context.annotations[e].annotations = d(
              t.context.annotations[e].annotations,
              n
            );
        } else if (
          [
            o.InteractionStepType.TextCollection,
            o.InteractionStepType.QIRTextCollection,
          ].includes(e.type)
        ) {
          const n = e.params.fields.map((e) => e.field_id);
          t.context.response.annotations = d(t.context.response.annotations, n);
        }
        return t;
      }
      function d(e, t) {
        return Object.fromEntries(
          Object.entries(e).filter(([e]) => t.includes(e))
        );
      }
      function m(e, t, n, i, r) {
        const s = (function (e, t, n) {
            const i = e.responses.filter(
              (e) => e.type === o.InteractionStepType.MultiTurnContinue
            ).length;
            if (t && t > i) return t;
            if (n && n < i) return n;
            return i;
          })(t, i, r),
          c = [],
          p = t.responses.filter(
            (t) => t.step_id === e.id && t.type === e.type
          );
        for (let o = 0; o < s; o++) {
          const t = {
            step_id: e.id,
            step_type: e.type,
            turn_number: o + 1,
            matching_response: y(e),
          };
          if (n) throw new l(a.UnsupportedTaskReason.DuplicateStepId);
          p.length
            ? p.length <= o
              ? (t.empty_reason = a.EmptyStepReason.NewRequiredTurns)
              : (t.matching_response = u(e, p[o]))
            : (t.empty_reason = a.EmptyStepReason.NewStep),
            c.push(t);
        }
        return c;
      }
      function h(e, t) {
        const n = e.turn,
          i = [...e.before, ...n, ...e.after],
          r = n.map((n) => {
            const r = i.filter((e) => e.id === n.id).length > 1;
            return m(n, t, r, f(e.minTurns), f(e.maxTurns));
          }),
          o = [],
          a = r.length ? r[0].length : 1;
        for (let s = 0; s < a; s++) {
          for (const e of r) o.push(e[s]);
          o.push(g(t, s));
        }
        return o;
      }
      function f(e) {
        const t = r.default.toInteger(e);
        return r.default.isNaN(t) ? void 0 : t;
      }
      function g(e, t) {
        const n = e.responses.filter(
          (e) => e.type === o.InteractionStepType.MultiTurnContinue
        );
        let i = n[t];
        if (!n.length || (i && !i.step_id))
          throw new l(a.UnsupportedTaskReason.NoPrompt);
        if (!i) {
          const e = n[0];
          i = {
            type: o.InteractionStepType.MultiTurnContinue,
            context: { ...e.context, message: "" },
            output: "",
            contextType: o.ContextType.Skipped,
            index: -1,
            step_id: e.step_id,
          };
        }
        if (!i.step_id) throw new l(a.UnsupportedTaskReason.NoPrompt);
        return {
          step_id: i.step_id,
          step_type: o.InteractionStepType.MultiTurnContinue,
          matching_response: i,
        };
      }
      function y(e) {
        return {
          output: c,
          contextType: o.ContextType.Skipped,
          index: -1,
          step_id: e.id,
          type: e.type,
          context: s.getNullContextForStepType(e.type),
        };
      }
      function b(e) {
        const t = e.filter(
          (e) => e.type === o.InteractionStepType.MultiTurnContinue
        );
        if (!t.length) throw new l(a.UnsupportedTaskReason.NoPrompt);
        for (let n = 0; n < t.length; n++) {
          const e = t[n];
          if (n !== t.length - 1) {
            const t = r.default.omit(e.context, ["message", "shouldContinue"]);
            e.context = {
              message: e.context.message,
              shouldContinue: !0,
              ...t,
            };
          } else
            (e.context = { message: e.context.message, shouldContinue: !1 }),
              (e.output = "");
        }
        return e;
      }
      function T(e) {
        const t = [];
        for (let n = 0; n < e.length; n++) {
          const i = e[n],
            r =
              i.output === c && n > 0
                ? t[n - 1].output
                : i.output === c
                ? ""
                : i.output;
          t.push({ ...i, index: n, output: r });
        }
        return t;
      }
      function _(e, t) {
        if (Array.isArray(e)) return e.map((e) => _(e, t));
        if ("object" === typeof e && null !== e) {
          const n = {};
          for (const i in e)
            Object.prototype.hasOwnProperty.call(e, i) && (n[i] = _(e[i], t));
          return n;
        }
        if ("string" === typeof e) {
          let n = e;
          for (const e in t)
            if (Object.prototype.hasOwnProperty.call(t, e)) {
              const i = new RegExp(`{{ *?${e} *?}}`, "gi");
              n = n.replace(i, t[e]);
            }
          return n;
        }
        return e;
      }
      t.OUTPUT_PLACEHOLDER = c;
    },
    959944: function (e, t) {
      "use strict";
      function n(e, t) {
        return e.context.response.annotations[t.field_id];
      }
      function i(e, t) {
        switch (t.type) {
          case "boolean": {
            const i = n(e, t)?.response?.at(0);
            return (
              "undefined" === typeof i || (i && t.value) || (!i && !t.value)
            );
          }
          case "text": {
            const i = n(e, t)?.response?.at(0);
            return (
              "undefined" === typeof i ||
              (function (e, t) {
                switch (t.operator) {
                  case "eq":
                    return e === t.value;
                  case "contains":
                    return e.includes(t.value);
                  case "startsWith":
                    return e.startsWith(t.value);
                  case "endWith":
                    return e.endsWith(t.value);
                  default:
                    return !0;
                }
              })(i, t)
            );
          }
          case "number": {
            const i = n(e, t)?.response?.at(0);
            return (
              "undefined" === typeof i ||
              (function (e, t) {
                switch (t.operator) {
                  case "eq":
                    return Number(e) === t.value;
                  case "lt":
                    return Number(e) < t.value;
                  case "lte":
                    return Number(e) <= t.value;
                  case "gt":
                    return Number(e) > t.value;
                  case "gte":
                    return Number(e) >= t.value;
                  default:
                    return !0;
                }
              })(i, t)
            );
          }
          case "category": {
            const i = n(e, t);
            if ("undefined" === typeof i) return !0;
            const r = i.response;
            return !r.length || r.flat().includes(t.value);
          }
          case "AND":
            return t.params.every((t) => i(e, t));
          case "OR":
            return t.params.some((t) => i(e, t));
          case "NOT":
            return !i(e, t.params);
          default:
            return !0;
        }
      }
      function r(e, t) {
        return t.filter((t) => t.step_id === e.id).at(-1);
      }
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.conditionalVisibilityCheckerStrategy = function e(t, n, o, a) {
          switch (t.type) {
            case "AND":
              return t.params.every((t) => e(t, n, o, a));
            case "OR":
              return t.params.some((t) => e(t, n, o, a));
            case "NOT":
              return !e(t.params, n, o, a);
            case "TextCollection":
              return (s = t), !(l = r(t, n)) || i(l, s.params.fields);
            case "ModelResponseSelector":
              return (function (e, t) {
                return !t || t.context.selectedId === e.params.modelId;
              })(t, r(t, n));
            case "Turn":
              return t.params.turns.includes(o);
            case "TemplateVariable":
              return !!a && t.params.values.includes(a[t.params.variable]);
            default:
              return !0;
          }
          var s, l;
        });
    },
    677686: function (e, t) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
      class n extends Error {
        constructor(e) {
          super(e), Object.setPrototypeOf(this, n.prototype);
        }
      }
      t.ChatTransformWarning = n;
    },
    936944: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.transformResponse = function (e, t, n) {
          const i = [
              ...t.before.filter((e) => e.params.hide_from_customer_view),
              ...t.turn.filter((e) => e.params.hide_from_customer_view),
              ...t.after.filter((e) => e.params.hide_from_customer_view),
            ].map((e) => e.id),
            r = n
              ? (function (e, t) {
                  const n = new u.ChatHistory(
                      t,
                      e
                    ).getFlattenedStepsWithResponses(),
                    i = [...e.responses];
                  for (let a = 0; a < i.length; a++) {
                    const r = i[a],
                      o = n[a][0];
                    o &&
                      r.type !== s.InteractionStepType.MultiTurnContinue &&
                      !c.isConditionallyVisible(
                        o,
                        e.responses,
                        a,
                        t.templateVariables
                      ) &&
                      i.splice(a, 1, p.getSkippedStepResponse(o));
                  }
                  const r = p.propagateOutputAndIndexes(i),
                    o = p.fixMTCContext(r);
                  return { ...e, responses: o };
                })(e, t)
              : e,
            a = l.formatRawStepResponse({
              taskParams: t,
              stepResponses: r.responses,
            }),
            d = o.default.max(
              a.filter((e) => o.default.isNumber(e.turnId)).map((e) => e.turnId)
            );
          if (!o.default.isNumber(d))
            throw new Error("Failed to get maxTurnIndex");
          const f = d + 1;
          if (!o.default.isNumber(f)) throw new Error("Failed to get numTurns");
          return {
            turns: a.map((e) => ({
              turnId: e.turnId,
              responses: e.stepResponsesWithParams
                .map((e) =>
                  (0, m[e.stepResponse.type])({
                    response: e.stepResponse,
                    params: e.stepParams,
                    turnId: e.turnId,
                  })
                )
                .filter((e) => !!e)
                .filter((e) => !i.includes(e.params.id)),
            })),
            messages: h(a, t),
            numTurns: f,
          };
        }),
        (t.ChatTaskTransformedStepResponseType = void 0);
      var i,
        r,
        o = (i = n(298784)) && i.__esModule ? i : { default: i },
        a = n(907777),
        s = n(854358),
        l = n(142486),
        c = n(900218),
        p = n(108305),
        u = n(900218);
      (t.ChatTaskTransformedStepResponseType = r),
        (function (e) {
          (e.Prompt = "prompt"),
            (e.BasicInput = "basic_input"),
            (e.PromptTextCollection = "prompt_text_collection"),
            (e.ModelResponseSelector = "model_response_selector"),
            (e.QuantitativeModelResponseSelector =
              "quantitative_model_response_selector"),
            (e.ResponseTextCollection = "response_text_collection"),
            (e.ModelResponseEditor = "model_response_editor"),
            (e.MetadataEditor = "metadata_editor"),
            (e.ModelResponseRanking = "model_response_ranking"),
            (e.GenericAnnotation = "generic_annotation"),
            (e.GenericAnnotationPerModelResponse =
              "generic_annotation_per_model_response"),
            (e.NamedEntityRecognition = "named_entity_recognition"),
            (e.SearchAutoComplete = "search_auto_complete"),
            (e.SearchReferences = "search_references"),
            (e.ProcessSupervision = "process_supervision"),
            (e.ExperimentalToolUse = "experimental_tool_use"),
            (e.ToolUseProcessSupervision = "tool_use_process_supervision"),
            (e.ModelResponseSelectorJustificationVariable =
              "model_response_selector_justification_variable"),
            (e.SpanFeedback = "span_feedback");
        })(r || (t.ChatTaskTransformedStepResponseType = r = {}));
      const d = {
          [s.InteractionStepType.PromptInput]: r.Prompt,
          [s.InteractionStepType.BasicInput]: r.BasicInput,
          [s.InteractionStepType.PromptTextCollection]: r.PromptTextCollection,
          [s.InteractionStepType.MultiTurnContinue]: r.Prompt,
          [s.InteractionStepType.ModelResponseSelector]:
            r.ModelResponseSelector,
          [s.InteractionStepType.QuantitativeModelResponseSelector]:
            r.QuantitativeModelResponseSelector,
          [s.InteractionStepType.ResponseTextCollection]:
            r.ResponseTextCollection,
          [s.InteractionStepType.ModelResponseEditor]: r.ModelResponseEditor,
          [s.InteractionStepType.MetadataEditor]: r.MetadataEditor,
          [s.InteractionStepType.ModelResponseRanking]: r.ModelResponseRanking,
          [s.InteractionStepType.TextCollection]: r.GenericAnnotation,
          [s.InteractionStepType.TextCollectionPerResponse]:
            r.GenericAnnotationPerModelResponse,
          [s.InteractionStepType.NER]: r.NamedEntityRecognition,
          [s.InteractionStepType.SearchAutoComplete]: r.SearchAutoComplete,
          [s.InteractionStepType.SearchReferences]: r.SearchReferences,
          [s.InteractionStepType.Instruction]: void 0,
          [s.InteractionStepType.MetadataViewer]: void 0,
          [s.InteractionStepType.ContextDirections]: void 0,
          [s.InteractionStepType.QIRTextCollection]: void 0,
          [s.InteractionStepType.QualityMeasurement]: void 0,
          [s.InteractionStepType.ProcessSupervision]: r.ProcessSupervision,
          [s.InteractionStepType.ExperimentalToolUse]: r.ExperimentalToolUse,
          [s.InteractionStepType.ToolUseProcessSupervision]:
            r.ToolUseProcessSupervision,
          [s.InteractionStepType.SpanFeedback]: r.SpanFeedback,
          [s.InteractionStepType.ChainOfThought]: void 0,
          [s.InteractionStepType.ModelResponseInput]: void 0,
        },
        m = {
          [s.InteractionStepType.PromptInput]: ({
            response: e,
            turnId: t,
            params: n,
          }) => {
            const i = e.context?.referenceTexts,
              r = e.context?.attachments;
            return {
              __internalType: e.type,
              params: n,
              type: d[e.type],
              turnId: t,
              data: {
                prompt: e.output,
                ...(i?.length && { referenceTexts: i }),
                ...(r?.length && { attachments: r }),
              },
              responsesIndex: e.index,
              stepId: n.id,
            };
          },
          [s.InteractionStepType.BasicInput]: ({
            response: e,
            turnId: t,
            params: n,
          }) => ({
            __internalType: e.type,
            params: n,
            type: d[e.type],
            turnId: t,
            data: { input: e.output },
            responsesIndex: e.index,
            stepId: n.id,
          }),
          [s.InteractionStepType.PromptTextCollection]: ({
            response: e,
            turnId: t,
            params: n,
          }) => ({
            __internalType: e.type,
            params: n,
            type: d[e.type],
            turnId: t,
            responsesIndex: e.index,
            stepId: n.id,
            data: { annotations: e.context.response.annotations },
          }),
          [s.InteractionStepType.ModelResponseSelector]: ({
            response: e,
            turnId: t,
            params: n,
          }) => ({
            __internalType: e.type,
            params: n,
            type: d[e.type],
            turnId: t,
            responsesIndex: e.index,
            stepId: n.id,
            data: {
              modelResponses: o.default.fromPairs(
                e.context.candidates.map((e) => [e.id, e.message.content])
              ),
              selectedModelId: e.context.selectedId,
              ...o.default.omitBy(
                {
                  isObjective: e.context.isObjective,
                  likertValue: e.context.likertValueUnrandomized,
                  justification: e.context.justificationUnrandomized,
                },
                o.default.isNil
              ),
            },
          }),
          [s.InteractionStepType.QuantitativeModelResponseSelector]: ({
            response: e,
            turnId: t,
            params: n,
          }) => ({
            __internalType: e.type,
            params: n,
            type: d[e.type],
            turnId: t,
            responsesIndex: e.index,
            stepId: n.id,
            data: {
              modelResponses: o.default.fromPairs(
                e.context.candidates.map((e) => [e.id, e.message.content])
              ),
              selectedModelId: e.context.selectedId,
              response: e.context.response,
            },
          }),
          [s.InteractionStepType.ResponseTextCollection]: ({
            response: e,
            turnId: t,
            params: n,
          }) => ({
            __internalType: e.type,
            params: n,
            type: d[e.type],
            turnId: t,
            responsesIndex: e.index,
            stepId: n.id,
            data: {
              responseId: e.context.responseId,
              annotations: e.context.response,
            },
          }),
          [s.InteractionStepType.ModelResponseEditor]: ({
            response: e,
            turnId: t,
            params: n,
          }) => ({
            __internalType: e.type,
            params: n,
            type: d[e.type],
            turnId: t,
            responsesIndex: e.index,
            stepId: n.id,
            data: {
              originalResponse: e.context.originalText ?? "",
              modelResponse: e.output.replaceAll("&#x20;", " "),
            },
          }),
          [s.InteractionStepType.MetadataEditor]: ({
            response: e,
            turnId: t,
            params: n,
          }) => ({
            __internalType: e.type,
            params: n,
            type: d[e.type],
            turnId: t,
            responsesIndex: e.index,
            stepId: n.id,
            data: {
              originalContent: e.context.baseMetadata ?? "",
              content: e.output.replaceAll("&#x20;", " "),
            },
          }),
          [s.InteractionStepType.ModelResponseRanking]: ({
            response: e,
            turnId: t,
            params: n,
          }) => ({
            __internalType: e.type,
            params: n,
            type: d[e.type],
            turnId: t,
            responsesIndex: e.index,
            stepId: n.id,
            data: {
              rankedCandidateIds: e.context.rankedCandidates.map((e) =>
                e.map((e) => e.id)
              ),
            },
          }),
          [s.InteractionStepType.TextCollection]: ({
            response: e,
            turnId: t,
            params: n,
          }) => ({
            __internalType: e.type,
            params: n,
            type: d[e.type],
            turnId: t,
            responsesIndex: e.index,
            stepId: n.id,
            data: { annotations: e.context.response.annotations },
          }),
          [s.InteractionStepType.TextCollectionPerResponse]: ({
            response: e,
            turnId: t,
            params: n,
          }) => ({
            __internalType: e.type,
            params: n,
            type: d[e.type],
            turnId: t,
            responsesIndex: e.index,
            stepId: n.id,
            data: o.default.fromPairs(
              Object.entries(e.context.annotations).map(
                ([e, { annotations: t }]) => [e, { annotations: t }]
              )
            ),
          }),
          [s.InteractionStepType.NER]: ({
            response: e,
            turnId: t,
            params: n,
          }) => ({
            __internalType: e.type,
            params: n,
            type: d[e.type],
            turnId: t,
            responsesIndex: e.index,
            stepId: n.id,
            data: { annotations: e.context.response },
          }),
          [s.InteractionStepType.MultiTurnContinue]: ({
            response: e,
            turnId: t,
            params: n,
          }) => {
            if (!e.context.shouldContinue) return;
            const i = e.context?.referenceTexts,
              r = e.context?.attachments;
            return {
              __internalType: e.type,
              params: n,
              type: d[e.type],
              turnId: t,
              data: {
                prompt: e.output,
                ...(i?.length && { referenceTexts: i }),
                ...(r?.length && { attachments: r }),
              },
              responsesIndex: e.index,
              stepId: n.id,
            };
          },
          [s.InteractionStepType.SearchAutoComplete]: ({
            response: e,
            turnId: t,
            params: n,
          }) => ({
            __internalType: e.type,
            params: n,
            type: d[e.type],
            turnId: t,
            responsesIndex: e.index,
            stepId: n.id,
            data: {
              finalResponse: e.output,
              modelResponses: o.default.fromPairs(
                e.context.candidates.map((e) => [
                  e.sourceId ?? e.index.toString(),
                  e.message.content,
                ])
              ),
              searchHistory: e.context.searchHistory,
              additionalReferences: e.context.additionalReferences,
            },
          }),
          [s.InteractionStepType.SearchReferences]: ({
            response: e,
            turnId: t,
            params: n,
          }) => ({
            __internalType: e.type,
            params: n,
            type: d[e.type],
            turnId: t,
            responsesIndex: e.index,
            stepId: n.id,
            data: { finalResponse: e.output, references: e.context.references },
          }),
          [s.InteractionStepType.Instruction]: () => {},
          [s.InteractionStepType.MetadataViewer]: () => {},
          [s.InteractionStepType.ContextDirections]: () => {},
          [s.InteractionStepType.QIRTextCollection]: () => {},
          [s.InteractionStepType.QualityMeasurement]: () => {},
          [s.InteractionStepType.ProcessSupervision]: ({
            response: e,
            turnId: t,
            params: n,
          }) => ({
            __internalType: s.InteractionStepType.ProcessSupervision,
            params: n,
            type: d[s.InteractionStepType.ProcessSupervision],
            turnId: t,
            responsesIndex: e.index,
            stepId: n.id,
            data: { ...e },
          }),
          [s.InteractionStepType.ExperimentalToolUse]: ({
            response: e,
            turnId: t,
            params: n,
          }) => ({
            __internalType: e.type,
            params: n,
            type: d[s.InteractionStepType.ExperimentalToolUse],
            turnId: t,
            responsesIndex: e.index,
            stepId: n.id,
            data: { ...e },
          }),
          [s.InteractionStepType.ToolUseProcessSupervision]: ({
            response: e,
            turnId: t,
            params: n,
          }) => ({
            __internalType: s.InteractionStepType.ToolUseProcessSupervision,
            params: n,
            type: d[s.InteractionStepType.ToolUseProcessSupervision],
            turnId: t,
            responsesIndex: e.index,
            stepId: n.id,
            data: { ...e },
          }),
          [s.InteractionStepType.SpanFeedback]: ({
            response: e,
            turnId: t,
            params: n,
          }) => ({
            __internalType: s.InteractionStepType.SpanFeedback,
            params: n,
            type: d[s.InteractionStepType.SpanFeedback],
            turnId: t,
            responsesIndex: e.index,
            stepId: n.id,
            data: { ...e },
          }),
          [s.InteractionStepType.ChainOfThought]: () => {},
          [s.InteractionStepType.ModelResponseInput]: () => {},
        };
      function h(e, t) {
        const { prevMessages: n } = a.extractPrefilledMessages(
            t.initialMessages
          ),
          i = [...n.map((e) => ({ role: e.role, content: e.content || "" }))],
          r = e.filter((e) => "before" !== e.turnId && "after" !== e.turnId);
        for (const o of r) {
          const e = o.stepResponsesWithParams;
          if (!e || 0 === e.length)
            throw new Error("Invalid turnStepResponsesWithParams");
          const t = e.find(
            (e) =>
              e.stepResponse.type === s.InteractionStepType.PromptInput ||
              e.stepResponse.type === s.InteractionStepType.MultiTurnContinue
          );
          if (!t) continue;
          const n = t.stepResponse.output,
            r = e[e.length - 1].stepResponse.output;
          if ("string" !== typeof n) throw new Error("Prompt is not a string");
          const a = e.find(
            (e) =>
              e.stepResponse.type === s.InteractionStepType.PromptInput ||
              e.stepResponse.type === s.InteractionStepType.MultiTurnContinue
          )?.stepResponse?.context?.attachments;
          i.push(
            {
              role: s.MessageRole.User,
              content: n,
              ...(a?.length && { attachments: a }),
            },
            { role: s.MessageRole.Assistant, content: r }
          );
        }
        return i;
      }
    },
    258269: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.generateEmptyChatResponse = function (e) {
          const t = [];
          let n = 0;
          e.before.forEach((e) => {
            const i = {
              type: e.type,
              context: r.getNullContextForStepType(e.type),
              output: "",
              index: n,
              step_id: e.id,
            };
            t.push(i), n++;
          });
          const o = Number(e.minTurns ?? 1);
          for (let a = 0; a < o; a++) {
            e.turn.forEach((e) => {
              const i = {
                type: e.type,
                context: r.getNullContextForStepType(e.type),
                output: "",
                index: n,
                step_id: e.id,
              };
              t.push(i), n++;
            });
            const s = e.before.find(
                (e) => e.type === i.InteractionStepType.PromptInput
              ),
              l = {
                type: i.InteractionStepType.MultiTurnContinue,
                context: {
                  ...r.getNullContextForStepType(
                    i.InteractionStepType.MultiTurnContinue
                  ),
                  shouldContinue: a !== o - 1,
                },
                output: "",
                index: n,
                step_id: s ? s.id : "prompt",
              };
            t.push(l), n++;
          }
          return (
            e.after.forEach((e) => {
              const i = {
                type: e.type,
                context: r.getNullContextForStepType(e.type),
                output: "",
                index: n,
                step_id: e.id,
              };
              t.push(i), n++;
            }),
            t
          );
        });
      var i = n(854358),
        r = n(900218);
    },
    560411: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.getCommentIsOverallFeedback = function (e) {
          return i.isNil(e.childId);
        }),
        (t.createChatTaskFeedbackEntriesFromResponse = function (e, t, n, o) {
          if (!n || i.isNil(o) || i.isNil(t)) return [];
          const a = new r.ChatHistory(e, {
              responses: t.responses,
            }).getFlattenedStepsWithResponses(),
            c = [];
          let d = -1;
          for (const [r, h] of a) {
            if (!r || !h) continue;
            const t = r.type;
            if (
              t === s.InteractionStepType.TextCollection ||
              t === s.InteractionStepType.QualityMeasurement
            ) {
              const e = Object.values(h.context.response.annotations),
                t = r.params.fields.filter(
                  (e) =>
                    (e.type === l.TextCollectionFieldType.Text ||
                      e.type === l.TextCollectionFieldType.Number ||
                      e.type === l.TextCollectionFieldType.Category) &&
                    e.save_to_task_feedback
                );
              e.forEach((e) => {
                const { field_id: f, type: g, response: y } = e,
                  b = t.find((e) => e.field_id === f);
                if (r.params.visibility_restricted && b) {
                  const e = r.params.visibility_restricted.sort((e, t) =>
                    i.isNumber(e) && i.isNumber(t) ? e - t : 0
                  );
                  let t, T;
                  if (g === l.TextCollectionFieldType.Category) {
                    const e = b.choices,
                      n = y[0].map((t) => {
                        const n = e.find((e) => e.value === t);
                        return n ? n.label : String(t);
                      });
                    n.length && ((t = n), (T = s.WorkerCommentType.Category));
                  } else
                    g === l.TextCollectionFieldType.Number
                      ? ((t = y[0]), (T = s.WorkerCommentType.Rating))
                      : g === l.TextCollectionFieldType.Text &&
                        ((t = y[0]), (T = s.WorkerCommentType.Text));
                  const _ =
                    h.type === s.InteractionStepType.QualityMeasurement
                      ? e.includes(o)
                      : o === e[0];
                  let S,
                    v = b.title;
                  if (h.type === s.InteractionStepType.QualityMeasurement) {
                    if (!p.includes(f)) {
                      const e = a.slice(0, h.index);
                      S = m(f, e, o);
                    }
                    u.includes(f) && (v = b.description ?? v);
                  }
                  if (!i.isNil(t) && _) {
                    const e = {
                      title: v,
                      response: t,
                      reviewerId: n,
                      source:
                        h.type === s.InteractionStepType.QualityMeasurement
                          ? s.WorkerCommentSourceType.QualityMeasurement
                          : s.WorkerCommentSourceType.TextCollection,
                      type: T,
                      childId: S,
                      turn: d >= 0 ? d : void 0,
                      fieldId: f,
                    };
                    c.push(e);
                  }
                }
              });
            }
            t === s.InteractionStepType.MultiTurnContinue &&
              (h.context.shouldContinue ? d++ : (d = -1)),
              h.index === e.before.length - 1 && (d = 0);
          }
          return c;
        }),
        (t.createChatLiteTaskFeedbackEntriesFromResponse = function (
          e,
          t,
          n,
          r
        ) {
          if (!n || i.isNil(r) || i.isNil(t)) return [];
          const o = [],
            c = e.after.find(
              (e) =>
                e.id === a.TaxonomyConstant.Eval.StandardStepId.ReviewerFeedback
            ),
            p =
              t?.after?.[
                a.TaxonomyConstant.Eval.StandardStepId.ReviewerFeedback
              ];
          if (
            !c ||
            !p ||
            !p.output ||
            c.type !== s.InteractionStepType.TextCollection
          )
            return [];
          const u = p.output;
          for (const [a, d] of Object.entries(u)) {
            const e = c.params.fields.find((e) => e.field_id === a);
            if (!e) continue;
            let t, r;
            if (e.type === l.TextCollectionFieldType.Category)
              (t = [d.toString()]), (r = s.WorkerCommentType.Category);
            else if (e.type === l.TextCollectionFieldType.Number)
              (t = d.toString()), (r = s.WorkerCommentType.Rating);
            else if (e.type === l.TextCollectionFieldType.Text)
              (t = d.toString()), (r = s.WorkerCommentType.Text);
            else {
              if (e.type !== l.TextCollectionFieldType.Boolean) continue;
              (t = d.toString()), (r = s.WorkerCommentType.Boolean);
            }
            if (!i.isNil(t)) {
              const i = {
                title: e.title,
                response: t,
                reviewerId: n,
                source: s.WorkerCommentSourceType.QualityMeasurement,
                type: r,
                fieldId: a,
              };
              o.push(i);
            }
          }
          return o;
        }),
        (t.getAuthorTagDataForFeedback = t.SENIOR_LABEL_REVIEW_LEVELS = void 0);
      var i = n(298784),
        r = n(900218),
        o = n(599789),
        a = n(783768),
        s = n(854358),
        l = n(963494);
      const c = [o.ReviewLevel.Corp, o.ReviewLevel.Deliverable];
      t.SENIOR_LABEL_REVIEW_LEVELS = c;
      const p = [
          s.QUALITY_TASK_OVERALL_FIELD_ID,
          s.QUALITY_INSTRUCTION_FOLLOWING_FIELD_ID,
          s.QUALITY_FEEDBACK_OVERALL_FIELD_ID,
        ],
        u = [
          s.QUALITY_RESPONSE_SELECTION_FIELD_ID,
          s.QUALITY_INSTRUCTION_FOLLOWING_FIELD_ID,
        ];
      function d(e, t, n) {
        return e.filter(([e, i]) => e && t(e) && r.isStepVisible(e, n)).at(-1);
      }
      function m(e, t, n) {
        if (e === s.QUALITY_PROMPT_FIELD_ID) {
          const e = d(
            t,
            (e) =>
              [
                s.InteractionStepType.PromptInput,
                s.InteractionStepType.MultiTurnContinue,
              ].includes(e.type),
            n
          );
          if (e && e[1]) return `${e[1].type}-${e[1].index}`;
        } else if (e === s.QUALITY_RESPONSE_SELECTION_FIELD_ID) {
          const e = d(
            t,
            (e) => e.type === s.InteractionStepType.ModelResponseSelector,
            n
          );
          if (e && e[1]) return `${e[1].type}-${e[1].index}`;
        } else if (e === s.QUALITY_RESPONSE_FIELD_ID) {
          const e = d(
            t,
            (e) => e.type === s.InteractionStepType.ModelResponseEditor,
            n
          );
          if (e && e[1]) return `${e[1].type}-${e[1].index}`;
        } else if (e === s.QUALITY_JUSTIFICATION_FIELD_ID) {
          const e = d(
            t,
            (e) =>
              e.type === s.InteractionStepType.TextCollection &&
              e.params.fields.some((e) => e.field_id.includes("justification")),
            n
          );
          if (e && e[1]) return `${e[1].type}-${e[1].index}`;
        }
      }
      t.getAuthorTagDataForFeedback = (e, t) => {
        const n = e?.slice(-6);
        return {
          authorLabel: n ? `Reviewer (${n})` : void 0,
          isSeniorReview: !i.isNil(t) && c.includes(t),
        };
      };
    },
    907777: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
      var i = {},
        r = u(n(112690));
      Object.keys(r).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === r[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return r[e];
              },
            }));
      });
      var o = u(n(546112));
      Object.keys(o).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === o[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return o[e];
              },
            }));
      });
      var a = u(n(142486));
      Object.keys(a).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === a[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return a[e];
              },
            }));
      });
      var s = u(n(936944));
      Object.keys(s).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === s[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return s[e];
              },
            }));
      });
      var l = u(n(677686));
      Object.keys(l).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === l[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return l[e];
              },
            }));
      });
      var c = u(n(560411));
      Object.keys(c).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === c[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return c[e];
              },
            }));
      });
      var p = u(n(258269));
      function u(e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e)
          for (var n in e)
            if (Object.prototype.hasOwnProperty.call(e, n)) {
              var i =
                Object.defineProperty && Object.getOwnPropertyDescriptor
                  ? Object.getOwnPropertyDescriptor(e, n)
                  : {};
              i.get || i.set ? Object.defineProperty(t, n, i) : (t[n] = e[n]);
            }
        return (t.default = e), t;
      }
      Object.keys(p).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === p[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return p[e];
              },
            }));
      });
    },
    142486: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.formatRawStepResponse = function ({
          taskParams: e,
          stepResponses: t,
        }) {
          const n = new s.ChatHistory(e, { responses: t }),
            { before: i, turns: r, after: l } = n.getStepsWithResponses(),
            c = [];
          i.forEach(([e, t]) => {
            c.push({
              stepParams: e,
              stepResponse: t,
              turnId:
                t.type === o.InteractionStepType.PromptInput ? 0 : "before",
            });
          }),
            r.forEach((e, t) => {
              a.default.zip(e.stepParams, e.responses).forEach(([e, n]) => {
                let i = t;
                if (n.type === o.InteractionStepType.MultiTurnContinue) {
                  if (!n.context.shouldContinue) return;
                  i = t + 1;
                }
                c.push({ stepParams: e, stepResponse: n, turnId: i });
              });
            }),
            l.forEach(([e, t]) => {
              c.push({ stepParams: e, stepResponse: t, turnId: "after" });
            });
          const p = [];
          for (const o of c) {
            const { turnId: e } = o,
              t = p.find((t) => t.turnId === e);
            t
              ? t.stepResponsesWithParams.push(o)
              : p.push({ turnId: e, stepResponsesWithParams: [o] });
          }
          return p;
        }),
        (t.legacyFormatRawStepResponse = function ({
          taskParams: e,
          stepResponses: t,
        }) {
          const n = l(t, e),
            i = [];
          for (const r of n) {
            const { turnId: e } = r,
              t = i.find((t) => t.turnId === e);
            t
              ? t.stepResponsesWithParams.push(r)
              : i.push({ turnId: e, stepResponsesWithParams: [r] });
          }
          return i;
        }),
        (t.getStepResponseWithParams = l);
      var i,
        r = n(907777),
        o = n(854358),
        a = (i = n(298784)) && i.__esModule ? i : { default: i },
        s = n(900218);
      function l(e, t) {
        const { before: n, turn: i, after: s } = t,
          l = n.filter((e) => e.type !== o.InteractionStepType.PromptInput),
          c = n.find((e) => e.type === o.InteractionStepType.PromptInput);
        if (!c)
          throw new r.ChatTransformWarning(
            "Prompt input step params not found"
          );
        const p = [c, ...i],
          u = e
            .slice(0, n.length)
            .filter((e) => e.type !== o.InteractionStepType.PromptInput);
        if (u.length !== l.length)
          throw new Error(
            `Invalid before step responses length: params has ${u.length} before steps, response has ${l.length} before steps`
          );
        const d = a.default.find(e, {
          type: o.InteractionStepType.PromptInput,
        });
        if (!d) throw new Error("PromptInput step response not found");
        const m = [d, ...e.slice(n.length, e.length - s.length)];
        if (m.length !== e.length - s.length - l.length)
          throw new Error(
            `Invalid turn step responses length: turnWithPromptStepResponses of ${m.length} should equal total steps (${e.length}) - before step (${l.length}) - after steps (${s.length}`
          );
        const h = e.slice(u.length + m.length);
        if (h.length !== s.length)
          throw new Error(
            `Invalid after step responses length: params has ${s.length} after steps, response has ${h.length} after steps`
          );
        const f = [];
        u.forEach((e, t) => {
          f.push({ stepParams: l[t], stepResponse: e, turnId: "before" });
        });
        const g = (m.length - 1) / p.length;
        if (g % 1 !== 0)
          throw new Error(
            `Invalid totalTurns length: turns in response (${
              m.length - 1
            }) should be divisible by turns in params (${p.length})`
          );
        for (let r = 0; r < g; r++)
          for (let e = 0; e < p.length; e++) {
            const t = m[r * p.length + e];
            if (!t)
              throw new Error(
                `Invalid stepResponse: could not find response at turn [${r}], response [${e}]`
              );
            f.push({ stepParams: p[e], stepResponse: t, turnId: r });
          }
        const y = m[m.length - 1];
        if (
          y.type !== o.InteractionStepType.MultiTurnContinue ||
          y.context.shouldContinue
        )
          throw new Error(
            "Last step response must be MultiTurnContinue with shouldContinue set to false"
          );
        return (
          h.forEach((e, t) => {
            f.push({ stepParams: s[t], stepResponse: e, turnId: "after" });
          }),
          f.forEach(({ stepParams: e, stepResponse: t }, n) => {
            if (
              e.type !== t.type &&
              (e.type !== o.InteractionStepType.PromptInput ||
                t.type !== o.InteractionStepType.MultiTurnContinue)
            )
              throw new Error(
                `Invalid step response type at step index ${n}, param type ${e.type} does not match response type ${t.type}`
              );
          }),
          f
        );
      }
    },
    112690: function (e, t) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
    },
    546112: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.populateAndValidateChatResponse = async function (e, t, n, i) {
          const r = await y(e, t, n, i),
            { valid: o, message: a } = g(e, r.responses, {
              includePerResponseValidation: !0,
            });
          if (!o) throw new Error(a);
          return r;
        }),
        (t.maybeEnsureResponseSelfConsistency = v),
        (t.maybePropagateResponseChanges = L),
        (t.extractPrefilledMessages =
          t.swapTurns =
          t.addTurn =
          t.duplicateTurn =
          t.deleteTurn =
          t.deleteAllTurnsAfterTurnIndex =
          t.reactivateSession =
          t.resetChatHistoryFromSelectedResponse =
          t.ensureStepResponseIndexConsistency =
          t.getMostRecentResponse =
          t.getMostRecentPrompt =
          t.interactionStepTriggersPropagation =
          t.ensureTextCollectionAnnotation =
          t.transformStepParamsToStepParamsWithStages =
          t.getStepParamsFromParams =
          t.getStepParamsForResponses =
          t.getNumTurns =
          t.populateTemplateAndPropagateChanges =
          t.validateChatResponse =
          t.validateStepTypes =
          t.stripTextCollectionResponses =
            void 0);
      var i = n(854358),
        r = n(954282),
        o = m(n(298784)),
        a = n(112738),
        s = n(108896),
        l = m(n(711719)),
        c = n(153115),
        p = n(530869),
        u = n(844159),
        d = n(900218);
      function m(e) {
        return e && e.__esModule ? e : { default: e };
      }
      t.stripTextCollectionResponses = (e) =>
        e.map((e) =>
          e.type === i.InteractionStepType.TextCollection
            ? { ...e, context: { ...e.context, response: { annotations: {} } } }
            : e.type === i.InteractionStepType.TextCollectionPerResponse
            ? { ...e, context: { ...e.context, annotations: {} } }
            : e
        );
      const h = (e, t) => {
          if (t.contextType === i.ContextType.Skipped) return { valid: !0 };
          switch (e.type) {
            case i.InteractionStepType.PromptInput:
            case i.InteractionStepType.ModelResponseSelector:
            case i.InteractionStepType.ProcessSupervision:
            case i.InteractionStepType.ModelResponseEditor:
              break;
            case i.InteractionStepType.QuantitativeModelResponseSelector:
            case i.InteractionStepType.QualityMeasurement:
            case i.InteractionStepType.PromptTextCollection:
            case i.InteractionStepType.TextCollection: {
              const n = s.flattenFields(e.params.fields),
                { valid: i, message: r } = a.validateTextCollectionResponse(
                  t.context.response,
                  n
                );
              if (!i) return { valid: !1, message: r };
              break;
            }
            case i.InteractionStepType.TextCollectionPerResponse: {
              const n = s.flattenFields(e.params.fields);
              for (const e of Object.keys(t.context.annotations)) {
                const { valid: i, message: r } =
                  a.validateTextCollectionResponse(t.context.annotations[e], n);
                if (!i)
                  return {
                    valid: !1,
                    message: `Response ${e} is invalid: ${r}`,
                  };
              }
              break;
            }
            case i.InteractionStepType.NER: {
              const e = t.context.response.annotations;
              for (const t of e) {
                const e = p.annotationSchema.validate(t, {
                  context: { textLength: 1e6 },
                })?.error;
                if (e)
                  return {
                    valid: !1,
                    message: `Invalid NER annotation: ${JSON.stringify(
                      t
                    )}, ${e}`,
                  };
              }
              break;
            }
            case i.InteractionStepType.MultiTurnContinue:
            case i.InteractionStepType.ContextDirections:
              break;
            case i.InteractionStepType.SearchAutoComplete: {
              const e = [
                ...t.context.searchHistory,
                ...t.context.additionalReferences,
              ];
              for (const t of e)
                if (c.searchResponseSchema.validate(t)?.error)
                  return {
                    valid: !1,
                    message: `Invalid search response: ${JSON.stringify(t)}`,
                  };
              break;
            }
          }
          return { valid: !0 };
        },
        f = (e, t) => o.default.every(t, (t, n) => t.type === e[n % e.length]);
      t.validateStepTypes = f;
      const g = (e, t, n) => {
        const { includePerResponseValidation: r } = n || {},
          a = t.length,
          s = o.default.slice(t, 0, e.before.length);
        if (
          !f(
            e.before.map((e) => e.type),
            s
          )
        )
          return { valid: !1, message: "Invalid before steps" };
        if (r)
          for (const [i, o] of s.entries()) {
            const t = e.before[i],
              { valid: n, message: r } = h(t, o);
            if (!n)
              return {
                valid: !1,
                message: `Step ${i + 1} (${t.type}) is invalid: ${r}`,
              };
          }
        const l = e.before.length,
          c = o.default.slice(t, l, a - e.after.length);
        if (
          !(c.length % (e.turn.length + 1) === 0) ||
          (e.turn.length > 0 && 0 === c.length)
        )
          return { valid: !1, message: "Invalid number of turns" };
        if (
          !f(
            [
              ...e.turn.map((e) => e.type),
              i.InteractionStepType.MultiTurnContinue,
            ],
            c
          )
        )
          return { valid: !1, message: "Invalid turn steps" };
        if (r)
          for (const [i, o] of c.entries())
            if (i % (e.turn.length + 1) !== e.turn.length) {
              const t = e.turn[i % (e.turn.length + 1)],
                { valid: n, message: r } = h(t, o);
              if (!n)
                return {
                  valid: !1,
                  message: `Step ${l + i + 1} (${t.type}) is invalid: ${r}`,
                };
            }
        const p = a - e.after.length,
          u = o.default.slice(t, p, a);
        if (
          !f(
            e.after.map((e) => e.type),
            u
          )
        )
          return { valid: !1, message: "Invalid after steps" };
        if (r)
          for (const [i, o] of u.entries()) {
            const t = e.after[i],
              { valid: n, message: r } = h(t, o);
            if (!n)
              return {
                valid: !1,
                message: `Step ${p + i} (${t.type}) is invalid: ${r}`,
              };
          }
        const { valid: d, message: m } = k(t);
        return d ? { valid: !0 } : { valid: d, message: m };
      };
      t.validateChatResponse = g;
      const y = async (e, t, n, i) => {
        const o = await r.populateTemplate(
            { responses: t },
            n,
            {
              parseJson: !0,
              enabledCustomFilters: [r.CustomFilterTypes.minWith],
              includeTemplateVariables: i,
            },
            {}
          ),
          a = T(e, o.responses);
        return (
          o.responses.map((t, n) => {
            v(a[n], o.responses[n]),
              L(e, o.responses, n, { stopAtNextInteractionStepTrigger: !0 }),
              (o.responses[n].index = n);
          }),
          o
        );
      };
      t.populateTemplateAndPropagateChanges = y;
      const b = (e, t) =>
        (t.length - e.before.length - e.after.length) / (e.turn.length + 1);
      t.getNumTurns = b;
      const T = (e, t) => {
        const n = b(e, t);
        if (!o.default.isInteger(n))
          throw new Error(
            `Number of responses (excluding before and after steps) is not a multiple of the expected number of the turns - found ${
              t.length
            } responses and but expected a multiple of ${
              e.turn.length + 1
            }. This likely indicates a taxonomy mismatch.`
          );
        return _(e, n);
      };
      t.getStepParamsForResponses = T;
      const _ = (e, t) => [
        ...e.before,
        ...o.default.flatMap(
          o.default.times(t, () => [
            ...e.turn,
            {
              id: l.default.v4(),
              type: i.InteractionStepType.MultiTurnContinue,
              params: {
                instructions: "Continue with the prompt or end your session.",
              },
            },
          ])
        ),
        ...e.after,
      ];
      t.getStepParamsFromParams = _;
      t.transformStepParamsToStepParamsWithStages = (e, t) =>
        [
          ...(e.before ?? []).map((e) => ({
            ...e,
            stage: u.ChatTaskParamsStages.Before,
            turn: -1,
          })),
          ...o.default.flatMap(
            o.default.times(t, () => [
              ...(e.turn ?? []).map((e) => ({
                ...e,
                stage: u.ChatTaskParamsStages.Turn,
                turn: 0,
              })),
              {
                id: l.default.v4(),
                type: i.InteractionStepType.MultiTurnContinue,
                params: {
                  instructions: "Continue with the prompt or end your session.",
                },
                stage: u.ChatTaskParamsStages.Turn,
                turn: 0,
              },
            ])
          ),
          ...(e.after ?? []).map((e) => ({
            ...e,
            stage: u.ChatTaskParamsStages.After,
            turn: -1,
          })),
        ].map((e, t) => ({ ...e, responseIndex: t }));
      const S = (e, t) => {
        const n = s.flattenFields(e);
        Object.keys(t.annotations).map((e) => {
          t.annotations[e].field_id || (t.annotations[e].field_id = e),
            t.annotations[e].type || (t.annotations[e].type = n[e]?.type);
        });
      };
      function v(e, t) {
        if (i.InteractionStepType.ModelResponseSelector === t.type) {
          const { selectedIndex: e } = t.context;
          if (void 0 === e) return;
          const n = t.context.candidates[e];
          if (void 0 === n) return;
          (t.context.selectedId = n.id), (t.output = n.message.content);
        } else
          i.InteractionStepType.TextCollection === t.type ||
          i.InteractionStepType.QualityMeasurement === t.type
            ? S(e.params.fields, t.context.response)
            : i.InteractionStepType.TextCollectionPerResponse === t.type &&
              Object.keys(t.context.annotations).map((n) => {
                S(e.params.fields, t.context.annotations[n]);
              });
      }
      t.ensureTextCollectionAnnotation = S;
      const C = (e, t = {}) => {
        if (e.contextType === i.ContextType.Skipped) return !1;
        const {
          previousStepResponse: n,
          stepParams: r,
          allStepResponses: o,
          benchmarkEdit: a,
        } = t;
        if (r && o && !d.isConditionallyVisible(r, o, e.index)) return !1;
        return (
          !(n && n.output === e.output && !a) &&
          u.RESPONSE_GENERATOR_STEPS.includes(e.type)
        );
      };
      function I(e, t, n) {
        return (
          o.default.isEqual(e.context.originalText, t) ||
            n ||
            ((e.context.originalText = t),
            (e.context.baseResponse = t),
            (e.output = t)),
          e.output
        );
      }
      function R(e, t, n, r) {
        const {
          use_last_model_responses: a,
          use_existing_model_response_as_option: s,
          replace_last_selected_candidate_with_existing: l,
          always_send_given_id: c,
          skip_selection: p,
        } = e.params;
        a &&
          r &&
          (t.context.candidates = o.default.cloneDeep(r.context.candidates));
        const u = t.context.candidates,
          d = o.default.keyBy(u, "id");
        s && d[i.EXISTING_CANDIDATE_ID] && P(u, n, i.EXISTING_CANDIDATE_ID);
        const m = r?.context.selectedId;
        l && m && m.length > 0 && P(u, n, m);
        const h = c && c.length > 0 ? c : t.context.selectedId;
        return (
          h.length > 0 &&
          d[h] &&
          !o.default.isEqual(t.output, d[h].message.content)
            ? (t.output = d[h].message.content)
            : p && u.length > 1 && (t.output = n),
          t.output
        );
      }
      function x(e, t, n) {
        if (!n) return t.output;
        const { always_send_given_id: i } = e.params,
          r = o.default.keyBy(o.default.cloneDeep(n.context.candidates), "id");
        t.context.rankedCandidates = t.context.rankedCandidates.map((e) =>
          e.map((e) => r[e.id])
        );
        let a = t.context.rankedCandidates[0][0].message.content;
        return (
          i && r[i] && (a = r[i].message.content),
          o.default.isEqual(t.output, a) || (t.output = a),
          t.output
        );
      }
      function L(
        e,
        t,
        n,
        r = { stopAtNextInteractionStepTrigger: !1, benchmarkEdit: !1 }
      ) {
        const {
          stopAtNextInteractionStepTrigger: a,
          previousStepResponse: s,
          benchmarkEdit: l,
        } = r;
        if (!C(t[n], { previousStepResponse: s, benchmarkEdit: l })) return;
        const c = new d.ChatHistory(e, {
          responses: t,
        }).getFlattenedStepsWithResponses();
        let p = t[n].output;
        for (let u = n + 1; u < c.length; u++) {
          const [e, n] = c[u];
          if (!e || !n) break;
          if (e.type !== n.type)
            throw new Error(
              `Mismatch between step type and response type at index ${u}: ${e.type} !== ${n.type}`
            );
          if (e.type === i.InteractionStepType.TextCollectionPerResponse) {
            const e = w(t, u, i.InteractionStepType.ModelResponseSelector);
            e &&
              (n.context.candidates = o.default.cloneDeep(
                e.context.candidates
              ));
          }
          if (n.type !== i.InteractionStepType.PromptInput) {
            if (n.type === i.InteractionStepType.MultiTurnContinue) {
              n.context.message = p;
              break;
            }
            if (C(n, { stepParams: e, allStepResponses: t })) {
              if (a) break;
              if (n.type === i.InteractionStepType.ModelResponseEditor)
                p = I(n, p, !!l);
              else if (
                e.type === i.InteractionStepType.ModelResponseSelector &&
                n.type === i.InteractionStepType.ModelResponseSelector
              ) {
                p = R(
                  e,
                  n,
                  p,
                  w(t, u, i.InteractionStepType.ModelResponseSelector)
                );
              } else if (
                e.type === i.InteractionStepType.ModelResponseRanking &&
                n.type === i.InteractionStepType.ModelResponseRanking
              ) {
                p = x(
                  e,
                  n,
                  w(t, u, i.InteractionStepType.ModelResponseSelector)
                );
              } else p = n.output;
            }
            n.output = p;
          }
        }
      }
      function w(e, t, n) {
        return e
          .slice(0, t)
          .filter(
            (e) => e.type === n && e.contextType !== i.ContextType.Skipped
          )
          .at(-1);
      }
      function P(e, t, n) {
        const i = e.find((e) => e.id === n);
        i && (i.message.content = t);
      }
      t.interactionStepTriggersPropagation = C;
      t.getMostRecentPrompt = (e, t) =>
        e
          .slice(0, t)
          .filter(
            (e) =>
              e.type === i.InteractionStepType.PromptInput ||
              e.type === i.InteractionStepType.MultiTurnContinue
          )
          .at(-1)?.output;
      t.getMostRecentResponse = (e, t) =>
        e
          .slice(0, t)
          .filter(
            (e) =>
              e.contextType !== i.ContextType.Skipped &&
              u.RESPONSE_GENERATOR_STEPS.includes(e.type)
          )
          .at(-1)?.output;
      const E = (e, t) =>
          e.before.length + e.turn.length + (t - 1) * (e.turn.length + 1),
        A = (e) => {
          for (let t = 0; t < e.length; t++) e[t].index = t;
        };
      t.ensureStepResponseIndexConsistency = A;
      const k = (e) => {
        for (let t = 0; t < e.length; t++)
          if (e[t].index !== t)
            return {
              valid: !1,
              message: `The response at index ${t} has index ${e[t].index} instead!`,
            };
        return { valid: !0 };
      };
      t.resetChatHistoryFromSelectedResponse = (e, t, n) => {
        const r = n.index,
          a = t.slice(0, r),
          s = t
            .slice(r + 1)
            .find((e) => e.type === i.InteractionStepType.MultiTurnContinue),
          l = [
            ...a,
            n,
            ...(!o.default.isNil(s) && s.context.shouldContinue
              ? t.slice(r + 1, s.index)
              : t.slice(r + 1)),
          ];
        return L(e, l, r, { previousStepResponse: n }), l;
      };
      t.reactivateSession = (e) => {
        const t = e
          .filter((e) => e.type === i.InteractionStepType.MultiTurnContinue)
          .at(-1)?.index;
        return o.default.isNil(t) ? e : e.slice(0, t);
      };
      t.deleteAllTurnsAfterTurnIndex = (e, t, n) => {
        const r = E(t, n + 1),
          a = o.default.cloneDeep(e),
          s = a.slice(0, r + 1);
        let l = [];
        const c = e
          .filter((e) => e.type === i.InteractionStepType.MultiTurnContinue)
          .at(-1);
        !o.default.isNil(c) &&
          !c.context.shouldContinue &&
          c.index < e.length - 1 &&
          (l = a.slice(c.index + 1));
        const p = o.default.last(s);
        o.default.isNil(p) ||
          ((p.context.shouldContinue = !1), (p.output = ""));
        const u = [...s, ...l];
        return A(u), u;
      };
      t.deleteTurn = (e, t, n) => {
        const i = o.default.cloneDeep(e),
          r = E(t, n),
          a = i.slice(0, r),
          s = i.slice(r + t.turn.length + 1),
          l = i[r].context.message;
        s[0].context.message = l;
        const c = [...a, ...s];
        return A(c), c;
      };
      t.duplicateTurn = (e, t, n) => {
        const i = E(t, n),
          r = o.default.cloneDeep(e.slice(i, i + t.turn.length + 1)),
          a = e.slice(0, i + t.turn.length + 1),
          s = e.slice(i + t.turn.length + 1),
          l = s[0].context.message;
        r[0].context.message = l;
        const c = [...a, ...r, ...s];
        return A(c), c;
      };
      t.addTurn = (e, t, n) => {
        const r = o.default.cloneDeep(e),
          a = E(t, n + 1),
          s = r.slice(0, a),
          c = r.slice(a),
          p = {
            step_id:
              t.before.find((e) => e.type === i.InteractionStepType.PromptInput)
                ?.id ?? l.default.v4(),
            index: a,
            type: i.InteractionStepType.MultiTurnContinue,
            context: d.getNullContextForStepType(
              i.InteractionStepType.MultiTurnContinue
            ),
            contextType: i.ContextType.Skipped,
            output: "",
          },
          u = t.turn.map((e, t) => {
            const n = {
              type: e.type,
              context: d.getNullContextForStepType(e.type),
              contextType: i.ContextType.Skipped,
              output: "",
            };
            return { step_id: e.id, index: a + t + 1, ...n };
          });
        c[0].context.message = "";
        const m = [...s, p, ...u, ...c];
        A(m);
        return {
          newResponses: m,
          newCompletedSteps: Object.fromEntries(
            Array.from({ length: m.length }, (e, n) =>
              n >= a && n < a + t.turn.length + 1 ? [n, !1] : [n, !0]
            )
          ),
        };
      };
      t.swapTurns = (e, t, n) => {
        const i = o.default.cloneDeep(e),
          r = E(t, n),
          a = E(t, n + 1),
          s = i.slice(0, r),
          l = i.slice(a + t.turn.length + 1),
          c = i.slice(r, a),
          p = i.slice(a, a + t.turn.length + 1),
          u = c[0].context.message,
          d = p[0].context.message,
          m = l[0].context.message;
        (p[0].context.message = u),
          (c[0].context.message = m),
          (l[0].context.message = d);
        const h = [...s, ...p, ...c, ...l];
        return A(h), h;
      };
      t.extractPrefilledMessages = (e) => {
        if (!e)
          return {
            prevMessages: [],
            taskingUserMessages: [],
            taskingAssistantMessages: [],
          };
        const t = e?.findIndex((e) => e.role === i.MessageRole.User);
        if (-1 === t)
          return {
            prevMessages: e,
            taskingUserMessages: [],
            taskingAssistantMessages: [],
          };
        const n = e.slice(0, t),
          r = e.slice(t);
        return {
          prevMessages: n,
          taskingUserMessages: r.filter((e) => e.role === i.MessageRole.User),
          taskingAssistantMessages: r.filter(
            (e) => e.role === i.MessageRole.Assistant
          ),
        };
      };
    },
    844159: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.ChatTaskParamsStages = t.RESPONSE_GENERATOR_STEPS = void 0);
      var i = n(232095);
      const r = [
        i.InteractionStepType.QuantitativeModelResponseSelector,
        i.InteractionStepType.ModelResponseSelector,
        i.InteractionStepType.ModelResponseEditor,
        i.InteractionStepType.ModelResponseRanking,
        i.InteractionStepType.SearchAutoComplete,
        i.InteractionStepType.ProcessSupervision,
        i.InteractionStepType.ExperimentalToolUse,
        i.InteractionStepType.ToolUseProcessSupervision,
        i.InteractionStepType.SpanFeedback,
      ];
      var o;
      (t.RESPONSE_GENERATOR_STEPS = r),
        (t.ChatTaskParamsStages = o),
        (function (e) {
          (e.Before = "before"), (e.Turn = "turn"), (e.After = "after");
        })(o || (t.ChatTaskParamsStages = o = {}));
    },
    153115: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.searchResponseSchema =
          t.formatChatJoiValidateError =
          t.chatParamsSchema =
          t.interactionStepParamsSchema =
          t.TEMPLATE_VARIABLE_REGEX =
            void 0);
      var i,
        r = (i = n(39300)) && i.__esModule ? i : { default: i },
        o = n(298784),
        a = n(974819),
        s = n(232095),
        l = n(167469),
        c = n(854358),
        p = n(561630);
      const u = /^\{\{ *?\w+ *?\}\}$/;
      t.TEMPLATE_VARIABLE_REGEX = u;
      const d = r.default
          .object()
          .keys({
            id: r.default.string().required(),
            title: r.default.string().optional(),
            subtitle: r.default.string().allow("").optional(),
            params: r.default.object().optional(),
            override_id: r.default.boolean().optional(),
          })
          .unknown(!0),
        m = r.default
          .object()
          .keys({
            visibility_restricted: r.default
              .array()
              .items(r.default.number())
              .optional(),
            editable_during_consensus: r.default
              .boolean()
              .custom((e, t) => {
                const { visibility_restricted: n = [] } = t.state.ancestors[0];
                return o.min(n) === l.ReviewLevel.ReviewConsensus || e;
              })
              .optional(),
          })
          .unknown(!0),
        h = r.default
          .object()
          .keys({
            readonly_review_levels: r.default
              .array()
              .items(r.default.number())
              .optional(),
          })
          .unknown(!0),
        f = d.keys({
          type: r.default
            .string()
            .valid(s.InteractionStepType.PromptInput)
            .required(),
          params: m
            .keys({
              instructions: r.default.string().required(),
              display_type: r.default
                .string()
                .valid(...Object.values(s.ChatMessageDisplayType))
                .optional(),
            })
            .required(),
        }),
        g = d.keys({
          type: r.default
            .string()
            .valid(s.InteractionStepType.Instruction)
            .required(),
          params: m.keys({
            instructions: r.default.string().required(),
            display_type: r.default
              .string()
              .valid(...Object.values(s.ChatMessageDisplayType))
              .optional(),
            enable_rtl_text: r.default.boolean().optional(),
            initial_prompt_text: r.default.string().optional(),
            enableAudioRecording: r.default.boolean().optional(),
            generatePrompts: r.default.boolean().optional(),
            systemPromptForPromptGeneration: r.default.string().optional(),
            promptGenerationModel: r.default.string().optional(),
          }),
        }),
        y = d.keys({
          type: r.default
            .string()
            .valid(s.InteractionStepType.ModelResponseSelector)
            .required(),
          params: m
            .keys({
              chat_models: r.default
                .array()
                .items(
                  r.default
                    .object()
                    .keys({
                      id: r.default.string().required(),
                      url: r.default.string().required(),
                      params: r.default.object().required(),
                      fallbackStrategy: r.default.string().optional(),
                      fallbackEndpoint: r.default
                        .object()
                        .keys({
                          id: r.default.string().required(),
                          url: r.default.string().required(),
                          params: r.default.object().required(),
                        })
                        .optional(),
                      name: r.default.string().optional(),
                    })
                )
                .custom((e, t) => {
                  const n = e.map((e) => e.id);
                  return e && o.uniq(n).length !== n.length
                    ? t.message({
                        custom: '"Chat Models" must have unique ids.',
                      })
                    : e;
                }),
              provided_model_responses: r.default
                .array()
                .items(
                  r.default
                    .object()
                    .keys({
                      id: r.default.string().required(),
                      content: r.default.string().required(),
                    })
                )
                .optional(),
              use_last_model_responses: r.default
                .boolean()
                .custom((e, t) => {
                  const {
                    chat_models: n = [],
                    provided_model_responses: i = [],
                  } = t.state.ancestors[0];
                  return e && (n.length > 0 || i.length > 0)
                    ? t.message({
                        custom:
                          '"Chat Models" and "Provided Model Responses" must be empty when "Use Last Model Responses" is enabled.',
                      })
                    : e;
                })
                .optional(),
              replace_last_selected_candidate_with_existing: r.default
                .boolean()
                .custom((e, t) => {
                  const { use_last_model_responses: n } = t.state.ancestors[0];
                  return e && !n
                    ? t.message({
                        custom:
                          '"Replace Last Selected Candidate with Existing" can only be enabled when "Use Last Model Responses" is enabled.',
                      })
                    : e;
                })
                .optional(),
              use_existing_model_response_as_option: r.default
                .boolean()
                .optional(),
              skip_initial_messages: r.default.boolean().optional(),
              only_use_initial_messages_for_turn: r.default
                .boolean()
                .optional(),
              force_consistent_responses: r.default
                .boolean()
                .custom((e, t) => {
                  const { chat_models: n = [] } = t.state.ancestors[0];
                  return e && 0 === n.length
                    ? t.message({
                        custom:
                          'Live Chat Models must be provided when "Force Consistent Responses" is enabled.',
                      })
                    : e;
                })
                .optional(),
              skip_selection: r.default.boolean().optional(),
              allow_reroll: r.default.boolean().optional(),
              allow_reroll_for_reviewers_only: r.default.boolean().optional(),
              allow_reroll_for_individual_candidates: r.default
                .boolean()
                .optional(),
              reset_history_on_change: r.default.boolean().optional(),
              always_send_given_id: r.default.string().optional(),
              show_likert_scale: r.default.boolean().optional(),
              max_likert: r.default.number().optional(),
              min_likert: r.default.number().optional(),
              custom_likert_labels: r.default
                .array()
                .items(r.default.string())
                .optional(),
              show_objectivity: r.default.boolean().optional(),
              show_justification: r.default.boolean().optional(),
              enable_rtl_text: r.default.boolean().optional(),
              enable_model_critique: r.default.boolean().optional(),
              exclude_system_prompt: r.default.boolean().optional(),
              use_most_recent_output: r.default.boolean().optional(),
              use_first_initial_message: r.default.boolean().optional(),
              use_last_response_for_step_id: r.default.string().optional(),
              propagate_response_attachments: r.default.boolean().optional(),
              use_previous_turn_model_response_as_option: r.default
                .boolean()
                .optional(),
              include_current_turn_in_chat_history: r.default
                .boolean()
                .optional(),
              prompt_input_step_id_to_use_for_current_turn: r.default
                .string()
                .optional(),
              enable_react_ui_rendering: r.default.boolean().optional(),
              should_execute_tools: r.default.boolean().optional(),
              tool_parsing_params: r.default
                .object({
                  toolIdRegex: r.default.string().optional(),
                  toolInputRegex: r.default.string().optional(),
                  toolOutputRegex: r.default.string().optional(),
                  reconstructionTemplate: r.default.string().optional(),
                })
                .optional(),
              omit_attachments: r.default.boolean().optional(),
              appended_user_message: r.default.string().optional(),
            })
            .required(),
        }),
        b = d.keys({
          type: r.default
            .string()
            .valid(
              s.InteractionStepType.ProcessSupervision,
              s.InteractionStepType.ExperimentalToolUse
            )
            .required(),
          params: m
            .keys({
              use_sub_chunking_strategy: r.default.boolean().optional(),
              sub_chunking_strategy: r.default.string().optional(),
              sub_chunking_strategy_params: r.default.object().optional(),
              tools: r.default.array().items(r.default.string()).optional(),
              configId: r.default.string().optional(),
              isActionPlanEnabled: r.default.boolean().optional(),
              enable_manual_mark_as_complete: r.default.boolean().optional(),
              tool_ids: r.default.array().items(r.default.string()).optional(),
              do_not_include_finish_by_default: r.default.boolean().optional(),
              skip_observation: r.default.boolean().optional(),
              allow_tool_call_response_errors: r.default.boolean().optional(),
              allow_add_actions: r.default.boolean().optional(),
              allow_add_thought_and_action: r.default.boolean().optional(),
              allow_delete_actions: r.default.boolean().optional(),
              concatenateCodeFromPreviousSteps: r.default.boolean().optional(),
              tool_ids_via_template_variable: r.default.string().optional(),
              require_incorrect_rating: r.default.boolean().optional(),
              min_num_tools_used: r.default.number().optional(),
              modelName: r.default.string().optional(),
              can_edit_observation: r.default.string().optional(),
              process_chunking_strategy: r.default.string().optional(),
              process_chunking_strategy_params: r.default.object().optional(),
              re_request_model: r.default.boolean().optional(),
              end_after_rating_ids: r.default
                .array()
                .items(r.default.any())
                .optional(),
              rating_buttons: r.default
                .array()
                .items(
                  r.default.object({
                    value: r.default
                      .alternatives()
                      .try(r.default.number(), r.default.string())
                      .required(),
                    label: r.default.string().required(),
                    color: r.default.string().optional(),
                  })
                )
                .optional(),
              fields_to_collect: r.default
                .array()
                .items(
                  r.default.object({
                    fieldId: r.default.string().required(),
                    label: r.default.string().required(),
                    description: r.default.string().required(),
                    collectForRatingValues: r.default
                      .array()
                      .items(
                        r.default
                          .alternatives()
                          .try(r.default.number(), r.default.string())
                          .required()
                      )
                      .required(),
                    required: r.default.boolean().required(),
                    type: r.default
                      .string()
                      .valid(
                        "markdown",
                        "plaintext",
                        "multiselect",
                        "select",
                        "latex"
                      )
                      .required(),
                    options: r.default
                      .array()
                      .items(
                        r.default.object({
                          value: r.default.string().required(),
                          label: r.default.string().required(),
                        })
                      )
                      .optional(),
                  })
                )
                .optional(),
              min_negative_ratings: r.default.number().optional(),
              allow_skip: r.default.boolean().optional(),
              enable_edit_without_reroll: r.default.boolean().optional(),
              input_step_id: r.default.string().optional(),
              disable_edit_chunks: r.default.boolean().optional(),
              prerating_strategies: r.default
                .array()
                .items(r.default.object())
                .optional(),
              enable_rtl_text: r.default.boolean().optional(),
              initial_input: r.default.string().optional(),
              initial_prompt: r.default.string().optional(),
              disable_manual_chunk_validation: r.default.boolean().optional(),
              output_first_bad_rating_only: r.default.boolean().optional(),
              remove_regex_matches: r.default.string().optional(),
              edit_chunks_title: r.default.string().optional(),
              enable_process_critique: r.default.boolean().optional(),
              process_critique_review_levels: r.default
                .array()
                .items(r.default.number())
                .optional(),
              has_gtfa: r.default.boolean().optional(),
              limit_chat_history: r.default.boolean().optional(),
              remove_prompt_templating: r.default.boolean().optional(),
              custom_prompt_template: r.default.string().optional(),
              min_reflections_before_rewrite: r.default.number().optional(),
            })
            .required(),
        }),
        T = b,
        _ = d.keys({
          type: r.default
            .string()
            .valid(s.InteractionStepType.SearchAutoComplete)
            .required(),
          params: m
            .keys({
              chat_models: r.default
                .array()
                .items(
                  r.default
                    .object()
                    .keys({
                      id: r.default.string().required(),
                      url: r.default.string().required(),
                      params: r.default.object().required(),
                      name: r.default.string().optional(),
                    })
                )
                .length(1),
              make_additional_references_optional: r.default
                .boolean()
                .optional(),
              enable_rtl_text: r.default.boolean().optional(),
            })
            .required(),
        }),
        S = d.keys({
          type: r.default
            .string()
            .valid(s.InteractionStepType.SearchReferences)
            .required(),
          params: m
            .keys({
              chat_models: r.default
                .array()
                .items(
                  r.default
                    .object()
                    .keys({
                      id: r.default.string().required(),
                      url: r.default.string().required(),
                      params: r.default.object().required(),
                      name: r.default.string().optional(),
                    })
                )
                .length(1),
              enable_rtl_text: r.default.boolean().optional(),
            })
            .required(),
        }),
        v = d.keys({
          type: r.default
            .string()
            .valid(s.InteractionStepType.ModelResponseEditor)
            .required(),
          params: m.keys({
            enable_inline_comments: r.default.boolean().optional(),
            enable_rtl_text: r.default.boolean().optional(),
            termination_regex_condition: r.default.string().optional(),
            enable_executable_code_block: r.default.boolean().optional(),
            step_id_to_use_output_as_original_text: r.default
              .string()
              .optional(),
            enable_react_ui_rendering: r.default.boolean().optional(),
          }),
        }),
        C = d.keys({
          type: r.default
            .string()
            .valid(s.InteractionStepType.TextCollection)
            .required(),
          params: m
            .concat(h)
            .keys({
              fields: r.default
                .array()
                .items(a.unitFieldAlternativesSchema)
                .required(),
              show_last_response: r.default.boolean().optional(),
              enable_inline_comments: r.default.boolean().optional(),
              prevent_retroactive_edits: r.default.boolean().optional(),
              enable_rtl_text: r.default.boolean().optional(),
              save_as_system_message: r.default.boolean().optional(),
            })
            .required(),
        }),
        I = d.keys({
          type: r.default
            .string()
            .valid(s.InteractionStepType.QualityMeasurement)
            .required(),
          params: m
            .keys({
              fields: r.default
                .array()
                .items(a.unitFieldAlternativesSchema)
                .required(),
              enable_rtl_text: r.default.boolean().optional(),
            })
            .required(),
        }),
        R = d.keys({
          type: r.default
            .string()
            .valid(s.InteractionStepType.TextCollectionPerResponse)
            .required(),
          params: m
            .keys({
              chat_models: r.default
                .array()
                .items(
                  r.default
                    .object()
                    .keys({
                      id: r.default.string().required(),
                      url: r.default.string().required(),
                      params: r.default.object().required(),
                      name: r.default.string().optional(),
                    })
                )
                .custom((e, t) => {
                  const n = e.map((e) => e.id);
                  return e && o.uniq(n).length !== n.length
                    ? t.message({
                        custom: '"Chat Models" must have unique ids.',
                      })
                    : e;
                })
                .optional(),
              fields: r.default
                .array()
                .items(a.unitFieldAlternativesSchema)
                .required(),
              fieldToCheck: r.default
                .string()
                .custom((e, t) => {
                  const { fields: n = [] } = t.state.ancestors[0];
                  return n.some((t) => t.field_id === e)
                    ? e
                    : t.message({
                        custom:
                          '"Ensure Ranking/Selection Consistency for the Given Field ID" in Text Collection Per-Response step must match a field id.',
                      });
                })
                .optional(),
              enable_inline_comments: r.default.boolean().optional(),
              enable_rtl_text: r.default.boolean().optional(),
            })
            .required(),
        }),
        x = d.keys({
          type: r.default.string().valid(s.InteractionStepType.NER).required(),
          params: m
            .keys({
              labels: r.default.array(),
              relationships: r.default.array().optional(),
              allow_overlapping_annotations: r.default.boolean().optional(),
              provided_text_step_id: r.default.string().optional(),
              provided_text_field_id: r.default.string().optional(),
              enable_rtl_text: r.default.boolean().optional(),
              default_attribute_fields: r.default.object().optional(),
            })
            .required(),
        }),
        L = d.keys({
          type: r.default
            .string()
            .valid(s.InteractionStepType.MultiTurnContinue)
            .required(),
          params: m
            .keys({
              instructions: r.default.string().required(),
              enable_rtl_text: r.default.boolean().optional(),
            })
            .required(),
        }),
        w = d.keys({
          type: r.default
            .string()
            .valid(s.InteractionStepType.ModelResponseRanking)
            .required(),
          params: m
            .keys({
              always_send_given_id: r.default.string().optional(),
              enable_rtl_text: r.default.boolean().optional(),
              allow_ties: r.default.boolean().optional(),
            })
            .required(),
        }),
        P = d.keys({
          type: r.default
            .string()
            .valid(s.InteractionStepType.ContextDirections)
            .required(),
          params: m
            .keys({ enable_rtl_text: r.default.boolean().optional() })
            .required(),
        }),
        E = r.default
          .object()
          .keys({
            attachmentType: r.default
              .string()
              .valid(...Object.values(c.AttachmentMetadataType))
              .required(),
            metadata: r.default.string().optional(),
          })
          .unknown(!0),
        A = r.default
          .when(
            r.default
              .object({ type: s.InteractionStepType.PromptInput })
              .unknown(),
            { then: f }
          )
          .when(
            r.default
              .object({ type: s.InteractionStepType.ModelResponseSelector })
              .unknown(),
            { then: y }
          )
          .when(
            r.default
              .object({ type: s.InteractionStepType.Instruction })
              .unknown(),
            { then: g }
          )
          .when(
            r.default
              .object({ type: s.InteractionStepType.ModelResponseEditor })
              .unknown(),
            { then: v }
          )
          .when(
            r.default
              .object({ type: s.InteractionStepType.ProcessSupervision })
              .unknown(),
            { then: b }
          )
          .when(
            r.default
              .object({ type: s.InteractionStepType.ExperimentalToolUse })
              .unknown(),
            { then: T }
          )
          .when(
            r.default
              .object({ type: s.InteractionStepType.TextCollection })
              .unknown(),
            { then: C }
          )
          .when(
            r.default
              .object({ type: s.InteractionStepType.QualityMeasurement })
              .unknown(),
            { then: I }
          )
          .when(
            r.default
              .object({ type: s.InteractionStepType.TextCollectionPerResponse })
              .unknown(),
            { then: R }
          )
          .when(
            r.default.object({ type: s.InteractionStepType.NER }).unknown(),
            { then: x }
          )
          .when(
            r.default
              .object({ type: s.InteractionStepType.MultiTurnContinue })
              .unknown(),
            { then: L }
          )
          .when(
            r.default
              .object({ type: s.InteractionStepType.ContextDirections })
              .unknown(),
            { then: P }
          )
          .when(
            r.default
              .object({ type: s.InteractionStepType.SearchAutoComplete })
              .unknown(),
            { then: _ }
          )
          .when(
            r.default
              .object({ type: s.InteractionStepType.SearchReferences })
              .unknown(),
            { then: S }
          )
          .when(
            r.default
              .object({ type: s.InteractionStepType.ModelResponseRanking })
              .unknown(),
            { then: w }
          );
      t.interactionStepParamsSchema = A;
      const k = r.default
          .object()
          .keys({
            role: r.default
              .string()
              .custom((e, t) => {
                const n = Object.values(s.MessageRole);
                return n.includes(e) || u.test(e)
                  ? e
                  : t.message({
                      custom: `Role must be one of ${n.join(
                        ", "
                      )} or a template variable wrapped with {{}} such as {{TEMPLATE VARIABLE}}.`,
                    });
              })
              .required(),
            content: r.default.string().allow("").optional(),
            options: r.default
              .array()
              .items(
                r.default
                  .object()
                  .keys({
                    id: r.default.string().required(),
                    content: r.default.string().required(),
                    attachments: r.default.array().items(E).optional(),
                  })
              )
              .optional(),
            userEditable: r.default.boolean().optional(),
            initialLikertScore: r.default.number().optional(),
            promptAttachments: r.default.array().optional(),
          })
          .unknown(!0),
        O = r.default.object({
          format: r.default
            .string()
            .default("wav")
            .valid(...p.SUPPORTED_AUDIO_FORMATS),
          maxVolume: r.default.number().min(-70).max(0).optional(),
          minAverageVolume: r.default.number().min(-70).max(0).optional(),
          maxAverageVolume: r.default.number().min(-70).max(0).optional(),
          maxAmbientNoiseVolume: r.default.number().min(-70).max(0).optional(),
          minBackgroundNoiseScore: r.default.number().optional(),
          minOverallSpeechScore: r.default.number().optional(),
        }),
        M = r.default
          .object()
          .keys({
            before: r.default.array().items(A).required(),
            turn: r.default.array().items(A).required(),
            after: r.default.array().items(A).required(),
            qir: r.default.array().max(1).items(A).optional(),
            minTurns: r.default
              .alternatives()
              .try(
                r.default.number().integer().min(1).required(),
                r.default.string().regex(u).required()
              )
              .required(),
            maxTurns: r.default
              .alternatives()
              .try(
                r.default.number().integer().required(),
                r.default.string().regex(u).required()
              )
              .required(),
            initialMessages: r.default.array().items(k).optional(),
            templateVariables: r.default
              .object()
              .pattern(r.default.string(), r.default.string())
              .optional(),
            hypothesis: r.default.object().optional(),
            useReferenceText: r.default.boolean().optional(),
            useReferenceTextOnMultiTurn: r.default.boolean().optional(),
            isReferenceTextRequired: r.default.boolean().optional(),
            hideReferenceURL: r.default.boolean().optional(),
            requireReferenceTextOnlySingleTurn: r.default.boolean().optional(),
            minReferenceTexts: r.default.number().integer().min(0).optional(),
            maxReferenceTexts: r.default
              .number()
              .integer()
              .min(1)
              .max(10)
              .optional(),
            useDefaultUserMessage: r.default.boolean().optional(),
            defaultUserMessageEditable: r.default.boolean().optional(),
            defaultUserMessage: r.default.string().optional().allow(""),
            usePreviousUserMessage: r.default.boolean().optional(),
            endSessionCondition: r.default.string().optional(),
            providedChatHistoryJson: r.default.string().optional(),
            enableSkipPromptInput: r.default.boolean().optional(),
            useAttachments: r.default.boolean().optional(),
            useAttachmentsOnMultiTurn: r.default.boolean().optional(),
            isAttachmentRequired: r.default.boolean().optional(),
            imageProvidedByCustomer: r.default.boolean().optional(),
            imageUrlTemplateVariable: r.default.string().optional(),
            disableImageEditing: r.default.boolean().optional(),
            useImageUrls: r.default.boolean().optional(),
            useImageUrlsOnMultiTurn: r.default.boolean().optional(),
            isImageUrlRequired: r.default.boolean().optional(),
            requireImageUrlsOnlySingleTurn: r.default.boolean().optional(),
            displayExecutedCode: r.default.boolean().optional(),
            minAttachments: r.default.number().integer().min(0).optional(),
            maxAttachments: r.default.number().integer().min(0).optional(),
            imageValidatorSettings: r.default.object().optional(),
            isDragAndDropDisabled: r.default.boolean().optional(),
            enableDownloadAttachments: r.default.boolean().optional(),
            enableMmImageService: r.default.boolean().optional(),
            allowNSFWImagesFromDB: r.default.boolean().optional(),
            audio: O.optional(),
            systemPrompt: r.default.string().optional().allow(""),
            systemPromptGptOnly: r.default.boolean().optional(),
            userPromptTemplate: r.default.string().optional().allow(""),
            restrictRollbacksInReview: r.default.boolean().optional(),
            enableLastTurnEditing: r.default.boolean().optional(),
            enableMassTurnDeletion: r.default.boolean().optional(),
            enableConversationEditing: r.default.boolean().optional(),
            forceHistoryReset: r.default.boolean().optional(),
            forceHistoryResetForResponseChanges: r.default.boolean().optional(),
            disablePromptEditing: r.default.boolean().optional(),
            resetChatHistoryOnEachTurn: r.default.boolean().optional(),
            passDownOriginalAttachments: r.default.boolean().optional(),
            isPromptGenerationEnabled: r.default.boolean().optional(),
            promptGenerationSystemPrompt: r.default.string().optional(),
            promptGenerationModel: r.default.string().optional(),
            isPreSeededPromptSuggestionEnabled: r.default.boolean().optional(),
            preSeededPromptSuggestions: r.default.string().optional(),
            specializations: r.default.string().optional().allow(""),
            workerSkills: r.default.string().optional().allow(""),
            turnLocking: r.default.boolean().optional(),
            renderCode: r.default.boolean().optional(),
            codeRegex: r.default.string().optional(),
            maxProcessSupervisions: r.default
              .number()
              .min(1)
              .max(100)
              .optional(),
            showMessageRoles: r.default.boolean().optional(),
            messageRoleOptions: r.default
              .array()
              .items(r.default.string())
              .optional(),
            messageRolePromptInputHint: r.default.string().optional(),
            defaultExpand: r.default.boolean().optional(),
            messageForContributor: r.default.object().optional(),
            allowedExtensions: r.default
              .array()
              .items(r.default.string())
              .optional(),
          })
          .unknown(!0);
      t.chatParamsSchema = M;
      t.formatChatJoiValidateError = (e, t) =>
        e.details.map((e) => {
          const n = e.path.length > 1,
            i = e.path[e.path.length - 1];
          let r;
          if ("custom" === e.type) r = e.message;
          else if (n) {
            let [n, a] = e.path;
            const s = `${n}.${a}`,
              l = o.get(t, s),
              p = c.InteractionStepConfig[l.type]?.title;
            (n && "string" === typeof n) || (n = ""),
              "number" !== typeof a && (a = parseInt(a));
            const u = /"([^"]*)"/,
              d = e.message.replace(u, `"${i}"`);
            r = `Error at: ${o.capitalize(n)} step number ${
              a + 1
            } - ${p} - Field ${d}`;
          } else r = `Field ${e.message}`;
          return r;
        });
      const N = r.default
          .object()
          .keys({
            query: r.default.string().required(),
            snippet: r.default.string().required(),
            url: r.default.string().allow("", null).optional(),
            link: r.default.string().allow("", null).optional(),
            title: r.default.string().allow("", null).optional(),
            sourceTitle: r.default.string().allow("", null).optional(),
            isChecked: r.default.boolean().optional(),
          })
          .unknown(!0),
        z = r.default
          .object()
          .keys({
            searchTerm: r.default.string().required(),
            searchResults: r.default.array().items(N).required(),
            hasRunAutocomplete: r.default.boolean().optional(),
          })
          .unknown(!0);
      t.searchResponseSchema = z;
    },
    783768: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.BackfillTaskOption =
          t.TaxonomyConstant =
          t.BackfillTaskType =
          t.BackfillEligibility =
          t.ProjectSuperType =
          t.ProjectArchetypeToType =
          t.ProjectArchetype =
            void 0);
      var i,
        r = n(956840);
      (t.ProjectArchetype = i),
        (function (e) {
          (e.Eval = "Eval"),
            (e.RLHF = "RLHF"),
            (e.SFT = "SFT"),
            (e.ProcessSupervision = "Process Supervision");
        })(i || (t.ProjectArchetype = i = {}));
      const o = {
        [i.RLHF]: r.GenAIProjectType.RLHF_PREF_RANKING,
        [i.Eval]: r.GenAIProjectType.EVALS,
        [i.SFT]: r.GenAIProjectType.SFT,
        [i.ProcessSupervision]: r.GenAIProjectType.PROCESS_SUPERVISION,
      };
      var a, s, l;
      (t.ProjectArchetypeToType = o),
        (t.ProjectSuperType = a),
        (function (e) {
          (e.ForeignLanguage = "Foreign Language"),
            (e.Math = "Math (uses LaTeX)"),
            (e.Code = "Code");
        })(a || (t.ProjectSuperType = a = {})),
        (t.BackfillEligibility = s),
        (function (e) {
          (e.Eligible = "Eligible"),
            (e.Ineligible = "Ineligible"),
            (e.NotNeeded = "Not Needed"),
            (e.Backfilled = "Backfilled");
        })(s || (t.BackfillEligibility = s = {})),
        (t.BackfillTaskType = l),
        (function (e) {
          (e.TrainingScenario = "Training Scenario"), (e.Task = "Task");
        })(l || (t.BackfillTaskType = l = {}));
      var c;
      (t.TaxonomyConstant = {
        Eval: {
          PlaceholderStepId: {
            PromptInputPlaceholderForEmptyInitialQuestions:
              "placeholder-step-prompt-input",
          },
          StandardStepId: {
            Instruction: "instruction",
            Initial: "initial_questions",
            SideBySide: "side_by_side_questions",
            PerResponseRatings: "per_response_ratings",
            ReviewerFeedback: "reviewer_feedback",
          },
          StandardFieldId: {
            RejectReason: "reject_reason",
            PreferenceLikert: "preferenceLikert",
            RankingJustification: "ranking_reasoning",
            Objectivity: "objectivity",
            Accuracy: "accuracy",
            AccuracyDescription: "accuracy_description",
            ResponseTruthfulness: "response_truthfulness",
            ResponseIF: "response_if",
            ResponseInstructionFollowing: "response_instruction_following",
            InstructionFollowingDescription:
              "instruction_following_description",
            ResponseConcisenessRelevance: "response_conciseness_relevance",
            ResponseWritingStyleTone: "response_writing_style_tone",
            StyleAndTone: "style_and_tone",
            Truthfulness: "truthfulness",
            InstructionFollowing: "instruction_following",
            MainRequestAdherence: "main_request_adherence",
            ConstraintAdherence: "constraint_adherence",
            Grammar: "grammar",
            Relevance: "relevance",
            Verbosity: "verbosity",
            ResponseRelevance: "response_relevance",
            Depth: "depth",
            OverallScore: "overall_score",
            WritingQuality: "writing_quality",
            ToolLogCorrectness: "tool_log_correctness",
            ToolNamesCorrectness: "tool_names_correctness",
            ToolFunctionsCorrectness: "tool_functions_correctness",
            ToolParameterCorrectness: "tool_functions_parameter_correctness",
            Fulfillment: "fulfillment",
            ValidRejectReason: "valid_reject_reason",
            PreferenceAgreement: "preference_agreement",
            JustificationRating: "justification_rating",
            Feedback: "feedback",
          },
        },
        RLHF: {
          StandardStepId: {
            Prompt: "prompt",
            PostPromptQuestions: "post_prompt_questions",
            SideBySide: "side_by_side_questions",
            PerResponseRatings: "per_response_ratings",
            ModelResponseEditing: "model_response_editing",
            PostRewriteQuestions: "post_rewrite_questions",
            PostTurnQuestions: "post_turn_questions",
            ReviewerFeedback: "reviewer_feedback",
          },
          StandardFieldId: {
            RankingJustification: "ranking_reasoning",
            Accuracy: "accuracy",
            Completeness: "completeness",
            Fluency: "fluency",
            Grammar: "grammar",
            Localized: "localized",
            Format: "format",
            SelectedResponseIsGood: "selected_response_is_good",
            BetterResponseJustification: "better_response_justification",
            OverallScore: "overall_score",
            ValidRejectReason: "valid_reject_reason",
            PreferenceAgreement: "preference_agreement",
            JustificationRating: "justification_rating",
            Feedback: "feedback",
          },
        },
        SFT: {
          StandardStepId: {
            Prompt: "prompt",
            PostPromptQuestions: "post_prompt_questions",
            InitialUserResponse: "initial_user_response",
            PostResponseQuestions: "post_response_questions",
            ModelResponseComparison: "model_response_comparison",
            BetterResponseQuestions: "better_response_questions",
            PerResponseRatings: "per_response_ratings",
            ModelResponseEditing: "model_response_editing",
            PostRewriteQuestions: "post_rewrite_questions",
            PostTurnQuestions: "post_turn_questions",
            ReviewerFeedback: "reviewer_feedback",
          },
          StandardFieldId: {
            RankingJustification: "ranking_reasoning",
            Accuracy: "accuracy",
            Completeness: "completeness",
            Fluency: "fluency",
            Grammar: "grammar",
            Localized: "localized",
            Format: "format",
            SelectedResponseIsGood: "selected_response_is_good",
            BetterResponseJustification: "better_response_justification",
            OverallScore: "overall_score",
            RewriteExplanation: "rewrite_explanation",
            ValidRejectReason: "valid_reject_reason",
            PreferenceAgreement: "preference_agreement",
            JustificationRating: "justification_rating",
            Feedback: "feedback",
          },
        },
        ProcessSupervision: {
          StandardStepId: {
            Prompt: "prompt",
            PlanOfAction: "plan_of_action",
            IdealResponse: "ideal_response",
            ChainOfThought: "chain_of_thought",
          },
        },
      }),
        (t.BackfillTaskOption = c),
        (function (e) {
          (e.AttemptTask = "Attempt (L-1) Task"),
            (e.ReviewTask = "Review (L0) Task"),
            (e.AllOtherTasks = "All Other Review Level Tasks (Not L-1, L0)"),
            (e.AttempterBenchmark = "Attempter Benchmark"),
            (e.ReviewerBenchmark = "Reviewer Benchmark");
        })(c || (t.BackfillTaskOption = c = {}));
    },
    530869: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.formatJoiValidateError =
          t.responseSchemaAny =
          t.annotationSchema =
            void 0);
      var i,
        r = (i = n(39300)) && i.__esModule ? i : { default: i };
      const o = r.default
          .object()
          .keys({ selected: r.default.string().required() }),
        a = r.default
          .object()
          .keys({
            id: r.default.string().required(),
            start: r.default.number().min(0).required(),
            end: r.default
              .number()
              .greater(r.default.ref("start"))
              .max(r.default.ref("$textLength"))
              .required(),
            text: r.default.string().required(),
            label: r.default.string().required(),
            attributes: r.default
              .object()
              .pattern(r.default.string(), o)
              .optional(),
          });
      t.annotationSchema = a;
      const s = r.default
          .object()
          .keys({
            id: r.default.string().required(),
            source_ref: r.default.string().required(),
            target_ref: r.default.string().required(),
            name: r.default.string().optional(),
          }),
        l = r.default.alternatives(
          r.default.string(),
          r.default.array().items(r.default.string()),
          r.default.number()
        ),
        c = r.default
          .object()
          .keys({
            annotations: r.default.array().items(a).unique("id").required(),
            relationships: r.default.array().items(s).unique("id").optional(),
            global_attributes: r.default
              .object()
              .pattern(r.default.string(), l)
              .optional(),
          }),
        p = r.default
          .object()
          .keys({
            annotations: r.default.array().items(a).unique("id").required(),
            relationships: r.default
              .array()
              .allow(null)
              .items(s)
              .unique("id")
              .optional(),
            global_attributes: r.default
              .object()
              .pattern(r.default.string(), l)
              .optional(),
            confidenceScore: r.default.number().allow(null).optional(),
            confidences: r.default.object().allow(null).unknown(!0).optional(),
            agreementScores: r.default
              .object()
              .allow(null)
              .unknown(!0)
              .optional(),
            agreementScoreMean: r.default.number().allow(null).optional(),
            annotationConfidences: r.default
              .array()
              .allow(null)
              .items(r.default.number())
              .optional(),
          }),
        u = r.default.alternatives().try(c, p);
      t.responseSchemaAny = u;
      t.formatJoiValidateError = (e) => {
        const t = e.details[0],
          n = t.path.join(".");
        return `Invalid NER response, reason: ${t.message}, path: ${n}`;
      };
    },
    954282: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.isDistributionItem = function (e) {
          return "key" in e && "weight" in e && "fields" in e;
        }),
        (t.convertMistParams = function (e, t) {
          if (e) {
            const n = s.default.cloneDeep(e);
            return b(n, t), T(n, t), n;
          }
          return e;
        }),
        (t.convertPromptInputMinMaxWords = b),
        (t.convertMinMaxTurns = T),
        (t.findUniqueChatModels = function e(t) {
          let n = new Set();
          for (const i in t)
            if (Object.prototype.hasOwnProperty.call(t, i))
              if ("chat_models" === i && Array.isArray(t[i]))
                t[i].forEach((e) =>
                  n.add(
                    JSON.stringify({
                      modelName: e.params.model,
                      modelURL: e.url,
                    })
                  )
                );
              else if ("object" === typeof t[i] && null !== t[i]) {
                const r = e(t[i]);
                n = new Set([...n, ...r]);
              }
          return n;
        }),
        (t.BenchmarkArgFields =
          t.getSampledTask =
          t.getRowUniqueId =
          t.generateUniqueId =
          t.generateExpectedResponse =
          t.ACCEPTABLE_BM_FIELD_TYPES =
          t.parseChatModels =
          t.populateTemplateHelper =
          t.populateTemplate =
          t.CustomFilterTypes =
            void 0);
      var i,
        r = n(284040),
        o = n(108896),
        a = n(963494),
        s = (i = n(298784)) && i.__esModule ? i : { default: i },
        l = n(854358),
        c = n(899047),
        p = n(153115);
      var u;
      (t.CustomFilterTypes = u),
        (function (e) {
          (e.minWith = "minWith"), (e.scaleTo = "scaleTo");
        })(u || (t.CustomFilterTypes = u = {}));
      const d = {
        minWith: (e, t) => Math.min(e, t),
        scaleTo: (e, t, n, i, r) =>
          Math.round(((r - i) * (e - t)) / (n - t) + i),
      };
      t.populateTemplate = async (e, t, n, i = {}) => {
        const { includeTemplateVariables: r = !0 } = n || {},
          o = await h(e, t, n),
          a = s.default.isString(o) ? JSON.parse(o) : o;
        return r
          ? { ...a, templateVariables: t, templateVariablesConfiguration: i }
          : { ...a };
      };
      const m = new r.Liquid({ cache: !0 }),
        h = async (e, t, n) => {
          const {
              parseJson: i = !1,
              enabledCustomFilters: o = [],
              useCache: a = !1,
            } = n || {},
            s = a && !o?.length ? m : new r.Liquid();
          for (const r of o) s.registerFilter(r, d[r]);
          if ("string" === typeof e) {
            const n = await s.parseAndRender(e, t);
            try {
              return i ? JSON.parse(n) : n;
            } catch (l) {
              return n;
            }
          }
          if (Array.isArray(e)) {
            return await Promise.all(e.map(async (e) => h(e, t, n)));
          }
          if ("object" === typeof e && null !== e) {
            const i = {};
            return (
              await Promise.all(
                Object.keys(e).map(async (r) => {
                  i[r] = await h(e[r], t, n);
                })
              ),
              i
            );
          }
          return e;
        };
      function f(e) {
        const t = e.url;
        if (p.TEMPLATE_VARIABLE_REGEX.test(t)) return;
        const n = c.StrategyParamsSchemaMap[c.masterEndpointMap[t].strategy];
        if (!n) throw new Error(`No endpoint found for URL: ${t}`);
        const i = Object.fromEntries(
          Object.entries(e.params).filter(([, e]) => null !== e)
        );
        try {
          n.parse(i);
        } catch (r) {
          const t = r.issues[0].path.join("."),
            n = r.issues[0].message;
          throw new Error(
            `Invalid endpoint configuration for ${e.id}: ${t} - ${n}`
          );
        }
      }
      t.populateTemplateHelper = h;
      t.parseChatModels = (e) => {
        e &&
          e.turn &&
          e.turn.forEach((e) => {
            e.type === l.InteractionStepType.ModelResponseSelector &&
              e.params.chat_models.forEach((e) => {
                f(e),
                  (function (e) {
                    if (
                      !s.default.isNil(e.fallbackEndpoint) &&
                      (f(e.fallbackEndpoint),
                      s.default.isEqual(
                        s.default.pick(e, ["url", "params"]),
                        s.default.pick(e.fallbackEndpoint, ["url", "params"])
                      ))
                    )
                      throw new Error(
                        `Fallback endpoint cannot be identical to ${e.id}`
                      );
                  })(e);
              });
          });
      };
      const g = [
        a.TextCollectionFieldType.Text,
        a.TextCollectionFieldType.Number,
        a.TextCollectionFieldType.TranscriptionText,
        a.TextCollectionFieldType.Category,
        a.TextCollectionFieldType.Boolean,
        a.TextCollectionFieldType.RankingOrder,
        a.TextCollectionFieldType.Autocomplete,
        a.TextCollectionFieldType.Select,
        a.TextCollectionFieldType.Code,
      ];
      t.ACCEPTABLE_BM_FIELD_TYPES = g;
      t.generateExpectedResponse = (e, t) => {
        const n = y(e, t);
        return o.createMiniformResponseForFields(n, t);
      };
      const y = (e, t) => {
        const n = {};
        for (const i of t)
          switch (i.type) {
            case a.TextCollectionFieldType.Text:
            case a.TextCollectionFieldType.Number:
              n[i.field_id] = [e[i.field_id]];
              break;
            case a.TextCollectionFieldType.RankingOrder:
              n[i.field_id] = JSON.parse(e[i.field_id]);
              break;
            case a.TextCollectionFieldType.Autocomplete:
            case a.TextCollectionFieldType.QueryableTextAndResults:
            case a.TextCollectionFieldType.JSON:
            case a.TextCollectionFieldType.Select:
            case a.TextCollectionFieldType.TranscriptionText:
              n[i.field_id] = [e[i.field_id]];
              break;
            case a.TextCollectionFieldType.Category:
              n[i.field_id] = [
                [...e[i.field_id].split(",").map((e) => e.trim())],
              ];
              break;
            case a.TextCollectionFieldType.Boolean:
              n[i.field_id] = [Boolean(e[i.field_id])];
              break;
            case a.TextCollectionFieldType.FieldSet:
            case a.TextCollectionFieldType.Form:
              Object.assign(n, y(e, i.fields));
              break;
            case a.TextCollectionFieldType.Code:
              n[i.field_id] = [JSON.parse(e[i.field_id])];
              break;
            default:
              throw Error(
                `${i.type} is not compatible with the csv to benchmark tool`
              );
          }
        return n;
      };
      t.generateUniqueId = (e, t) => `${e}_${t}`;
      t.getRowUniqueId = (e) => e.split("_")[1];
      function b(e, t) {
        for (const n of [...e.before, ...e.turn, ...e.after])
          if (n.type === l.InteractionStepType.PromptInput) {
            if (
              void 0 !== n.params.maxWords &&
              "string" === typeof n.params.maxWords
            )
              if (isNaN(parseInt(n.params.maxWords, 10))) {
                if (t.failOnParseInt)
                  throw new Error("Failed to parse maxWords");
                n.params.maxWords = 987;
              } else n.params.maxWords = parseInt(n.params.maxWords, 10);
            if (
              void 0 !== n.params.minWords &&
              "string" === typeof n.params.minWords
            )
              if (isNaN(parseInt(n.params.minWords, 10))) {
                if (t.failOnParseInt)
                  throw new Error("Failed to parse minWords");
                n.params.minWords = 1;
              } else n.params.minWords = parseInt(n.params.minWords, 10);
          }
      }
      function T(e, t) {
        if (void 0 !== e.minTurns && "string" === typeof e.minTurns)
          if (isNaN(parseInt(e.minTurns, 10))) {
            if (t.failOnParseInt) throw new Error("Failed to parse minTurns");
            e.minTurns = 1;
          } else e.minTurns = parseInt(e.minTurns, 10);
        if (void 0 !== e.maxTurns && "string" === typeof e.maxTurns)
          if (isNaN(parseInt(e.maxTurns, 10))) {
            if (t.failOnParseInt) throw new Error("Failed to parse maxTurns");
            e.maxTurns = 1;
          } else e.maxTurns = parseInt(e.maxTurns, 10);
      }
      var _;
      (t.getSampledTask = (e) => {
        if (e && e.length > 0) {
          const t = [];
          for (const n of e) {
            if (!(n && n.length > 0))
              throw Error(`Distribution is not valid or empty: ${n}`);
            {
              if (n.every((e) => 0 === e.weight))
                throw Error("Distribution has all 0 weights");
              const e = s.default.sample(
                s.default.flatMap(n, (e) => s.default.times(e.weight, () => e))
              );
              e && t.push({ ...e.fields, key: e.key });
            }
          }
          if (t.length > 0) {
            const e = s.default.reduce(t, (e, t) => ({ ...e, ...t }), {});
            return (e.key = t.map((e) => e.key).join("|")), e;
          }
          return null;
        }
        throw Error("Distributions are not valid or empty");
      }),
        (t.BenchmarkArgFields = _),
        (function (e) {
          (e.IsInstructive = "is_instructive"),
            (e.BenchmarkFeedback = "feedback"),
            (e.SceneConfigs = "scene_configs"),
            (e.BenchmarkFeedbackV2 = "benchmark_feedback_v2"),
            (e.BenchmarkCandidate = "benchmark_candidate"),
            (e.InstructionItems = "instructionItems");
        })(_ || (t.BenchmarkArgFields = _ = {}));
    },
    147460: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.PreviewAction =
          t.UnsupportedTaskReason =
          t.EmptyStepReason =
          t.NameToReviewLevelStrategyV2 =
          t.NameToReviewLevelStrategy =
          t.ReviewLevelStrategyToNameV2 =
          t.ReviewLevelStrategyToName =
          t.BackfillDecisionV2 =
          t.BackfillDecision =
          t.ReviewLevelDecision =
          t.ReviewLevelOptionToReviewLevel =
          t.ReviewLevelToReviewLevelOption =
          t.ReviewLevelOption =
          t.ClaimStrategy =
          t.ReviewLevelStrategyV2 =
          t.ReviewLevelStrategy =
          t.FetchBackfillQueryStatus =
          t.ValidationTypeLabels =
          t.ValidationType =
            void 0);
      var i,
        r = n(599789);
      (t.ValidationType = i),
        (function (e) {
          (e.CONTEXT_EMAILS = "contextEmailsValidation"),
            (e.URL = "urlValidation"),
            (e.JSON = "jsonValidation");
        })(i || (t.ValidationType = i = {}));
      const o = {
        [i.CONTEXT_EMAILS]: "Email Validation",
        [i.URL]: "URL Validation",
        [i.JSON]: "JSON Validation",
      };
      var a, s, l, c, p;
      (t.ValidationTypeLabels = o),
        (t.FetchBackfillQueryStatus = a),
        (function (e) {
          (e[(e.Success = 0)] = "Success"),
            (e[(e.Error = 1)] = "Error"),
            (e[(e.InProgress = 2)] = "InProgress");
        })(a || (t.FetchBackfillQueryStatus = a = {})),
        (t.ReviewLevelStrategy = s),
        (function (e) {
          (e[(e.Stay = 0)] = "Stay"),
            (e[(e.Smart = 1)] = "Smart"),
            (e[(e.Restart = 2)] = "Restart");
        })(s || (t.ReviewLevelStrategy = s = {})),
        (t.ReviewLevelStrategyV2 = l),
        (function (e) {
          (e.Smart = "Preserve work where possible"),
            (e.Restart = "Restart from scratch");
        })(l || (t.ReviewLevelStrategyV2 = l = {})),
        (t.ClaimStrategy = c),
        (function (e) {
          (e.Preserve = "Preserve contributor claims"),
            (e.Eject = "Eject contributors");
        })(c || (t.ClaimStrategy = c = {})),
        (t.ReviewLevelOption = p),
        (function (e) {
          (e.Unstarted = "Unstarted"),
            (e.Attempt = "Attempt"),
            (e.L0 = "L0"),
            (e.L1 = "L1"),
            (e.L4 = "L4"),
            (e.L8 = "L8"),
            (e.L10 = "L10"),
            (e.L11 = "L11"),
            (e.L12 = "L12");
        })(p || (t.ReviewLevelOption = p = {}));
      const u = {
        [r.ReviewLevel.Attempt]: p.Attempt,
        [r.ReviewLevel.Normal]: p.L0,
        [r.ReviewLevel.Level1]: p.L1,
        [r.ReviewLevel.ReviewConsensus]: p.L4,
        [r.ReviewLevel.Expedite]: p.L8,
        [r.ReviewLevel.Corp]: p.L10,
        [r.ReviewLevel.CorpFlagged]: p.L11,
        [r.ReviewLevel.Deliverable]: p.L12,
      };
      t.ReviewLevelToReviewLevelOption = u;
      const d = {
        [p.Attempt]: r.ReviewLevel.Attempt,
        [p.L0]: r.ReviewLevel.Normal,
        [p.L1]: r.ReviewLevel.Level1,
        [p.L4]: r.ReviewLevel.ReviewConsensus,
        [p.L8]: r.ReviewLevel.Expedite,
        [p.L10]: r.ReviewLevel.Corp,
        [p.L11]: r.ReviewLevel.CorpFlagged,
        [p.L12]: r.ReviewLevel.Deliverable,
      };
      var m, h, f;
      (t.ReviewLevelOptionToReviewLevel = d),
        (t.ReviewLevelDecision = m),
        (function (e) {
          (e[(e.Stay = 0)] = "Stay"),
            (e[(e.Drop = 1)] = "Drop"),
            (e[(e.Restart = 2)] = "Restart");
        })(m || (t.ReviewLevelDecision = m = {})),
        (t.BackfillDecision = h),
        (function (e) {
          (e.OnlyParams = "OnlyParams"),
            (e.CancelAndRedo = "CancelAndRedo"),
            (e.ParamsAndResponse = "ParamsAndResponse");
        })(h || (t.BackfillDecision = h = {})),
        (t.BackfillDecisionV2 = f),
        (function (e) {
          (e.RestartFromScratch = "Restart (clear existing work)"),
            (e.PreserveWork = "Preserve existing work"),
            (e.RestartUnstarted = "Restart (task is unstarted)");
        })(f || (t.BackfillDecisionV2 = f = {}));
      const g = {
        [s.Stay]: "Stay",
        [s.Restart]: "Restart",
        [s.Smart]: "Smart",
      };
      t.ReviewLevelStrategyToName = g;
      const y = {
        [l.Restart]: "Restart from scratch",
        [l.Smart]: "Preserve work where possible",
      };
      t.ReviewLevelStrategyToNameV2 = y;
      const b = { Stay: s.Stay, Restart: s.Restart, Smart: s.Smart };
      t.NameToReviewLevelStrategy = b;
      const T = { Restart: l.Restart, Smart: l.Smart };
      var _, S, v;
      (t.NameToReviewLevelStrategyV2 = T),
        (t.EmptyStepReason = _),
        (function (e) {
          (e.NewStep = "This step is new"),
            (e.NewRequiredTurns = "At least one new required turn was added");
        })(_ || (t.EmptyStepReason = _ = {})),
        (t.UnsupportedTaskReason = S),
        (function (e) {
          (e.NoPrompt =
            "The backfill tool only supports tasks that have a PromptInput step with a valid step_id"),
            (e.DuplicateStepId =
              "The backfill tool does not support tasks with duplicate step ids (please fix this asap!!)");
        })(S || (t.UnsupportedTaskReason = S = {})),
        (t.PreviewAction = v),
        (function (e) {
          (e.None = "No, proceed as planned"),
            (e.Override = "Yes, keep all tasks in their current level"),
            (e.Filter = "Yes, filter out tasks that will move backward");
        })(v || (t.PreviewAction = v = {}));
    },
    971599: function (e, t) {
      "use strict";
      var n, i;
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.lintDiagnosticToIssues =
          t.issuesToLintDiagnostics =
          t.VALID_LINT_DISMISSAL_TYPES_FOR_ERROR_DISMISSAL =
          t.LINT_DISMISSAL_TYPE_TO_PERSIST =
          t.LintDismissalType =
          t.LintSeverity =
            void 0),
        (t.LintSeverity = n),
        (function (e) {
          (e.INFO = "INFO"),
            (e.WARNING = "WARNING"),
            (e.ERROR = "ERROR"),
            (e.DISMISSABLE_ERROR = "DISMISSABLE_ERROR"),
            (e.DEBUG = "DEBUG"),
            (e.RUNTIME_EXCEPTION = "RUNTIME_EXCEPTION"),
            (e.BLOCK_EDITING = "BLOCK_EDITING");
        })(n || (t.LintSeverity = n = {}));
      class r {
        constructor(e, t, n = {}, i = !1) {
          (this.id = e),
            (this.severity = t),
            (this.data = n),
            (this.experimental = i),
            (this.createdAt = new Date());
        }
      }
      (t.LintDiagnostic = r),
        (r.MAX_ELAPSED_TIME_MS = 6e5),
        (t.LintDismissalType = i),
        (function (e) {
          (e.Acknowledged = "acknowledged"),
            (e.Rejected = "rejected"),
            (e.Autofixed = "autofixed");
        })(i || (t.LintDismissalType = i = {}));
      const o = Object.freeze([i.Rejected, i.Autofixed]);
      t.LINT_DISMISSAL_TYPE_TO_PERSIST = o;
      const a = Object.freeze([i.Rejected, i.Autofixed]);
      t.VALID_LINT_DISMISSAL_TYPES_FOR_ERROR_DISMISSAL = a;
      t.issuesToLintDiagnostics = (e) =>
        e
          .filter((e) => e?.lintIssues?.length ?? !1)
          .map(
            (e) =>
              new r(e.linterId ?? "", e?.severity ?? n.WARNING, {
                message: e?.message ?? "",
                taskComponentAnnotations: e.lintIssues,
              })
          );
      t.lintDiagnosticToIssues = (e) =>
        e
          .filter((e) => e.data.taskComponentAnnotations)
          .flatMap((e) => e.data.taskComponentAnnotations)
          .map((e) => ({ [e.id]: e }));
    },
    112738: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.collectUnexpectedFieldIds = p),
        (t.validateTextCollectionResponse = function (e, t) {
          for (const r of Object.values(e.annotations))
            if (s.annotationSchema.validate(r)?.error)
              return {
                valid: !1,
                message: `Invalid TextCollection annotation: ${r}`,
              };
          const n = r.default.keyBy(
            o.flattenAnnotations(e.annotations),
            (e) => e.field_id
          );
          delete n.rlhf_history;
          const i = p(t, n);
          if (0 !== i.length)
            return {
              valid: !1,
              message: `Unexpected field ids: ${JSON.stringify(i)}`,
            };
          for (const [r, o] of Object.entries(n)) {
            const e = t[r],
              n = f[e.type] ?? h,
              { valid: i, message: a } = n({ field: e, annotation: o });
            if (!i)
              return {
                valid: !1,
                message: `Invalid response for field id ${r}: ${a}`,
              };
          }
          return { valid: !0 };
        }),
        (t.getCategoricalValidChoices = g);
      var i,
        r = (i = n(298784)) && i.__esModule ? i : { default: i },
        o = n(108896),
        a = n(963494),
        s = n(974819),
        l = n(689510),
        c = n(561630);
      function p(e, t) {
        const n = Object.keys(e);
        return Object.keys(t).filter((e) => !n.includes(e));
      }
      const u = ({ field: e, annotation: t }) => {
          const { values: n } =
            o.getValidValuesForFieldId([e], e.field_id) ?? {};
          if (!n) return { valid: !0 };
          e.type === a.TextCollectionFieldType.Number &&
            n.push(
              ...n
                .filter(
                  (e) => r.default.isString(e) && !r.default.isNaN(parseInt(e))
                )
                .map((e) => parseInt(e))
            );
          const i = t.response[0];
          return !r.default.isNil(i) && "" !== i && !n.includes(i)
            ? { valid: !1, message: `Unexpected choice: ${JSON.stringify(i)}` }
            : { valid: !0 };
        },
        d = ({ field: e, annotation: t }) => {
          const n = t.response[0];
          return r.default.isNil(n) || r.default.isString(n)
            ? { valid: !0 }
            : {
                valid: !1,
                message: `Expected a string, but got ${JSON.stringify(n)}`,
              };
        },
        m = l.z.object({
          type: l.z.literal(a.TextCollectionFieldType.AudioRecording),
          format: l.z
            .enum(c.SUPPORTED_AUDIO_FORMATS)
            .optional()
            .default("webm"),
          minAudioDuration: l.z.number().min(0).optional(),
          maxAudioDuration: l.z.number().min(1).optional(),
          maxVolume: l.z.number().min(-70).max(0).optional(),
          minAverageVolume: l.z.number().min(-70).max(0).optional(),
          maxAverageVolume: l.z.number().min(-70).max(0).optional(),
          maxAmbientNoiseVolume: l.z.number().min(-70).max(0).optional(),
          minBackgroundNoiseScore: l.z.number().optional(),
          minOverallSpeechScore: l.z.number().optional(),
        }),
        h = ({ field: e, annotation: t }) => ({ valid: !0 }),
        f = {
          [a.TextCollectionFieldType.Text]: d,
          [a.TextCollectionFieldType.TranscriptionText]: h,
          [a.TextCollectionFieldType.Boolean]: u,
          [a.TextCollectionFieldType.Number]: u,
          [a.TextCollectionFieldType.Datetime]: h,
          [a.TextCollectionFieldType.Category]: ({
            field: e,
            annotation: t,
          }) => {
            if (e.choicesS3Artifact) return { valid: !0 };
            const n = g(
                [e],
                r.default.get(e, "can_select_intermediate_nodes") || !1
              ),
              i = r.default.flatten(Object.values(n)).map((e) => e.toString());
            if (
              r.default.some(
                t.response,
                (e) => !r.default.isArray(e) && "" !== e
              )
            )
              return {
                valid: !1,
                message: `Invalid response: ${JSON.stringify(t.response)}`,
              };
            const o = r.default
              .flatten(t.response)
              .map((e) => e.toString())
              .filter((e) => "" !== e)
              .filter((e) => !i.includes(e));
            return 0 !== o.length
              ? {
                  valid: !1,
                  message: `Unexpected choices: ${JSON.stringify(o)}`,
                }
              : { valid: !0 };
          },
          [a.TextCollectionFieldType.FieldSet]: h,
          [a.TextCollectionFieldType.TimeRange]: h,
          [a.TextCollectionFieldType.Select]: h,
          [a.TextCollectionFieldType.Form]: h,
          [a.TextCollectionFieldType.BoundingBox]: h,
          [a.TextCollectionFieldType.Autocomplete]: h,
          [a.TextCollectionFieldType.RankingOrder]: h,
          [a.TextCollectionFieldType.RLHFHistory]: h,
          [a.TextCollectionFieldType.Code]: h,
          [a.TextCollectionFieldType.FileUpload]: h,
          [a.TextCollectionFieldType.QueryableTextAndResults]: h,
          [a.TextCollectionFieldType.JSON]: h,
          [a.TextCollectionFieldType.WorkspaceContainer]: h,
          [a.TextCollectionFieldType.WfeButton]: h,
          [a.TextCollectionFieldType.Markdown]: d,
          [a.TextCollectionFieldType.Tool]: h,
          [a.TextCollectionFieldType.Instruction]: h,
          [a.TextCollectionFieldType.Rubric]: h,
          [a.TextCollectionFieldType.AudioRecording]: ({
            field: e,
            annotation: t,
          }) => {
            const n = m.safeParse(e);
            if (!n.success)
              return {
                valid: !1,
                message: `Invalid AudioRecording field: ${JSON.stringify(
                  n.error
                )}`,
              };
            if (t.type !== a.TextCollectionFieldType.AudioRecording)
              return {
                valid: !1,
                message: `Expected AudioRecording annotation, but got ${t.type}`,
              };
            const { format: i } = n.data;
            return t.response.some((e) => e.mimeType !== `audio/${i}`)
              ? { valid: !1, message: "Invalid mimeType in response" }
              : { valid: !0 };
          },
          [a.TextCollectionFieldType.MultiChannelAudioUpload]: h,
          [a.TextCollectionFieldType.DynamicLabeledText]: h,
          [a.TextCollectionFieldType.AttachmentUpload]: h,
        };
      function g(e, t) {
        const n = (e) => {
            let i = [];
            return (
              e.forEach((e) => {
                e.subchoices
                  ? ((i = i.concat(n(e.subchoices))), t && i.push(e.value))
                  : i.push(e.value);
              }),
              i
            );
          },
          i = {},
          r = (e) => {
            for (const t of e)
              if (
                t.type === a.TextCollectionFieldType.FieldSet ||
                t.type === a.TextCollectionFieldType.Form
              )
                r(t.fields);
              else if (t.type === a.TextCollectionFieldType.Category) {
                const e = t.choices;
                i[t.field_id] = n(e);
              } else
                t.type === a.TextCollectionFieldType.Select &&
                  (i[t.field_id] = t.choices || []);
          };
        return r(e), i;
      }
    },
    974819: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.validateInternalFields =
          t.formatJoiValidateError =
          t.annotationSchema =
          t.requestParamsSchemaDependent =
          t.requestParamsSchema =
          t.formSchema =
          t.formFieldSchema =
          t.fieldSetSchema =
          t.unitFieldAlternativesSchema =
          t.wfeButtonFieldSchema =
          t.JSONFieldSchema =
          t.queryableTextAndResultsFieldSchema =
          t.fileUploadTextFieldSchema =
          t.boundingBoxFieldSchema =
          t.categoryFieldSchema =
          t.autocompleteFieldSchema =
          t.selectFieldSchema =
          t.timeRangeFieldSchema =
          t.datetimeFieldSchema =
          t.numberFieldSchema =
          t.booleanFieldSchema =
          t.transcriptionTextFieldSchema =
          t.textFieldSchema =
          t.fieldSchemaBase =
          t.attachmentSchema =
            void 0);
      var i = l(n(39300)),
        r = n(963494),
        o = l(n(298784)),
        a = n(918397),
        s = n(561630);
      function l(e) {
        return e && e.__esModule ? e : { default: e };
      }
      const c = i.default.object().keys({
        type: i.default
          .string()
          .valid(...Object.values(r.TextCollectionAttachmentType))
          .required(),
        content: i.default
          .alternatives()
          .conditional("type", {
            not: r.TextCollectionAttachmentType.VideoComparison,
            then: i.default.string(),
            otherwise: i.default.string().allow("").optional(),
          }),
        column_count: i.default.number().optional(),
        forms: i.default.array().min(1).items(i.default.string()).optional(),
        caption: i.default.string().optional(),
        left: i.default.string().optional(),
        right: i.default.string().optional(),
        blocking: i.default.boolean().optional(),
        autoplay: i.default.boolean().optional(),
        max_num_plays: i.default.number().integer().min(1).optional(),
        videoA: i.default.string().optional(),
        videoB: i.default.string().optional(),
        randomizeOrder: i.default.boolean().optional(),
        attachment_body: i.default.any().optional(),
        width: i.default.number().optional(),
        height: i.default.number().optional(),
        darkMode: i.default.boolean().optional(),
        streamResponses: i.default.boolean().optional(),
        mockType: i.default.string().optional(),
      });
      t.attachmentSchema = c;
      const p = i.default
          .object()
          .keys({
            field_id: i.default.string().required(),
            title: i.default.string().required(),
            description: i.default.string().optional().allow(""),
          }),
        u = i.default.array().items(i.default.any()),
        d = i.default.alternatives().try(i.default.object({ not: u }), u),
        m = i.default.object().pattern(i.default.string(), d),
        h = p.keys({
          hint: i.default.string().optional(),
          instruction: i.default.any().strict().optional(),
          toggle_message: i.default.string().optional(),
          toggle_hint: i.default.string().optional(),
          required: i.default.boolean().optional(),
          min_responses_required: i.default
            .number()
            .integer()
            .min(0)
            .optional(),
          max_responses_required: i.default
            .number()
            .integer()
            .optional()
            .when("min_responses_required", {
              is: i.default.exist(),
              then: i.default
                .number()
                .min(i.default.ref("min_responses_required")),
            }),
          hide_for_single_response: i.default.boolean().optional(),
          extra_content: i.default.string().optional(),
          unit_test_pass_required: i.default.boolean().optional(),
          conditions: i.default.array().min(1).items(m).optional(),
          templateVariableConditions: i.default
            .array()
            .min(1)
            .items(m)
            .optional(),
          show_separator: i.default.boolean().optional(),
          showForReviewLevels: i.default
            .array()
            .items(i.default.number().integer())
            .optional(),
        });
      t.fieldSchemaBase = h;
      const f = h.keys({
        type: i.default.valid(r.TextCollectionFieldType.Text).required(),
        min_characters: i.default.number().integer().min(1).optional(),
        max_characters: i.default
          .number()
          .integer()
          .optional()
          .when("min_characters", {
            is: i.default.exist(),
            then: i.default.number().min(i.default.ref("min_characters")),
          }),
        min_tokens: i.default.number().integer().min(1).optional(),
        max_tokens: i.default
          .number()
          .integer()
          .optional()
          .when("min_tokens", {
            is: i.default.exist(),
            then: i.default.number().min(i.default.ref("min_tokens")),
          }),
        spellcheck: i.default.boolean().optional(),
        prefill: i.default
          .object({
            mapS3Artifact: i.default.string(),
            fieldKey: i.default.string(),
            addToDescription: i.default.boolean().optional(),
          })
          .optional(),
        default_text: i.default.string().allow("").optional(),
        show_word_counter: i.default.boolean().optional(),
        flexible_min_rows: i.default.boolean().optional(),
        use_grammar_check: i.default.boolean().optional(),
        dropdown: i.default.array().items(i.default.string()).optional(),
        disable_pasting: i.default.boolean().optional(),
        show_diff: i.default.boolean().optional(),
        original_text: i.default.string().optional(),
        show_latex_preview: i.default.boolean().optional(),
        show_markdown_preview: i.default.boolean().optional(),
        show_equation_builder: i.default.boolean().optional(),
        can_upload_file: i.default.boolean().optional(),
        save_to_task_feedback: i.default.boolean().optional(),
        disable_copying: i.default.boolean().optional(),
      });
      t.textFieldSchema = f;
      const g = h.keys({
        type: i.default
          .valid(r.TextCollectionFieldType.TranscriptionText)
          .required(),
        tags: i.default
          .object()
          .pattern(
            i.default.string(),
            i.default
              .object()
              .keys({
                options: i.default.array().items(i.default.string()),
                followUpCharacter: i.default.string().optional(),
              })
          )
          .required(),
        spellcheck: i.default.boolean().optional(),
      });
      t.transcriptionTextFieldSchema = g;
      const y = h.keys({
        type: i.default.valid(r.TextCollectionFieldType.Boolean).required(),
      });
      t.booleanFieldSchema = y;
      const b = h.keys({
        type: i.default.valid(r.TextCollectionFieldType.Number).required(),
        digits: i.default.number().integer().min(0).optional(),
        min: i.default.number().optional(),
        max: i.default
          .number()
          .optional()
          .when("min", {
            is: i.default.exist(),
            then: i.default.number().greater(i.default.ref("min")),
          }),
        step: i.default.number().optional(),
        prefix: i.default.string().allow("").optional(),
        mid_label: i.default.string().allow("").optional(),
        suffix: i.default.string().allow("").optional(),
        use_slider: i.default.boolean().optional(),
        use_candybar: i.default.boolean().optional(),
        allow_not_applicable: i.default.boolean().optional(),
        allow_cannot_assess: i.default.boolean().optional(),
        max_precision: i.default.number().integer().min(0).optional(),
        step_ticks_override: i.default.number().optional(),
        labels_list_override: i.default.string().optional(),
        precompute_field_params: i.default
          .object({
            weights: i.default
              .array()
              .items(
                i.default
                  .object()
                  .pattern(i.default.string(), i.default.number())
              ),
            precompute_formula: i.default
              .string()
              .valid(...o.default.values(r.PrecomputeFormulas)),
            thresholds: i.default.array().items(i.default.number()).optional(),
          })
          .optional(),
        rubric: i.default.string().optional(),
        save_to_task_feedback: i.default.boolean().optional(),
        default_value: i.default.string().optional(),
      });
      t.numberFieldSchema = b;
      const T = h.keys({
        type: i.default.valid(r.TextCollectionFieldType.Datetime).required(),
        include: i.default
          .array()
          .items(...Object.values(r.DatetimeSpec))
          .min(1)
          .max(Object.values(r.DatetimeSpec).length)
          .required(),
        defaults: i.default
          .object({
            year: i.default.number().optional(),
            month: i.default.number().optional(),
            day: i.default.number().optional(),
            hour: i.default.number().optional(),
            minute: i.default.number().optional(),
          })
          .optional(),
      });
      t.datetimeFieldSchema = T;
      const _ = h.keys({
        type: i.default.valid(r.TextCollectionFieldType.TimeRange).required(),
        increment_seconds: i.default.number().min(1).max(3600).optional(),
        defaults_seconds: i.default
          .array()
          .items(i.default.number().min(0).max(86400))
          .length(2)
          .optional(),
        default_from_field: i.default.string().optional(),
      });
      t.timeRangeFieldSchema = _;
      const S = h.keys({
        type: i.default.valid(r.TextCollectionFieldType.Select).required(),
        choices_from_field: i.default.string().optional(),
        choices: i.default.array().items(i.default.string()).optional(),
        columns: i.default.number().integer().min(1).optional(),
      });
      t.selectFieldSchema = S;
      const v = h.keys({
        type: i.default
          .valid(r.TextCollectionFieldType.Autocomplete)
          .required(),
        options: i.default.array().items(i.default.string()).required(),
        min_responses_required: i.default.number().integer().min(0).optional(),
        max_responses_required: i.default
          .number()
          .integer()
          .optional()
          .when("min_responses_required", {
            is: i.default.exist(),
            then: i.default
              .number()
              .min(i.default.ref("min_responses_required")),
          }),
        hideMaxResponsesLabel: i.default.boolean().optional(),
        allow_custom_options: i.default.boolean().optional(),
        longHintsS3Artifact: i.default.string().optional(),
      });
      t.autocompleteFieldSchema = v;
      const C = i.default
          .object()
          .keys({
            value: i.default
              .alternatives(
                i.default.string(),
                i.default.number(),
                i.default.boolean()
              )
              .required(),
            label: i.default.string().required(),
            hint: i.default.string().optional(),
            subLabel: i.default.string().optional(),
            customerValue: i.default.string().optional(),
            instruction: i.default.string().optional(),
            preferred: i.default.boolean().optional(),
            subchoices: i.default
              .array()
              .min(1)
              .items(i.default.link("#categoryChoice"))
              .optional(),
            pinned: i.default.boolean().optional(),
            conditions: i.default.array().min(1).items(m).optional(),
            link: i.default.string().optional(),
          })
          .id("categoryChoice"),
        I = h.keys({
          type: i.default.valid(r.TextCollectionFieldType.Category).required(),
          choices: i.default
            .array()
            .min(0)
            .items(C)
            .required()
            .unique((e, t) => {
              const n = new Set();
              for (const [i] of a.depthFirstChoices([e, t])) {
                if (n.has(i.value)) return !0;
                n.add(i.value);
              }
              return !1;
            }),
          min_choices: i.default.number().integer().min(1).optional(),
          max_choices: i.default
            .number()
            .integer()
            .optional()
            .when("min_choices", {
              is: i.default.exist(),
              then: i.default.number().min(i.default.ref("min_choices")),
            }),
          use_category_choose_multiple: i.default.boolean().optional(),
          can_select_intermediate_nodes: i.default.boolean().optional(),
          groupSamePathLabelCategories: i.default.boolean().optional(),
          longHintsS3Artifact: i.default.string().optional(),
          choicesS3Artifact: i.default.string().optional(),
          initialChoiceFilter: i.default
            .array()
            .items(i.default.string())
            .optional(),
          showSearchBar: i.default.boolean().optional(),
          showParentLonghint: i.default.boolean().optional(),
          tokenizeSearch: i.default.boolean().optional(),
          hideMinMaxLabel: i.default.boolean().optional(),
          useOntologyHints: i.default.boolean().optional(),
          rubric: i.default.string().optional(),
          save_to_task_feedback: i.default.boolean().optional(),
        });
      t.categoryFieldSchema = I;
      const R = h.keys({
        type: i.default.valid(r.TextCollectionFieldType.BoundingBox).required(),
      });
      t.boundingBoxFieldSchema = R;
      const x = h.keys({
        type: i.default.valid(r.TextCollectionFieldType.FileUpload).required(),
        allowed_mime_types: i.default
          .array()
          .items(i.default.string())
          .optional(),
      });
      t.fileUploadTextFieldSchema = x;
      const L = h.keys({
        type: i.default
          .valid(r.TextCollectionFieldType.QueryableTextAndResults)
          .required(),
        use_autocomplete_button: i.default.boolean().optional(),
        autopopulate_from_model_response: i.default.boolean().optional(),
        query_type: i.default.string().optional(),
      });
      t.queryableTextAndResultsFieldSchema = L;
      const w = h.keys({
        type: i.default.valid(r.TextCollectionFieldType.JSON).required(),
      });
      t.JSONFieldSchema = w;
      const P = h.keys({
        type: i.default.valid(r.TextCollectionFieldType.WfeButton).required(),
        buttonLabel: i.default.string().required(),
        buttonUrl: i.default.string().optional(),
        isDolphin: i.default.boolean().optional(),
      });
      t.wfeButtonFieldSchema = P;
      const E = h.keys({
          type: i.default
            .valid(r.TextCollectionFieldType.AudioRecording)
            .required(),
          format: i.default
            .string()
            .valid(...s.SUPPORTED_AUDIO_FORMATS)
            .required(),
          minAudioDuration: i.default.number().min(0).optional(),
          maxAudioDuration: i.default.number().min(1).optional(),
          maxVolume: i.default.number().min(-70).max(0).optional(),
          minAverageVolume: i.default.number().min(-70).max(0).optional(),
          maxAverageVolume: i.default.number().min(-70).max(0).optional(),
          maxAmbientNoiseVolume: i.default.number().min(-70).max(0).optional(),
          minBackgroundNoiseScore: i.default.number().optional(),
          minOverallSpeechScore: i.default.number().optional(),
        }),
        A = i.default
          .when(
            i.default
              .object({ type: r.TextCollectionFieldType.Text })
              .unknown(),
            { then: f }
          )
          .when(
            i.default
              .object({ type: r.TextCollectionFieldType.Number })
              .unknown(),
            { then: b }
          )
          .when(
            i.default
              .object({ type: r.TextCollectionFieldType.Boolean })
              .unknown(),
            { then: y }
          )
          .when(
            i.default
              .object({ type: r.TextCollectionFieldType.Datetime })
              .unknown(),
            { then: T }
          )
          .when(
            i.default
              .object({ type: r.TextCollectionFieldType.Category })
              .unknown(),
            { then: I }
          )
          .when(
            i.default
              .object({ type: r.TextCollectionFieldType.Select })
              .unknown(),
            { then: S }
          )
          .when(
            i.default
              .object({ type: r.TextCollectionFieldType.Autocomplete })
              .unknown(),
            { then: v }
          )
          .when(
            i.default
              .object({
                type: r.TextCollectionFieldType.QueryableTextAndResults,
              })
              .unknown(),
            { then: L }
          )
          .when(
            i.default
              .object({ type: r.TextCollectionFieldType.JSON })
              .unknown(),
            { then: w }
          )
          .when(
            i.default
              .object({ type: r.TextCollectionFieldType.BoundingBox })
              .unknown(),
            { then: R }
          )
          .when(
            i.default
              .object({ type: r.TextCollectionFieldType.TimeRange })
              .unknown(),
            { then: _ }
          )
          .when(
            i.default
              .object({ type: r.TextCollectionFieldType.TranscriptionText })
              .unknown(),
            { then: g }
          )
          .when(
            i.default
              .object({ type: r.TextCollectionFieldType.FileUpload })
              .unknown(),
            { then: x }
          )
          .when(
            i.default
              .object({ type: r.TextCollectionFieldType.WfeButton })
              .unknown(),
            { then: P }
          )
          .when(
            i.default
              .object({ type: r.TextCollectionFieldType.AudioRecording })
              .unknown(),
            { then: E }
          );
      t.unitFieldAlternativesSchema = A;
      const k = h
        .keys({
          type: i.default.valid(r.TextCollectionFieldType.FieldSet).required(),
          fields: i.default
            .array()
            .min(1)
            .items(A, i.default.link("#fieldSet"))
            .required(),
          inline: i.default.boolean().optional(),
        })
        .id("fieldSet");
      t.fieldSetSchema = k;
      const O = h.keys({
          type: i.default.valid(r.TextCollectionFieldType.FieldSet).required(),
          fields: i.default.array().min(1).items(A).required(),
          inline: i.default.valid(!0),
        }),
        M = p.keys({
          type: i.default.valid(r.TextCollectionFieldType.Form).required(),
          random_order: i.default.boolean().optional(),
          fields: i.default
            .array()
            .min(1)
            .items(
              A.when(
                i.default
                  .object({ type: r.TextCollectionFieldType.FieldSet })
                  .unknown(),
                { then: k }
              )
            )
            .required(),
        });
      t.formFieldSchema = M;
      const N = i.default.object().keys({
        form_id: i.default.string(),
        title: i.default.string(),
        action: i.default
          .string()
          .valid(...o.default.values(r.TextCollectionFormAction)),
        conditions: i.default.array().min(1).items(m).optional(),
        fields: i.default
          .array()
          .min(1)
          .items(
            A.when(
              i.default
                .object({ type: r.TextCollectionFieldType.FieldSet })
                .unknown(),
              { then: O }
            )
          )
          .required(),
      });
      t.formSchema = N;
      const z = i.default
        .object()
        .keys({
          attachments: i.default.array().min(1).items(c).required(),
          fields: i.default
            .array()
            .min(1)
            .items(
              A.when(
                i.default
                  .object({ type: r.TextCollectionFieldType.FieldSet })
                  .unknown(),
                { then: k }
              ).when(
                i.default
                  .object({ type: r.TextCollectionFieldType.Form })
                  .unknown(),
                { then: M }
              )
            )
            .required()
            .messages({
              "any.required":
                "The following input field is missing: {{#label}}, you can check your input in JSON tab in Edit section to locate your missing field.",
            }),
          forms: i.default.array().items(N).optional(),
          suggestionSources: i.default
            .array()
            .items(
              i.default
                .string()
                .valid(...o.default.values(r.TextCollectionSuggestionSource))
            )
            .optional(),
          title: i.default.string().optional(),
          hypothesis: i.default.object().unknown(!0).optional(),
          hypothesisConfidence: i.default.number().optional(),
          hideHypothesis: i.default.boolean().optional(),
          read_only_field_ids: i.default
            .array()
            .items(i.default.string())
            .optional(),
          blurred_field_ids: i.default
            .array()
            .items(i.default.string())
            .optional(),
          description: i.default.string().optional(),
          responses_required: i.default.number().integer().min(1).optional(),
          headset_required: i.default.boolean().optional(),
          process_attachments: i.default.boolean().optional(),
          templateVariables: i.default.object().unknown(!0).optional(),
          force_stacked: i.default.boolean().optional(),
          generation_task_extra_params: i.default
            .object()
            .unknown(!0)
            .optional(),
        })
        .unknown(!0);
      t.requestParamsSchema = z;
      const j = i.default
        .object()
        .keys({
          fields: i.default
            .array()
            .min(1)
            .items(
              A.when(
                i.default
                  .object({ type: r.TextCollectionFieldType.FieldSet })
                  .unknown(),
                { then: k }
              ).when(
                i.default
                  .object({ type: r.TextCollectionFieldType.Form })
                  .unknown(),
                { then: M }
              )
            )
            .required()
            .messages({
              "any.required":
                "The following input field is missing: {{#label}}, you can check your input in JSON tab in Edit section to locate your missing field.",
            }),
          forms: i.default.array().items(N).optional(),
          suggestionSources: i.default
            .array()
            .items(
              i.default
                .string()
                .valid(...o.default.values(r.TextCollectionSuggestionSource))
            )
            .optional(),
          title: i.default.string().optional(),
          hypothesis: i.default.object().unknown(!0).optional(),
          hypothesisConfidence: i.default.number().optional(),
          hideHypothesis: i.default.boolean().optional(),
          read_only_field_ids: i.default
            .array()
            .items(i.default.string())
            .optional(),
          blurred_field_ids: i.default
            .array()
            .items(i.default.string())
            .optional(),
          description: i.default.string().optional(),
          responses_required: i.default.number().integer().min(1).optional(),
          headset_required: i.default.boolean().optional(),
          process_attachments: i.default.boolean().optional(),
          templateVariables: i.default.object().unknown(!0).optional(),
          force_stacked: i.default.boolean().optional(),
          generation_task_extra_params: i.default
            .object()
            .unknown(!0)
            .optional(),
        })
        .unknown(!0);
      t.requestParamsSchemaDependent = j;
      const D = i.default
        .object()
        .keys({
          field_id: i.default.string().required(),
          type: i.default
            .string()
            .valid(...Object.values(r.TextCollectionFieldType))
            .required(),
          response: i.default.array().items(i.default.any()).required(),
        })
        .unknown(!0);
      t.annotationSchema = D;
      t.formatJoiValidateError = (e) => {
        const t = e.details[0],
          n = t.path.join(".");
        return `The taxonomy or instruction parameters are not set up correctly. Error Message: ${t.message} Path: ${n}`;
      };
      const F = i.default
        .array()
        .items(
          A.when(
            i.default
              .object({ type: r.TextCollectionFieldType.FieldSet })
              .unknown(),
            { then: k }
          ).when(
            i.default
              .object({ type: r.TextCollectionFieldType.Form })
              .unknown(),
            { then: M }
          )
        );
      t.validateInternalFields = async (e) => {
        if (!o.default.isArray(e))
          throw new Error(
            "Failed internal field validation, fields is not an array"
          );
        const { error: t } = F.validate(e);
        if (t)
          throw new Error(
            `Failed internal field validation: ${JSON.stringify(t)}`
          );
        return !0;
      };
    },
    899047: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        Object.defineProperty(t, "OpenAIModels", {
          enumerable: !0,
          get: function () {
            return c.OpenAIModels;
          },
        }),
        (t.masterEndpointMap =
          t.doesUrlSupportAttachments =
          t.doesStrategySupportAttachments =
          t.getStrategyFromUrl =
          t.StrategiesThatSupportAttachments =
          t.EndpointHostToStrategyMap =
          t.GCPTextBisonEnpoint =
          t.GCPTextBisonProjectId =
          t.StrategyParamsSchemaMap =
          t.LiteLLMStrategyParamsSchema =
          t.GeminiProviderParamsSchema =
          t.LLMEngineProviderParamsSchema =
          t.MistralProviderParamsSchema =
          t.BedrockProviderParamsSchema =
          t.CohereProviderParamsSchema =
          t.AnthropicProviderParamsSchema =
          t.OpenAIProviderParamsSchema =
          t.LiteLLMCommonParamsSchema =
          t.OpenAIStrategyParamsSchema =
          t.OpenAIProviderCustomParamsSchema =
          t.LiteLLMProvider =
          t.MonadMultimodalStrategyParamsSchema =
          t.GoldfishStrategyParamsSchema =
          t.GoldfishStrategyUseCase =
          t.MeerkatSafetyStrategyParamsSchema =
          t.NemotronStrategyParamsSchema =
          t.AlpacaStrategyParamsSchema =
          t.AnthropicStrategyParamsSchema =
          t.AnthropicStrategyCustomParamsSchema =
          t.YiStrategyParamsSchema =
          t.VertexGeminiStrategyParamsSchema =
          t.GeminiStrategyParamsSchema =
          t.GeminiModels =
          t.VertexRegions =
          t.GCPProjects =
          t.SDAIAStrategyParamsSchema =
          t.BulbaIceStrategyV2ParamsSchema =
          t.BulbaIceStrategyParamsSchema =
          t.BulbaLiveRewriteStrategyParamsSchema =
          t.BulbaBardEndpointOperation =
          t.DonovanStrategyParamsSchema =
          t.BeeOrchestratorStrategyParamsSchema =
          t.BeeStrategyParamsSchema =
          t.ImpalaStrategyParamsSchema =
          t.BeaverStrategyParamsSchema =
          t.TextBisonStrategyParamsSchema =
          t.BulbaBridgeStrategyParamsSchema =
          t.GorillaRewriteStrategyParamsSchema =
          t.HuggingFaceStrategyParamsSchema =
          t.CohereStrategyParamsSchema =
          t.EGPCompletionsStrategyParamsSchema =
          t.EGPChatCompletionsStrategyParamsSchema =
          t.FlamingoAudioStrategyParamsSchema =
          t.FlamingoMMStrategyParamsSchema =
          t.FlamingoGraphStrategyParamsSchema =
          t.FlamingoStrategyParamsSchema =
          t.OpenAIAssistantsStrategyParamsSchema =
          t.OpenAIResponseFormatSchema =
          t.MirrorStrategyParamsSchema =
          t.SealStrategyParamsSchema =
          t.AiredaleChatStrategyParamsSchema =
          t.ToolUseProcessSupervisionStrategyParamsSchema =
          t.AirdaleStrategyParamsSchema =
          t.StrategyName =
          t.CandidateState =
          t.ImageDetail =
            void 0);
      var i,
        r,
        o,
        a = n(689510),
        s = n(450973),
        l = n(246311),
        c = n(527096);
      (t.ImageDetail = i),
        (function (e) {
          (e.Auto = "auto"), (e.Low = "low"), (e.High = "high");
        })(i || (t.ImageDetail = i = {})),
        (t.CandidateState = r),
        (function (e) {
          (e.Completed = "completed"),
            (e.Loading = "loading"),
            (e.Error = "error");
        })(r || (t.CandidateState = r = {})),
        (t.StrategyName = o),
        (function (e) {
          (e.MirrorStrategy = "MirrorStrategy"),
            (e.OpenAIStrategy = "OpenAIStrategy"),
            (e.EGPChatCompletionsStrategy = "EGPChatCompletionsStrategy"),
            (e.EGPV2ChatCompletionsStrategy = "EGPV2ChatCompletionsStrategy"),
            (e.LiteLLMStrategy = "LiteLLMStrategy"),
            (e.FlamingoStrategy = "FlamingoStrategy"),
            (e.FlamingoGraphStrategy = "FlamingoGraphStrategy"),
            (e.FlamingoMMStrategy = "FlamingoMMStrategy"),
            (e.FlamingoAudioStrategy = "FlamingoAudioStrategy"),
            (e.EGPCompletionsStrategy = "EGPCompletionsStrategy"),
            (e.EGPV2CompletionsStrategy = "EGPV2CompletionsStrategy"),
            (e.CohereStrategy = "CohereStrategy"),
            (e.HuggingFaceStrategy = "HuggingFaceStrategy"),
            (e.HuggingFaceStrategyV2 = "HuggingFaceStrategyV2"),
            (e.GorillaRewriteStrategy = "GorillaRewriteStrategy"),
            (e.BulbaBridgeStrategy = "BulbaBridgeStrategy"),
            (e.BulbaLiveRewriteStrategy = "BulbaLiveRewriteStrategy"),
            (e.BulbaIceStrategy = "BulbaIceStrategy"),
            (e.BulbaIceStrategyV2 = "BulbaIceStrategyV2"),
            (e.TextBisonStrategy = "TextBisonStrategy"),
            (e.BeaverStrategy = "BeaverStrategy"),
            (e.ImpalaStrategy = "ImpalaStrategy"),
            (e.BeeStrategy = "BeeStrategy"),
            (e.BeeOrchestratorStrategy = "BeeOrchestratorStrategy"),
            (e.DonovanStrategy = "DonovanStrategy"),
            (e.SealStrategy = "SealStrategy"),
            (e.AirdaleStrategy = "AirdaleStrategy"),
            (e.AiredaleChatStrategy = "AiredaleChatStrategy"),
            (e.SealStrategyV2 = "SealStrategyV2"),
            (e.GeminiStrategy = "GeminiStrategy"),
            (e.VertexGeminiStrategy = "VertexGeminiStrategy"),
            (e.ToolUseProcessSupervisionStrategy =
              "ToolUseProcessSupervisionStrategy"),
            (e.YiStrategy = "YiStrategy"),
            (e.AnthropicStrategy = "AnthropicStrategy"),
            (e.SealStrategyV3 = "SealStrategyV3"),
            (e.OpenAIAssistantsStrategy = "OpenAIAssistantsStrategy"),
            (e.SealStrategyV4 = "SealStrategyV4"),
            (e.AlpacaStrategy = "AlpacaStrategy"),
            (e.SDAIAStrategy = "SDAIAStrategy"),
            (e.NemotronStrategy = "NemotronStrategy"),
            (e.MeerkatSafetyStrategy = "MeerkatSafetyStrategy"),
            (e.GoldfishStrategy = "GoldfishStrategy"),
            (e.MonadMultimodalStrategy = "MonadMultimodalStrategy");
        })(o || (t.StrategyName = o = {}));
      const p = {
          workerId: a.z.string().optional(),
          useWorkerLocation: a.z.boolean().optional(),
        },
        u = a.z.object({
          numResults: a.z.number().int().optional(),
          maxTokens: a.z.number().int().optional(),
          temperature: a.z.number().optional(),
          topKReturn: a.z.number().int().optional(),
          topP: a.z.number().optional(),
          countPenalty: a.z
            .object({
              scale: a.z.number().optional(),
              applyToNumbers: a.z.boolean().optional(),
              applyToPunctuations: a.z.boolean().optional(),
              applyToStopwords: a.z.boolean().optional(),
              applyToWhitespaces: a.z.boolean().optional(),
              applyToEmojis: a.z.boolean().optional(),
            })
            .optional(),
          frequencyPenalty: a.z
            .object({
              scale: a.z.number().optional(),
              applyToNumbers: a.z.boolean().optional(),
              applyToPunctuations: a.z.boolean().optional(),
              applyToStopwords: a.z.boolean().optional(),
              applyToWhitespaces: a.z.boolean().optional(),
              applyToEmojis: a.z.boolean().optional(),
            })
            .optional(),
          presencePenalty: a.z
            .object({
              scale: a.z.number().optional(),
              applyToNumbers: a.z.boolean().optional(),
              applyToPunctuations: a.z.boolean().optional(),
              applyToStopwords: a.z.boolean().optional(),
              applyToWhitespaces: a.z.boolean().optional(),
              applyToEmojis: a.z.boolean().optional(),
            })
            .optional(),
          stopSequences: a.z.array(a.z.string()).optional(),
        });
      t.AirdaleStrategyParamsSchema = u;
      const d = a.z.object({
        endpointName: a.z.string().optional(),
        vllm_sampling_params: a.z.any().optional(),
        max_depth: a.z.number().optional(),
        num_retries: a.z.number().optional(),
        num_steps_to_generate: a.z.number().optional(),
        generate_action_plan_only: a.z.boolean().optional(),
        tools: a.z.array(a.z.string()).optional(),
      });
      t.ToolUseProcessSupervisionStrategyParamsSchema = d;
      const m = a.z.object({
        temperature: a.z.number().optional(),
        systemPrompt: a.z.string().optional(),
        maxTokens: a.z.number().int().optional(),
      });
      t.AiredaleChatStrategyParamsSchema = m;
      const h = a.z.object({
        url_override: a.z.string().optional(),
        max_new_tokens: a.z.number().int().max(8192).optional(),
        temperature: a.z.number().optional(),
        do_sample: a.z.boolean().optional(),
        num_beams: a.z.number().optional(),
        no_repeat_ngram_size: a.z.number().optional(),
        repeat_penalty: a.z.number().optional(),
      });
      t.SealStrategyParamsSchema = h;
      const f = a.z.object({
        prefix: a.z.string().optional(),
        stream: a.z.boolean().optional(),
        interval_time: a.z.number().optional(),
        total_time: a.z.number().optional(),
        test_random_error_rate: a.z
          .number()
          .refine((e) => void 0 === e || (e >= 0 && e <= 1))
          .optional(),
      });
      t.MirrorStrategyParamsSchema = f;
      const g = a.z.object({
        type: a.z.enum(["json_object", "json_schema", "text"]).optional(),
        json_schema: a.z.object({}).passthrough().optional(),
      });
      t.OpenAIResponseFormatSchema = g;
      const y = a.z.object({
        model: a.z
          .enum([
            "gpt-3.5-turbo",
            "gpt-4",
            "gpt-4-turbo",
            "gpt-4-1106-preview",
            "gpt-4-vision-preview",
            "gpt-4-turbo-preview",
            "gpt-4o",
          ])
          .optional(),
        name: a.z.string().optional(),
        description: a.z.string().optional(),
        instructions: a.z.string().optional(),
        tools: a.z.array(a.z.any()).optional(),
      });
      t.OpenAIAssistantsStrategyParamsSchema = y;
      const b = a.z.object({
        stream: a.z.boolean().optional(),
        model: a.z.string().optional(),
        max_tokens: a.z.number().int().optional(),
        temperature: a.z.number().optional(),
        repetition_penalty: a.z.number().optional(),
        top_p: a.z.number().optional(),
        separatorToken: a.z.string().optional(),
        requestTimeoutMs: a.z.number().optional(),
        returnFullSequence: a.z.boolean().optional(),
        returnDeserialized: a.z.boolean().optional(),
        systemPrompt: a.z.string().optional(),
        sampleModelParams: a.z.any().optional(),
      });
      t.FlamingoStrategyParamsSchema = b;
      const T = a.z.object({
        model: a.z.string(),
        stream: a.z.boolean().default(!1),
        uploadToS3: a.z.boolean().default(!0),
        temperature: a.z.number(),
        maxMessages: a.z.number().default(20),
        v2: a.z.boolean().optional(),
        sampleModelParams: a.z.any().optional(),
        systemPrompt: a.z.string().optional(),
        assignmentId: a.z.string().optional(),
        projectId: a.z.string().optional(),
        usedFallbackParams: a.z.boolean().optional(),
        topP: a.z.number().optional(),
        repetitionPenalty: a.z.number().optional(),
        dialogId: a.z.string().optional(),
        userPromptTemplate: a.z.string().optional(),
        workstream: a.z.string().optional(),
      });
      t.FlamingoGraphStrategyParamsSchema = T;
      const _ = a.z.object({
        model: a.z.string(),
        maxTokens: a.z.number().int().default(2048),
        maxGenLength: a.z.number().int(),
        generationAlgorithm: a.z.string().default("top_p"),
        temperature: a.z.number(),
        assignmentId: a.z.string().optional(),
        projectId: a.z.string().optional(),
        sampleModelParams: a.z.any().optional(),
        topP: a.z.number().optional(),
        repetitionPenalty: a.z.number().optional(),
      });
      t.FlamingoMMStrategyParamsSchema = _;
      const S = a.z.object({
        model: a.z.string(),
        stream: a.z.boolean().default(!1),
        uploadToS3: a.z.boolean().default(!0),
        processTranscripts: a.z.boolean().default(!0),
        sampleModelParams: a.z.any().optional(),
        temperature: a.z.number().optional(),
        assignmentId: a.z.string().optional(),
        projectId: a.z.string().optional(),
        topP: a.z.number().optional(),
      });
      t.FlamingoAudioStrategyParamsSchema = S;
      const v = a.z.object({
        model: a.z.string(),
        instructions: a.z.string().optional(),
        temperature: a.z.number().optional(),
        max_tokens: a.z.number().optional(),
        stop_sequences: a.z.array(a.z.string()).optional(),
        stream: a.z.boolean().optional(),
      });
      t.EGPChatCompletionsStrategyParamsSchema = v;
      const C = a.z.object({
        model: a.z.string(),
        database_schema: a.z.string().optional(),
        table_id: a.z.string().optional(),
        temperature: a.z.number().optional(),
        max_tokens: a.z.number().optional(),
        stop_sequences: a.z.array(a.z.string()).optional(),
        stream: a.z.boolean().optional(),
      });
      t.EGPCompletionsStrategyParamsSchema = C;
      const I = a.z.object({
        stream: a.z.boolean().optional(),
        model: a.z.string().optional(),
        temperature: a.z.number().gte(0).lte(5).optional(),
        k: a.z.number().int().gte(0).lte(500).optional(),
        p: a.z.number().gte(0).lte(1).optional(),
        max_tokens: a.z.number().int().optional(),
        preamble_override: a.z.string().optional(),
        projectId: a.z.string().optional(),
        assignmentId: a.z.string().optional(),
        prompt_truncation: a.z.enum(["AUTO", "OFF"]).optional(),
      });
      t.CohereStrategyParamsSchema = I;
      const R = a.z.object({
        temperature: a.z.number().optional(),
        max_new_tokens: a.z.number().int().optional(),
        top_p: a.z.number().optional(),
        repetition_penalty: a.z.number().optional(),
        do_sample: a.z.boolean().optional(),
        seed: a.z.number().int().optional(),
        truncate: a.z.number().int().optional(),
        stop: a.z.array(a.z.string()).optional(),
        stream: a.z.boolean().optional(),
      });
      t.HuggingFaceStrategyParamsSchema = R;
      const x = a.z.object({
        url_override: a.z.string().optional(),
        model: a.z.string(),
        temperature: a.z.number().optional(),
        candidateCount: a.z.number().optional(),
        topP: a.z.number().optional(),
        topK: a.z.number().optional(),
      });
      t.GorillaRewriteStrategyParamsSchema = x;
      const L = a.z.object({
        model: a.z.string(),
        temperature: a.z.number().optional(),
        candidateCount: a.z.number().optional(),
        topP: a.z.number().optional(),
        topK: a.z.number().optional(),
        useChatHistoryInPrompt: a.z.boolean().optional(),
        prependPrompt: a.z.string().optional(),
        bardConfig: a.z
          .object({
            overwriteSystemInstruction: a.z.string().optional(),
            overwriteDeveloperInstruction: a.z.string().optional(),
            returnFactualityMetadata: a.z.boolean().optional(),
            searchOnlyConfig: a.z.object({}).optional(),
          })
          .optional(),
        ...p,
      });
      t.BulbaBridgeStrategyParamsSchema = L;
      const w = a.z.object({
        model: a.z.string().optional(),
        temperature: a.z.number().gte(0).lte(1).optional(),
        maxOutputTokens: a.z.number().int().gte(1).lte(1024).optional(),
        topK: a.z.number().int().gte(1).lte(40).optional(),
        topP: a.z.number().gte(0).lte(1).optional(),
      });
      t.TextBisonStrategyParamsSchema = w;
      const P = a.z.object({ model: a.z.string() });
      t.BeaverStrategyParamsSchema = P;
      const E = a.z.object({
        config: a.z.string().optional(),
        timeout_sec: a.z.number().int().optional(),
      });
      t.ImpalaStrategyParamsSchema = E;
      const A = a.z.object({
        model: a.z.string(),
        options: a.z
          .object({
            frequency_penalty: a.z.number().optional(),
            max_tokens: a.z.number().optional(),
            n: a.z.number().optional(),
            temperature: a.z.number().optional(),
            variable_temperature: a.z
              .string()
              .optional()
              .describe("{{my_template_variable}}"),
            top_p: a.z.number().optional(),
            tools: a.z.string().optional(),
            useRandomSeed: a.z
              .boolean()
              .optional()
              .describe(
                "If enabled, uses a random seed each request to generate random samples"
              ),
          })
          .optional(),
      });
      t.BeeStrategyParamsSchema = A;
      const k = a.z.object({
        model: a.z.string().optional(),
        orchestrator: a.z
          .string()
          .optional()
          .describe("deprecated, use model instead"),
        options: a.z
          .object({
            frequency_penalty: a.z.number().optional(),
            max_tokens: a.z.number().optional(),
            n: a.z.number().optional(),
            temperature: a.z.number().optional(),
            variable_temperature: a.z
              .string()
              .optional()
              .describe("{{my_template_variable}}"),
            top_p: a.z.number().optional(),
            tools: a.z.string().optional(),
            useRandomSeed: a.z
              .boolean()
              .optional()
              .describe(
                "If enabled, uses a random seed each request to generate random samples"
              ),
          })
          .optional(),
      });
      t.BeeOrchestratorStrategyParamsSchema = k;
      const O = a.z.object({
        model: a.z.string().optional(),
        workspace: a.z.string().optional(),
        taskCustomer: a.z.string().optional(),
        thread: a.z.string().optional(),
        datasets: a.z.array(a.z.string()).optional(),
      });
      var M;
      (t.DonovanStrategyParamsSchema = O),
        (t.BulbaBardEndpointOperation = M),
        (function (e) {
          (e.BARD = "bard"),
            (e.BARD_ICE = "bard-ice"),
            (e.BARD_NO_SEARCH = "bard-no-search"),
            (e.BARD_SEARCH_OVERRIDE = "bard-search-override"),
            (e.SEARCH = "search"),
            (e.TOOL_PROMPT_GENERATION = "tool-prompt-generation"),
            (e.TOOL_CODE_EXECUTION = "tool-code-execution");
        })(M || (t.BulbaBardEndpointOperation = M = {}));
      const N = a.z.object({
        url_override: a.z.string().optional(),
        model: a.z.string().optional(),
        operation: a.z
          .enum(["bard", "bard-no-search", "bard-search-override", "search"])
          .optional(),
        search_results: a.z.array(a.z.any()).optional(),
      });
      t.BulbaLiveRewriteStrategyParamsSchema = N;
      const z = a.z.object({
        url_override: a.z.string().optional(),
        model: a.z.string().optional(),
        file_attachments: a.z.array(a.z.any()).optional(),
        use_history: a.z.boolean().optional(),
        enable_advanced_ice_flow: a.z.boolean().optional(),
        multiturn: a.z.boolean().optional(),
        tool_prompt_generation: a.z.boolean().optional(),
        use_tasker_response: a.z.boolean().optional(),
        previousTextCollection: a.z.any().optional(),
        sftFlag: a.z.boolean().optional(),
      });
      t.BulbaIceStrategyParamsSchema = z;
      const j = a.z.object({
        url_override: a.z.string().optional(),
        model: a.z.string().optional(),
        file_attachments: a.z.array(a.z.any()).optional(),
        enable_advanced_ice_flow: a.z.boolean().optional(),
        multiturn: a.z.boolean().optional(),
      });
      t.BulbaIceStrategyV2ParamsSchema = j;
      const D = a.z.object({
        temperature: a.z.number().optional(),
        stream: a.z.boolean().optional(),
        model: a.z.string().optional(),
        top_p: a.z.number().optional(),
        n: a.z.number().optional(),
        add_generation_prompt: a.z.boolean().optional(),
        echo: a.z.boolean().optional(),
        stop: a.z.any().optional(),
      });
      var F, U;
      (t.SDAIAStrategyParamsSchema = D),
        (t.GCPProjects = F),
        (function (e) {
          (e.VERTEX = "vertex"), (e.VERTEX_BACKUP = "vertex_backup");
        })(F || (t.GCPProjects = F = {})),
        (t.VertexRegions = U),
        (function (e) {
          (e.US_WEST4 = "us-west4"), (e.US_CENTRAL1 = "us-central1");
        })(U || (t.VertexRegions = U = {}));
      const $ = a.z.object({
          category: a.z.nativeEnum(s.HarmCategory),
          threshold: a.z.nativeEnum(s.HarmBlockThreshold),
        }),
        V = a.z.enum([
          "gemini-2.0-flash-exp",
          "gemini-1.5-pro-002",
          "gemini-1.5-pro-latest",
          "gemini-1.5-pro-exp-0801",
          "gemini-1.5-pro-exp-0827",
          "gemini-1.5-flash-002",
          "gemini-1.5-flash-latest",
          "gemini-1.0-pro-latest",
          "gemini-1.0-pro-vision-latest",
          "gemini-pro",
          "gemini-pro-vision",
          "gemini-exp-1121",
          "embedding-001",
          "text-embedding-004",
          "aqa",
        ]);
      t.GeminiModels = V;
      const q = a.z.object({
        model: V,
        maxOutputTokens: a.z.number().optional(),
        temperature: a.z.number().optional(),
        topP: a.z.number().optional(),
        topK: a.z.number().optional(),
        safetySettings: a.z.array($).optional(),
        gcpProject: a.z
          .nativeEnum(F)
          .optional()
          .describe(
            "When left blank, it rotates between defined projects and API keys. Only select a project if you are instructed to do so."
          ),
        systemInstruction: a.z.string().optional(),
        n: a.z.number().optional(),
        overrideApiKey: a.z.string().optional(),
      });
      t.GeminiStrategyParamsSchema = q;
      const B = a.z.object({
        model: a.z.enum([
          "gemini-1.5-pro-002",
          "gemini-1.5-pro",
          "gemini-1.5-pro-latest",
          "gemini-1.5-pro-001",
          "gemini-1.5-pro-preview-0514",
          "gemini-1.5-flash-002",
          "gemini-1.5-flash-preview-0514",
          "gemini-1.0-pro-001",
          "gemini-1.0-pro-002",
          "gemini-1.0-pro-vision-001",
          "gemini-1.0-pro-vision",
          "gemini-1.0-pro",
        ]),
        maxOutputTokens: a.z.number().optional(),
        temperature: a.z.number().optional(),
        topP: a.z.number().optional(),
        topK: a.z.number().optional(),
        tools: a.z.any().optional(),
        safetySettings: a.z.array($).optional(),
        region: a.z
          .nativeEnum(U)
          .optional()
          .describe(
            "The region to be used when calling VertexStrategy. When left blank, it uses us-west4 as the default region."
          ),
      });
      t.VertexGeminiStrategyParamsSchema = B;
      const G = a.z.object({
        model: a.z.string().optional(),
        prompt_template: a.z.string().optional(),
        top_k: a.z.number().optional(),
        top_p: a.z.number().optional(),
        temperature: a.z.number().optional(),
        max_new_tokens: a.z.number().optional(),
        repetition_penalty: a.z.number().optional(),
      });
      t.YiStrategyParamsSchema = G;
      const W = a.z.object({
        n: a.z
          .number()
          .int()
          .optional()
          .describe("Number of completions to generate."),
        overrideApiKey: a.z
          .string()
          .optional()
          .describe("Override the API key used for this client."),
      });
      t.AnthropicStrategyCustomParamsSchema = W;
      const H = a.z.object({
        model: a.z.string(),
        ...W.shape,
        ...c.AnthropicMessagesParamsSchema.shape,
      });
      t.AnthropicStrategyParamsSchema = H;
      const Q = a.z.object({
        model: a.z.string(),
        isSandbox: a.z.boolean().default(!1),
      });
      t.AlpacaStrategyParamsSchema = Q;
      const J = a.z.object({
        model: a.z.enum(["nvidia/nemotron-4-340b-instruct"]),
        temperature: a.z.number().optional(),
        top_p: a.z.number().optional(),
        max_tokens: a.z.number().optional(),
      });
      t.NemotronStrategyParamsSchema = J;
      const K = a.z.object({
        config: a.z.string().optional(),
        model: a.z.string().optional(),
      });
      var Y;
      (t.MeerkatSafetyStrategyParamsSchema = K),
        (t.GoldfishStrategyUseCase = Y),
        (function (e) {
          (e.EVAL = "eval"),
            (e.SFT_RLHF = "sft/rlhf"),
            (e.MULTIMODAL = "multimodal");
        })(Y || (t.GoldfishStrategyUseCase = Y = {}));
      const Z = a.z.object({
        model: a.z.string().default("grok-0626.research-models"),
        stream: a.z.boolean().default(!1),
        max_tokens: a.z.number().int().default(8192),
        use_case: a.z.nativeEnum(Y),
        temperature: a.z.number().optional().describe("Only for vlm-2"),
        partial_gen: a.z
          .enum(["Math", "chat_with_files", "chat_completions"])
          .describe(
            "Partial gen is a special API that returns chunked responses for process supervision. Only use this if the customer specified"
          )
          .optional(),
      });
      t.GoldfishStrategyParamsSchema = Z;
      const X = a.z.object({
        model: a.z.string().optional(),
        maxTokens: a.z.number().int().optional(),
        temperature: a.z.number().optional(),
      });
      var ee;
      (t.MonadMultimodalStrategyParamsSchema = X),
        (t.LiteLLMProvider = ee),
        (function (e) {
          (e.OpenAI = "openai"),
            (e.Anthropic = "anthropic"),
            (e.Cohere = "cohere"),
            (e.Mistral = "mistral"),
            (e.Bedrock = "bedrock"),
            (e.LLMEngine = "llmengine"),
            (e.Gemini = "gemini");
        })(ee || (t.LiteLLMProvider = ee = {}));
      const te = a.z.object({
        timeout: a.z.number().optional(),
        system_message_prefix: a.z.string().optional(),
        system_message_suffix: a.z.string().optional(),
        content_bytes: a.z.string().optional(),
        ...p,
      });
      t.OpenAIProviderCustomParamsSchema = te;
      const ne = a.z.object({
        model: c.OpenAIModelsSchema,
        temperature: a.z.number().optional(),
        max_tokens: a.z.number().optional(),
        timeout: a.z.number().optional(),
        logprobs: a.z.boolean().optional(),
        top_logprobs: a.z.number().optional(),
        stream: a.z.boolean().optional(),
        n: a.z.number().optional(),
        system_message_prefix: a.z.string().optional(),
        system_message_suffix: a.z.string().optional(),
        content_bytes: a.z.string().optional(),
        overrideApiKey: a.z.string().optional(),
        response_format: g.optional(),
        ...p,
        modalities: a.z.array(a.z.string()).optional(),
        audio: a.z
          .object({ voice: a.z.string(), format: a.z.string() })
          .optional(),
        modelResponseCorruptionMetadata:
          l.ModelResponseCorruptionMetadata.optional(),
        assignmentId: a.z.string().optional(),
        tools: a.z
          .array(
            a.z.object({
              type: a.z.enum(["function"]),
              function: c.FunctionObjectSchema,
            })
          )
          .optional(),
        functionCallOverride: a.z.string().optional(),
      });
      t.OpenAIStrategyParamsSchema = ne;
      const ie = a.z.object({
        overrideApiKey: a.z
          .string()
          .optional()
          .describe("Override the API key used for this client."),
        functionCallOverride: a.z
          .string()
          .optional()
          .describe(
            "A string parameter that overrides the default behavior of the tools parameter for function calling api."
          ),
      });
      t.LiteLLMCommonParamsSchema = ie;
      const re = a.z.object({
        provider: a.z.enum([ee.OpenAI]),
        model: c.OpenAIModelsSchema,
        ...ie.shape,
        ...c.OpenAIChatCompletionParamsSchema.shape,
        ...te.shape,
      });
      t.OpenAIProviderParamsSchema = re;
      const oe = a.z.object({
        provider: a.z.enum([ee.Anthropic]),
        model: a.z.string(),
        ...ie.shape,
        ...c.OpenAIChatCompletionParamsSchema.shape,
      });
      t.AnthropicProviderParamsSchema = oe;
      const ae = a.z.object({
        provider: a.z.enum([ee.Cohere]),
        model: a.z.string(),
        ...ie.shape,
        ...c.OpenAIChatCompletionParamsSchema.shape,
      });
      t.CohereProviderParamsSchema = ae;
      const se = a.z.object({
        provider: a.z.enum([ee.Bedrock]),
        model: a.z.string(),
        ...ie.shape,
        ...c.OpenAIChatCompletionParamsSchema.shape,
      });
      t.BedrockProviderParamsSchema = se;
      const le = a.z.object({
        provider: a.z.enum([ee.Mistral]),
        model: a.z.string(),
        ...ie.shape,
        ...c.OpenAIChatCompletionParamsSchema.shape,
      });
      t.MistralProviderParamsSchema = le;
      const ce = a.z.object({
        provider: a.z.enum([ee.LLMEngine]),
        model: a.z.string(),
        ...ie.shape,
        ...c.OpenAIChatCompletionParamsSchema.shape,
        ...c.VLLMAdditionalParamsSchema.shape,
      });
      t.LLMEngineProviderParamsSchema = ce;
      const pe = a.z.object({
        provider: a.z.enum([ee.Gemini]),
        model: V,
        ...ie.shape,
        ...c.OpenAIChatCompletionParamsSchema.shape,
      });
      t.GeminiProviderParamsSchema = pe;
      const ue = a.z.discriminatedUnion("provider", [re, oe, ae, le, pe, ce]);
      t.LiteLLMStrategyParamsSchema = ue;
      const de = {
        [o.MirrorStrategy]: f,
        [o.OpenAIStrategy]: ne,
        [o.EGPChatCompletionsStrategy]: v,
        [o.EGPV2ChatCompletionsStrategy]: v,
        [o.LiteLLMStrategy]: ue,
        [o.FlamingoStrategy]: b,
        [o.FlamingoGraphStrategy]: T,
        [o.FlamingoMMStrategy]: _,
        [o.FlamingoAudioStrategy]: S,
        [o.EGPCompletionsStrategy]: C,
        [o.EGPV2CompletionsStrategy]: C,
        [o.CohereStrategy]: I,
        [o.HuggingFaceStrategy]: R,
        [o.HuggingFaceStrategyV2]: R,
        [o.GorillaRewriteStrategy]: x,
        [o.BulbaLiveRewriteStrategy]: N,
        [o.BulbaIceStrategy]: z,
        [o.BulbaIceStrategyV2]: j,
        [o.SDAIAStrategy]: D,
        [o.BulbaBridgeStrategy]: L,
        [o.TextBisonStrategy]: w,
        [o.BeaverStrategy]: P,
        [o.ImpalaStrategy]: E,
        [o.BeeStrategy]: A,
        [o.BeeOrchestratorStrategy]: k,
        [o.DonovanStrategy]: O,
        [o.SealStrategy]: h,
        [o.AirdaleStrategy]: u,
        [o.AiredaleChatStrategy]: m,
        [o.SealStrategyV2]: h,
        [o.GeminiStrategy]: q,
        [o.VertexGeminiStrategy]: B,
        [o.YiStrategy]: G,
        [o.AnthropicStrategy]: H,
        [o.SealStrategyV3]: h,
        [o.OpenAIAssistantsStrategy]: y,
        [o.SealStrategyV4]: h,
        [o.ToolUseProcessSupervisionStrategy]: d,
        [o.AlpacaStrategy]: Q,
        [o.NemotronStrategy]: J,
        [o.MeerkatSafetyStrategy]: K,
        [o.GoldfishStrategy]: Z,
        [o.MonadMultimodalStrategy]: X,
      };
      var me;
      (t.StrategyParamsSchemaMap = de),
        (function (e) {
          (e.Billing = "billing"),
            (e.Benchmark = "benchmark"),
            (e.ChatMain = "chat-main"),
            (e.Linter = "linter"),
            (e.AutoFeedback = "auto-feedback"),
            (e.AutoReviewer = "auto-reviewer"),
            (e.AutoRater = "auto-rater"),
            (e.ProcessSupervision = "process-supervision"),
            (e.AutoLanguageDetection = "auto-language-detection"),
            (e.ModelEval = "model-eval"),
            (e.PipelineV3WorkflowFramework = "pipelinev3-workflow-framework"),
            (e.PipelineV3Hooks = "pipelinev3-hooks"),
            (e.Script = "script"),
            (e.AutoCritique = "auto-critique"),
            (e.Corp = "corp"),
            (e.Compass = "compass"),
            (e.GenAI = "genai"),
            (e.RLHF = "rlhf"),
            (e.Grader = "grader"),
            (e.StepFunctions = "sfn"),
            (e.Chatlite = "chatlite"),
            (e.AutoJsonata = "auto-jsonata"),
            (e.ChatTaskTool = "chat-task-tool"),
            (e.SyntheticBenchmark = "synthetic-benchmark"),
            (e.FailureMode = "failure-mode"),
            (e.ModelPlayground = "model-playground");
        })(me || (me = {}));
      const he = "responsive-seat-393017";
      t.GCPTextBisonProjectId = he;
      t.GCPTextBisonEnpoint =
        "https://us-central1-aiplatform.googleapis.com/v1/projects/responsive-seat-393017/locations/us-central1/publishers/google/models/text-bison:predict";
      const fe = {
        "api.openai.com": o.OpenAIStrategy,
        "generativelanguage.googleapis.com": o.GorillaRewriteStrategy,
        "34.105.44.178": o.BulbaLiveRewriteStrategy,
        "chatbot-gateway-7ssccobb.uc.gateway.dev": o.CohereStrategy,
        "api.cohere.ai": o.CohereStrategy,
        "falcon-40b-ift.ngrok.io": o.HuggingFaceStrategy,
        "api-inference.huggingface.co": o.HuggingFaceStrategyV2,
        "us-central1-aiplatform.googleapis.com": o.TextBisonStrategy,
        "hyperplant.io.naver.com": o.BeaverStrategy,
        "usw2-fm-third-party-endpoint-prod.apple.com": o.BeeStrategy,
      };
      t.EndpointHostToStrategyMap = fe;
      const ge = [
        o.BulbaIceStrategy,
        o.BulbaIceStrategyV2,
        o.OpenAIStrategy,
        o.FlamingoMMStrategy,
        o.FlamingoAudioStrategy,
        o.GoldfishStrategy,
        o.GeminiStrategy,
        o.VertexGeminiStrategy,
        o.BeeStrategy,
        o.BeeOrchestratorStrategy,
        o.AnthropicStrategy,
        o.MonadMultimodalStrategy,
        o.FlamingoGraphStrategy,
        o.LiteLLMStrategy,
      ];
      t.StrategiesThatSupportAttachments = ge;
      const ye = (e) => {
        if (Te[e]?.strategy) return Te[e].strategy;
        let t;
        try {
          t = new URL(e);
        } catch (n) {
          return;
        }
        return t && t.host ? fe[t.host] : void 0;
      };
      t.getStrategyFromUrl = ye;
      const be = (e) => ge.includes(e);
      t.doesStrategySupportAttachments = be;
      t.doesUrlSupportAttachments = (e) => {
        const t = ye(e);
        return !!t && be(t);
      };
      const Te = {
        "https://xiaohua-zhang-test.com/v1/chat/completions": {
          strategy: o.MirrorStrategy,
          description: "Testing, do not use",
          customer: "Scale",
        },
        "https://api.openai.com/v1/chat/completions": {
          strategy: o.OpenAIStrategy,
          description: "",
          customer: "Ostrich",
        },
        "https://falcon-40b-ift.ngrok.io": {
          strategy: o.HuggingFaceStrategy,
          description: "",
          customer: "Hedgehog",
        },
        "https://api-inference.huggingface.co/models/HuggingFaceH4/falcon-40b-ift":
          {
            strategy: o.HuggingFaceStrategyV2,
            description: "",
            customer: "Hedgehog",
          },
        "https://api.spellbook.scale.com/egp/v1/chat-completions": {
          strategy: o.EGPChatCompletionsStrategy,
          description: "V1 Chat Completions",
          customer: "Scale",
        },
        "https://api.spellbook.scale.com/egp/v1/completions": {
          strategy: o.EGPCompletionsStrategy,
          description: "V1 Completions",
          customer: "Scale",
        },
        "https://api.egp.scale.com/v2/completions": {
          strategy: o.EGPV2CompletionsStrategy,
          description: "V2 Completions",
          customer: "Scale",
        },
        "https://api.egp.scale.com/v2/chat-completions": {
          strategy: o.EGPV2ChatCompletionsStrategy,
          description: "V2 Chat Completions",
          customer: "Scale",
        },
        "https://litellm.ml-serving-internal.scale.com/v1/chat/completions": {
          strategy: o.LiteLLMStrategy,
          description: "Chat completions through LiteLLM Proxy",
          customer: "Scale",
        },
        "https://api.cohere.ai/v1/chat": {
          strategy: o.CohereStrategy,
          description: "",
          customer: "Crab",
        },
        GCPTextBisonEnpoint: {
          strategy: o.TextBisonStrategy,
          description: "Text Bison",
          customer: "Vertigo",
        },
        "https://hyperplant.io.naver.com/v1/proxy/call_llm": {
          strategy: o.BeaverStrategy,
          description: "",
          customer: "Beaver",
        },
        "https://pieplatform.co/api/external/chat": {
          strategy: o.ImpalaStrategy,
          description: "",
          customer: "Impala",
        },
        "https://autopush-generativelanguage.sandbox.googleapis.com/v1beta2": {
          strategy: o.BulbaBridgeStrategy,
          description: "Gemini Internal - Use preprod instead",
          customer: "Gaius",
        },
        "https://preprod-generativelanguage.googleapis.com/v1beta": {
          strategy: o.BulbaBridgeStrategy,
          description: "Gemini Internal",
          customer: "Gaius",
        },
        "https://usw2-fm-third-party-endpoint-prod.apple.com/api/v1/chat/completions":
          { strategy: o.BeeStrategy, description: "", customer: "Bee" },
        "https://usw2-fm-third-party-endpoint-prod.apple.com/api/v1/orchestrator/completions":
          {
            strategy: o.BeeOrchestratorStrategy,
            description: "Only for afm-text-orch-* endpoints",
            customer: "Bee",
          },
        "https://www.fairllms.com/codellama": {
          strategy: o.FlamingoStrategy,
          description: "Code LLaMa",
          customer: "Lazarus",
        },
        "https://graph-genai.facebook.com/v18.0": {
          strategy: o.FlamingoGraphStrategy,
          description: "",
          customer: "Lazarus",
        },
        "https://graph-genai.facebook.com/v19.0/retina_generations": {
          strategy: o.FlamingoMMStrategy,
          description: "",
          customer: "Lazarus",
        },
        "https://graph-genai.facebook.com/v18.0/llm_annotations_speech_to_speech":
          {
            strategy: o.FlamingoAudioStrategy,
            description: "",
            customer: "Lazarus",
          },
        "https://34.105.44.178/api_v2": {
          strategy: o.BulbaIceStrategy,
          description: "Bulba Ice",
          customer: "Gaius",
        },
        "https://vllm.allam.ai/v1/chat/completions": {
          strategy: o.SDAIAStrategy,
          description: "",
          customer: "Sandfish",
        },
        "https://preprod-generativelanguage.googleapis.com/v1beta/models/chat-modelName:generateContent":
          {
            strategy: o.BulbaIceStrategyV2,
            description: "",
            customer: "Gaius",
          },
        "https://api.donovan.scale[gov].com/v1/chat": {
          strategy: o.DonovanStrategy,
          description: "",
          customer: "Scale",
        },
        "https://3e68c4a5-6f1e-4a5c-81de-02e60ff6bd28-8080.job.console.elementai.com/generate":
          { strategy: o.SealStrategy, description: "", customer: "Seal" },
        "https://api.ai21.com/studio/v1/j2-ultra/complete": {
          strategy: o.AirdaleStrategy,
          description: "",
          customer: "Airdale",
        },
        "https://api.ai21.com/studio/v1/j2-ultra/chat": {
          strategy: o.AiredaleChatStrategy,
          description: "",
          customer: "Airdale",
        },
        "https://1c9dbf63-7634-4d3b-ab34-dc9242dbc6d4-8080.job.console.elementai.com/generate":
          { strategy: o.SealStrategyV2, description: "", customer: "Seal" },
        "https://generativelanguage.googleapis.com/v1beta/models/gemini": {
          strategy: o.GeminiStrategy,
          description: "Gemini Public",
          customer: "Gaius",
        },
        "https://aiplatform.googleapis.com/$discovery/rest?version=v1beta1": {
          strategy: o.VertexGeminiStrategy,
          description: "",
          customer: "Vertigo",
        },
        "https://api.replicate.com/v1/predictions/yi": {
          strategy: o.YiStrategy,
          description: "",
          customer: "Yi",
        },
        "https://api.anthropic.com/v1/messages": {
          strategy: o.AnthropicStrategy,
          description: "",
          customer: "Abra",
        },
        "https://4f2e2788-d8b6-4a1e-b1c4-bb0a43bd55f6-8080.job.console.elementai.com/generate":
          { strategy: o.SealStrategyV3, description: "", customer: "Seal" },
        "https://api.openai.com/v1/assistants": {
          strategy: o.OpenAIAssistantsStrategy,
          description: "Assistants",
          customer: "Ostrich",
        },
        "https://snow-core_llm-inference_external-core_llm_hold_scale_router.job.console.elementai.com/generate":
          {
            strategy: o.SealStrategyV4,
            description: "",
            customer: "ServiceNow",
          },
        "https://psuedo-launch-url/tool-use-process-supervision": {
          strategy: o.ToolUseProcessSupervisionStrategy,
          description: "",
          customer: "Scale",
        },
        "https://q3pacei43h.execute-api.us-east-1.amazonaws.com": {
          strategy: o.AlpacaStrategy,
          description: "",
          customer: "Alpaca",
        },
        "https://integrate.api.nvidia.com/v1": {
          strategy: o.NemotronStrategy,
          description: "",
          customer: "Narwhal",
        },
        "https://flightacademy.inf5mi6t.com/api/external/chat/": {
          strategy: o.MeerkatSafetyStrategy,
          description: "",
          customer: "Meerkat",
        },
        "https://api.x.ai": {
          strategy: o.GoldfishStrategy,
          description: "",
          customer: "Goldfish",
        },
        "https://api.mistraldev.net/v1/chat/completions": {
          strategy: o.MonadMultimodalStrategy,
          description: "Monad Multimodal Pilot",
          customer: "Monad",
        },
      };
      t.masterEndpointMap = Te;
    },
    173995: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.disagreementFeedbackTemplate =
          t.OUTPUT_SYSTEM_INSTRUCTIONS =
          t.OUTPUT_FORMAT_BLOCK =
          t.validAutoFeedbackStepTypes =
          t.globalChatVariablesTooltipMap =
          t.globalAllowedChatVariablesByStep =
          t.RESPONSE_INDEX_REGEX =
          t.ML_FIELD_VARIABLES =
          t.DefaultGlobalVariable =
          t.InlinePositionType =
          t.AutoFeedbackExecutionType =
          t.AutoFeedbackItemStatus =
          t.AutoFeedbackCategory =
            void 0);
      var i,
        r,
        o,
        a,
        s,
        l = n(232095);
      (t.AutoFeedbackCategory = i),
        (function (e) {
          (e.GRAMMAR = "Grammar"),
            (e.FACTUALITY = "Factuality"),
            (e.QUALITY = "Quality"),
            (e.INSTRUCTIONS = "Instructions"),
            (e.CREATIVITY = "Creativity"),
            (e.AP_STYLE = "AP Style"),
            (e.FORMATTING = "Formatting");
        })(i || (t.AutoFeedbackCategory = i = {})),
        (t.AutoFeedbackItemStatus = r),
        (function (e) {
          (e.FIXED = "Fixed"),
            (e.IGNORED = "Ignored"),
            (e.RESOLVED = "Resolved");
        })(r || (t.AutoFeedbackItemStatus = r = {})),
        (t.AutoFeedbackExecutionType = o),
        (function (e) {
          (e.TASK = "Task"), (e.POST_PROCESS = "Post Process"), (e.CSV = "CSV");
        })(o || (t.AutoFeedbackExecutionType = o = {})),
        (t.InlinePositionType = a),
        (function (e) {
          e.TEXT = "text";
        })(a || (t.InlinePositionType = a = {})),
        (t.DefaultGlobalVariable = s),
        (function (e) {
          (e.EDITED_RESPONSE_TEXT = "__edited_response_text"),
            (e.PROMPT_TEXT = "__prompt_text"),
            (e.CHAT_HISTORY = "__chat_history"),
            (e.ORIGINAL_RESPONSE_TEXT = "__original_response_text"),
            (e.CURR_RESPONSE_INDEX = "__responses[currResponseIndex]"),
            (e.MULTICHAT_CONVERSATION_GOAL = "__conversation_goal"),
            (e.MOST_RECENT_RESPONSE = "__most_recent_response_[responseId]");
        })(s || (t.DefaultGlobalVariable = s = {}));
      const c = Object.freeze([
        { name: "Edited Response Text", id: s.EDITED_RESPONSE_TEXT },
        { name: "Prompt Text", id: s.PROMPT_TEXT },
        { name: "Chat History", id: s.CHAT_HISTORY },
        { name: "Original Response Text", id: s.ORIGINAL_RESPONSE_TEXT },
        { name: "Current Response Index", id: s.CURR_RESPONSE_INDEX },
      ]);
      t.ML_FIELD_VARIABLES = c;
      t.RESPONSE_INDEX_REGEX =
        /__responses\[\s*currResponseIndex\s*(?:-\s*(\d+))?\s*\]/g;
      const p = {
        [l.InteractionStepType.PromptInput]: [s.PROMPT_TEXT, s.CHAT_HISTORY],
        [l.InteractionStepType.ModelResponseEditor]: [
          s.EDITED_RESPONSE_TEXT,
          s.ORIGINAL_RESPONSE_TEXT,
          s.PROMPT_TEXT,
          s.CHAT_HISTORY,
        ],
        [l.InteractionStepType.ModelResponseSelector]: [
          s.PROMPT_TEXT,
          s.CHAT_HISTORY,
          s.MOST_RECENT_RESPONSE,
        ],
      };
      t.globalAllowedChatVariablesByStep = p;
      const u = {
        [s.CURR_RESPONSE_INDEX]:
          "The response at the index where the evaluator runs.\n  Modify to reference previous responses (e.g. __responses[currResponseIndex - 1])\n  Reference paths within the response (e.g. __responses[currResponseIndex].context.response.annotations[0]).",
      };
      t.globalChatVariablesTooltipMap = u;
      const d = [
        l.InteractionStepType.ModelResponseEditor,
        l.InteractionStepType.PromptInput,
      ];
      t.validAutoFeedbackStepTypes = d;
      t.OUTPUT_FORMAT_BLOCK =
        "\n\n-----------------------------\nThen, in your response, add an array of strings using double quotations (\"), where each string is a specific issue plus suggested fixes.\nThe array must be JSON parseable. When quoting a sentence or fragment from the provided User Written Response, use single quotes.\nDo not use double quotes for quoting the User Written Response. And MOST IMPORTANTLY do NOT include any backslashes in your response.\n\nFinally, wrap the array in a block surrounded by ```feedback``` markdown.\n\nExample:\n```feedback\n[\"The sentence 'abc' is incoherent.\", \"Change 'toda' to 'today'.\"]\n```\n-----------------------------";
      t.OUTPUT_SYSTEM_INSTRUCTIONS =
        "-----------------------------\nFollow these instructions exactly for formatting your response:\n\n1. **Create an array of strings** using double quotations (\").\n2. **Each string must identify a specific issue and suggest a fix.**\n3. **The array must be JSON parseable.**\n4. When quoting a sentence or fragment from the User Written Response, **use single quotes ('), NOT double quotes (\").**\n5. **DO NOT include any backslashes () in your response.**\n\n**Example:**\n^*^*^[\"The sentence 'abc' is incoherent.\", \"Change 'toda' to 'today'.\"]^*^*^\n\n**IMPORTANT: DO NOT DO THE FOLLOWING:**\n- Do NOT wrap the array in any other manner.\n- Do NOT include backslashes.\n- Do NOT use double quotes for quoting the User Written Response.\n- Do NOT format the array as a code block.\n\n**BAD Example (DO NOT DO THIS):**\n```python\n[\"The sentence 'abc' is incoherent.\", \"Change 'toda' to 'today'.\"]\n```\n-----------------------------";
      t.disagreementFeedbackTemplate = (e, t) =>
        `-----------------------------\n## Issues not to flag (even if you identify the following issues, do not include them in your response):\nAny issues within the Chat History ${
          t === l.InteractionStepType.ModelResponseEditor ? "or Prompt" : ""
        },\n${e}`;
    },
    612182: function (e, t) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
    },
    510478: function (e, t) {
      "use strict";
      var n;
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.CorruptionEndpointId = void 0),
        (t.CorruptionEndpointId = n),
        (function (e) {
          (e.Uncorrupted = "uncorrupted"),
            (e.CorruptedAccuracy = "corrupted-accuracy"),
            (e.CorruptedFluency = "corrupted-fluency"),
            (e.CorruptedGibberish = "corrupted-gibberish"),
            (e.CorruptedNoDeviation = "corrupted-no-deviation"),
            (e.CorruptedAutoDimension = "corrupted-auto-dimension");
        })(n || (t.CorruptionEndpointId = n = {}));
    },
    799581: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.constructStepChildId =
          t.HIDDEN_STEP_TYPES =
          t.sanitizeStepResponses =
          t.getCanViewEditFeedback =
          t.getCanAddFeedback =
          t.belongsToStep =
          t.truncateText =
          t.transformWorkerCommentsToUnifiedFeedback =
          t.ActionTakenEnum =
          t.FeedbackPriority =
            void 0);
      var i,
        r,
        o = n(674055),
        a = n(854358),
        s = u(n(711719)),
        l = n(599789),
        c = n(108896),
        p = u(n(298784));
      function u(e) {
        return e && e.__esModule ? e : { default: e };
      }
      (t.FeedbackPriority = i),
        (function (e) {
          (e.HIGH = "High risk issues"), (e.LOW = "Other detected issues");
        })(i || (t.FeedbackPriority = i = {})),
        (t.ActionTakenEnum = r),
        (function (e) {
          (e.Fixed = "Fixed"),
            (e.Disagreed = "Disagreed"),
            (e.Ignored = "Ignored"),
            (e.Dismissed = "Dismissed");
        })(r || (t.ActionTakenEnum = r = {}));
      t.transformWorkerCommentsToUnifiedFeedback = (e) =>
        e.map((e) => {
          const t = i.HIGH,
            n = e.title ?? d(e.comment, 35),
            l = e.comment,
            c = e.childId,
            p = e.turn;
          return {
            id: s.default.v4(),
            type: o.FeedbackType.HumanReviewerFeedback,
            title: n,
            content: l,
            priority: t,
            childId: c,
            turn: p,
            inlinePosition:
              e.locationStart || e.locationEnd
                ? {
                    type: "Text",
                    start: e.locationStart,
                    end: e.locationEnd,
                    quotedText: e.quotedText,
                  }
                : void 0,
            sourceFeedbackId: e.workerCommentId,
            action: e.feedbackResponse
              ? {
                  actionTaken:
                    e.feedbackResponse === a.FeedbackResponseType.Accept
                      ? r.Fixed
                      : r.Disagreed,
                }
              : void 0,
            author: e.author,
            isBlocking: !1,
          };
        });
      const d = (e, t) => (e.length > t ? e.substring(0, t) + "..." : e);
      t.truncateText = d;
      t.belongsToStep = (e, t) => e === t || (!(!e || !t) && e.startsWith(t));
      t.getCanAddFeedback = ({ reviewLevel: e, areCommentsReadOnly: t }) =>
        !t && e !== l.ReviewLevel.Attempt;
      t.getCanViewEditFeedback = ({ feedback: e }) => e.length > 0;
      t.sanitizeStepResponses = ({
        currStepResponse: e,
        allStepResponses: t,
        currStepParams: n,
        allStepParams: i,
      }) => {
        t = t.map((t) =>
          t.step_id === n.id
            ? { ...p.default.cloneDeep(t), ...p.default.cloneDeep(e) }
            : t
        );
        let r = e;
        if (n.type === a.InteractionStepType.TextCollection)
          (r = p.default.cloneDeep(e)),
            (r.context.response = c.removeHiddenFields(
              r.context.response,
              n.params.fields
            ));
        else if (n.type === a.InteractionStepType.TextCollectionPerResponse) {
          r = p.default.cloneDeep(e);
          const t = r.context.annotations;
          Object.keys(t).forEach((e) => {
            t[e] = c.removeHiddenFields(t[e], n.params.fields);
          });
        }
        return {
          sanitizedStepResponse: r,
          sanitizedResponses: t.map((e, t) => {
            const n = i[t];
            if (n.type === a.InteractionStepType.TextCollection) {
              const t = p.default.cloneDeep(e);
              return (
                (t.context.response = c.removeHiddenFields(
                  t.context.response,
                  n.params.fields
                )),
                t
              );
            }
            if (n.type === a.InteractionStepType.TextCollectionPerResponse) {
              const t = p.default.cloneDeep(e),
                i = t.context.annotations;
              return (
                Object.keys(i).forEach((e) => {
                  i[e] = c.removeHiddenFields(i[e], n.params.fields);
                }),
                t
              );
            }
            return e;
          }),
        };
      };
      const m = [
        a.InteractionStepType.Instruction,
        a.InteractionStepType.ContextDirections,
      ];
      t.HIDDEN_STEP_TYPES = m;
      t.constructStepChildId = (e, t, n) =>
        n ? `${e}-${t}-${n}` : `${e}-${t}`;
    },
    35557: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.DeliveryBuilderJobRequestSchema =
          t.DEFAULT_CHAT_DELIVERY_ATTEMPT_COUNT_LIMIT =
          t.PRIMITIVE_EXTERNAL_ATTEMPT_FIELDS =
          t.EXTERNAL_ATTEMPT_FIELDS =
            void 0);
      var i,
        r = n(689510),
        o = (i = n(298784)) && i.__esModule ? i : { default: i };
      const a = ["attemptedBy", "attemptedAt", "reviewLevel", "response", "id"];
      t.EXTERNAL_ATTEMPT_FIELDS = a;
      const s = o.default.without(a, "response");
      t.PRIMITIVE_EXTERNAL_ATTEMPT_FIELDS = s;
      t.DEFAULT_CHAT_DELIVERY_ATTEMPT_COUNT_LIMIT = 1;
      const l = r.z.object({
        taskIds: r.z.array(r.z.string().length(24)),
        projectId: r.z.string().length(24),
        email: r.z.string().email(),
        requestUserId: r.z.string().length(24),
        isTest: r.z.boolean().optional(),
      });
      t.DeliveryBuilderJobRequestSchema = l;
    },
    674055: function (e, t) {
      "use strict";
      var n, i;
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.OverridePayConfigCheck = t.FeedbackType = void 0),
        (t.FeedbackType = n),
        (function (e) {
          (e.AutoFeedback = "AutoFeedback"),
            (e.ReviewerCopilot = "ReviewerCopilot"),
            (e.ProcessCritique = "ProcessCritique"),
            (e.AutoCritique = "AutoCritique"),
            (e.ModelCritique = "ModelCritique"),
            (e.Linters = "Linters"),
            (e.HumanReviewerFeedback = "HumanReviewerFeedback"),
            (e.AutoQC = "AutoQC"),
            (e.MarkdownValidation = "MarkdownValidation");
        })(n || (t.FeedbackType = n = {})),
        (t.OverridePayConfigCheck = i),
        (function (e) {
          (e.DolphinMirrorProject = "dolphinMirrorProject"),
            (e.OtherMirrorProject = "otherMirrorProject"),
            (e.LazarusMinimumRateException = "lazarusMinimumRateException"),
            (e.QualityBasedPay = "qualityBasedPay"),
            (e.PayPerTask = "payPerTask"),
            (e.PayHighestLanguageSkill = "payHighestLanguageSkill"),
            (e.Other = "other");
        })(i || (t.OverridePayConfigCheck = i = {}));
    },
    572368: function (e, t) {
      "use strict";
      var n, i, r, o;
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.OVERALL_WORKER_COMMENT_SOURCE_TYPES =
          t.WorkerCommentType =
          t.WorkerCommentSourceType =
          t.WorkerCommentParentType =
          t.FeedbackResponseType =
            void 0),
        (t.FeedbackResponseType = n),
        (function (e) {
          (e.Accept = "accept"), (e.Dismiss = "dismiss");
        })(n || (t.FeedbackResponseType = n = {})),
        (t.WorkerCommentParentType = i),
        (function (e) {
          (e.PipelineV3HumanNode = "pipelineV3HumanNode"),
            (e.TaskAttempt = "taskAttempt"),
            (e.Task = "task");
        })(i || (t.WorkerCommentParentType = i = {})),
        (t.WorkerCommentSourceType = r),
        (function (e) {
          (e.Inline = "inline"),
            (e.Step = "step"),
            (e.TextCollection = "textCollection"),
            (e.QualityMeasurement = "qualityMeasurement"),
            (e.RRS = "rrs"),
            (e.RewardModel = "rewardModel"),
            (e.AutoReviewer = "autoReviewer"),
            (e.SpeedAudit = "speedAudit"),
            (e.TextBasedSpeedAudit = "textBasedSpeedAudit"),
            (e.ChatBulkAudit = "chatBulkAudit"),
            (e.AutoQC = "autoQC");
        })(r || (t.WorkerCommentSourceType = r = {})),
        (t.WorkerCommentType = o),
        (function (e) {
          (e.Text = "text"),
            (e.Rating = "rating"),
            (e.Category = "category"),
            (e.Boolean = "boolean");
        })(o || (t.WorkerCommentType = o = {}));
      const a = [r.TextCollection, r.QualityMeasurement, r.RRS];
      t.OVERALL_WORKER_COMMENT_SOURCE_TYPES = a;
    },
    854358: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
      var i = {},
        r = v(n(232095));
      Object.keys(r).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === r[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return r[e];
              },
            }));
      });
      var o = v(n(893383));
      Object.keys(o).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === o[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return o[e];
              },
            }));
      });
      var a = v(n(441936));
      Object.keys(a).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === a[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return a[e];
              },
            }));
      });
      var s = v(n(674055));
      Object.keys(s).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === s[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return s[e];
              },
            }));
      });
      var l = v(n(402168));
      Object.keys(l).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === l[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return l[e];
              },
            }));
      });
      var c = v(n(510478));
      Object.keys(c).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === c[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return c[e];
              },
            }));
      });
      var p = v(n(411802));
      Object.keys(p).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === p[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return p[e];
              },
            }));
      });
      var u = v(n(612182));
      Object.keys(u).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === u[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return u[e];
              },
            }));
      });
      var d = v(n(341226));
      Object.keys(d).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === d[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return d[e];
              },
            }));
      });
      var m = v(n(572368));
      Object.keys(m).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === m[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return m[e];
              },
            }));
      });
      var h = v(n(392228));
      Object.keys(h).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === h[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return h[e];
              },
            }));
      });
      var f = v(n(400022));
      Object.keys(f).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === f[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return f[e];
              },
            }));
      });
      var g = v(n(173995));
      Object.keys(g).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === g[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return g[e];
              },
            }));
      });
      var y = v(n(807834));
      Object.keys(y).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === y[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return y[e];
              },
            }));
      });
      var b = v(n(35557));
      Object.keys(b).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === b[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return b[e];
              },
            }));
      });
      var T = v(n(445216));
      Object.keys(T).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === T[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return T[e];
              },
            }));
      });
      var _ = v(n(66630));
      Object.keys(_).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === _[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return _[e];
              },
            }));
      });
      var S = v(n(799581));
      function v(e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e)
          for (var n in e)
            if (Object.prototype.hasOwnProperty.call(e, n)) {
              var i =
                Object.defineProperty && Object.getOwnPropertyDescriptor
                  ? Object.getOwnPropertyDescriptor(e, n)
                  : {};
              i.get || i.set ? Object.defineProperty(t, n, i) : (t[n] = e[n]);
            }
        return (t.default = e), t;
      }
      Object.keys(S).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === S[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return S[e];
              },
            }));
      });
    },
    66630: function (e, t) {
      "use strict";
      var n;
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.SupportedLanguages = void 0),
        (t.SupportedLanguages = n),
        (function (e) {
          (e.auto = "auto"),
            (e.ar = "ar"),
            (e.astES = "ast-ES"),
            (e.beBY = "be-BY"),
            (e.brFR = "br-FR"),
            (e.caES = "ca-ES"),
            (e.caESBalear = "ca-ES-balear"),
            (e.caESValencia = "ca-ES-valencia"),
            (e.crhUA = "crh-UA"),
            (e.daDK = "da-DK"),
            (e.de = "de"),
            (e.deAT = "de-AT"),
            (e.deCH = "de-CH"),
            (e.deDE = "de-DE"),
            (e.deDEXSimpleLanguage = "de-DE-x-simple-language"),
            (e.deDEXSimpleLanguageDE = "de-DE-x-simple-language-DE"),
            (e.deLU = "de-LU"),
            (e.elGR = "el-GR"),
            (e.en = "en"),
            (e.enAU = "en-AU"),
            (e.enCA = "en-CA"),
            (e.enGB = "en-GB"),
            (e.enNZ = "en-NZ"),
            (e.enUS = "en-US"),
            (e.enZA = "en-ZA"),
            (e.eo = "eo"),
            (e.es = "es"),
            (e.esAR = "es-AR"),
            (e.esES = "es-ES"),
            (e.fa = "fa"),
            (e.faIR = "fa-IR"),
            (e.fr = "fr"),
            (e.frBE = "fr-BE"),
            (e.frCA = "fr-CA"),
            (e.frCH = "fr-CH"),
            (e.frFR = "fr-FR"),
            (e.gaIE = "ga-IE"),
            (e.glES = "gl-ES"),
            (e.it = "it"),
            (e.itIT = "it-IT"),
            (e.jaJP = "ja-JP"),
            (e.kmKH = "km-KH"),
            (e.nl = "nl"),
            (e.nlBE = "nl-BE"),
            (e.nlNL = "nl-NL"),
            (e.plPL = "pl-PL"),
            (e.pt = "pt"),
            (e.ptAO = "pt-AO"),
            (e.ptBR = "pt-BR"),
            (e.ptMZ = "pt-MZ"),
            (e.ptPT = "pt-PT"),
            (e.roRO = "ro-RO"),
            (e.ruRU = "ru-RU"),
            (e.skSK = "sk-SK"),
            (e.slSI = "sl-SI"),
            (e.sv = "sv"),
            (e.svSE = "sv-SE"),
            (e.taIN = "ta-IN"),
            (e.tlPH = "tl-PH"),
            (e.ukUA = "uk-UA"),
            (e.zhCN = "zh-CN");
        })(n || (t.SupportedLanguages = n = {}));
    },
    341226: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.LinterPresets =
          t.LinterPreset =
          t.ChatTaskScriptLinterConfigSchemas =
          t.ChatTaskLinterToSupportedStepTypes =
          t.ChatTaskLinters =
            void 0);
      var i = n(599789),
        r = n(971599),
        o = n(101241),
        a = n(388703),
        s = n(689510),
        l = n(232095);
      const c = [
        o.ScriptLinterName.GrammarLinter,
        o.ScriptLinterName.ContradictionsLinter,
        o.ScriptLinterName.SpamLinter,
        o.ScriptLinterName.ToxicityLinter,
        o.ScriptLinterName.MultilingualToxicityLinter,
        o.ScriptLinterName.ChatJsonataCustomLinter,
        o.ScriptLinterName.ChatRobotsValidationCustomLinter,
        o.ScriptLinterName.ChatMultiReplicaJsonataCustomLinter,
        o.ScriptLinterName.ChatLazarusMathTopicsLinter,
        o.ScriptLinterName.ChatZipFileContentsLinter,
        o.ScriptLinterName.ChatCustomEndpointLinter,
        o.ScriptLinterName.ChatPreventAnswerBasedOnContributorWt,
        o.ScriptLinterName.ChatDolphinPromptImage,
        o.ScriptLinterName.NightingaleCheckCorrectnessClassification,
        o.ScriptLinterName.ChatJustificationMinWords,
        o.ScriptLinterName.NightingaleResponseCoherence,
        o.ScriptLinterName.ChatNightingaleRankingConsistencyLinter,
        o.ScriptLinterName.ChatNightingaleRatingConsistencyLinter,
        o.ScriptLinterName.ChatMissingResponseLinter,
        o.ScriptLinterName.ChatMLSingletonQualityMetricLinter,
        o.ScriptLinterName.ChatMLPromptResponsePairQualityMetricLinter,
        o.ScriptLinterName.ChatRegexLinter,
        o.ScriptLinterName.ChatGPTZeroLinter,
        o.ScriptLinterName.ChatMinEditDistanceLinter,
        o.ScriptLinterName.ChatUniqueResponseLinter,
        o.ScriptLinterName.ChatCompletedTasksUniqueResponseLinter,
        o.ScriptLinterName.ChatPromptResponsePairLinter,
        o.ScriptLinterName.ChatCorrectLanguageLinter,
        o.ScriptLinterName.ChatTextLengthLinter,
        o.ScriptLinterName.ChatNGramDiversityLinter,
        o.ScriptLinterName.ChatBadWordsLinter,
        o.ScriptLinterName.ChatSemanticSimilarityLinter,
        o.ScriptLinterName.ChatMultiTurnResponseSimilarityLinter,
        o.ScriptLinterName.ChatGoogleTranslateDetectionLinter,
        o.ScriptLinterName.ChatURLExistsLinter,
        o.ScriptLinterName.ChatPromptResponseWordCountDiffLinter,
        o.ScriptLinterName.ChatSphereExecutionOutputLinter,
        o.ScriptLinterName.BeeCustomLinter,
        o.ScriptLinterName.ChatJustificationLikertMatchMLLinter,
        o.ScriptLinterName.ChatValidLikertScoreLinter,
        o.ScriptLinterName.ChatNightingaleCustomizedLinter,
        o.ScriptLinterName.ChatNightingaleArchetypeDiversityLinter,
        o.ScriptLinterName.ChatNightingaleGoalAlignmentLinter,
        o.ScriptLinterName.ChatNightingalePlagiarismLinter,
        o.ScriptLinterName.ChatNightingaleReferenceLinter,
        o.ScriptLinterName.ChatNightingaleValidateArchetypeLinter,
        o.ScriptLinterName.ChatNightingaleWordCountLinter,
        o.ScriptLinterName.ChatPromptComparisonToSearchResult,
        o.ScriptLinterName.ChatBulbaFactualityLinter,
        o.ScriptLinterName.ChatNERSentenceLinter,
        o.ScriptLinterName.ChatBulbaLikertResponseValidator,
        o.ScriptLinterName.ChatBulbaLockFieldLinter,
        o.ScriptLinterName.ChatPromptModelAgreementLinter,
        o.ScriptLinterName.ChatBulbaCodeEvalCodePresentLinter,
        o.ScriptLinterName.ChatImageNSFWLinter,
        o.ScriptLinterName.ChatMRSSphereExecutionRelevanceLinter,
        o.ScriptLinterName.ChatGoogleSearchPlagiarismLinter,
        o.ScriptLinterName.ChatMultiModalRelevanceLinter,
        o.ScriptLinterName.ChatLatexParsingLinter,
        o.ScriptLinterName.ChatBlockMMMULinter,
        o.ScriptLinterName.ChatAutoraterPlagiarismLinter,
        o.ScriptLinterName.ChatLambdaUnitTestExecutionLinter,
      ];
      t.ChatTaskLinters = c;
      const p = [
          l.InteractionStepType.ModelResponseEditor,
          l.InteractionStepType.ModelResponseSelector,
          l.InteractionStepType.TextCollection,
          l.InteractionStepType.TextCollectionPerResponse,
          l.InteractionStepType.PromptInput,
          l.InteractionStepType.MultiTurnContinue,
          l.InteractionStepType.QualityMeasurement,
          l.InteractionStepType.ProcessSupervision,
          l.InteractionStepType.QuantitativeModelResponseSelector,
          l.InteractionStepType.PromptTextCollection,
          l.InteractionStepType.ToolUseProcessSupervision,
        ],
        u = [
          l.InteractionStepType.ModelResponseEditor,
          l.InteractionStepType.ModelResponseSelector,
          l.InteractionStepType.TextCollection,
          l.InteractionStepType.TextCollectionPerResponse,
          l.InteractionStepType.PromptInput,
          l.InteractionStepType.MultiTurnContinue,
          l.InteractionStepType.QualityMeasurement,
          l.InteractionStepType.ProcessSupervision,
          l.InteractionStepType.QuantitativeModelResponseSelector,
          l.InteractionStepType.PromptTextCollection,
        ],
        d = {
          [o.ScriptLinterName.ChatMissingResponseLinter]: [
            l.InteractionStepType.PromptInput,
            l.InteractionStepType.MultiTurnContinue,
            l.InteractionStepType.ModelResponseEditor,
            l.InteractionStepType.TextCollection,
            l.InteractionStepType.TextCollectionPerResponse,
            l.InteractionStepType.NER,
          ],
          [o.ScriptLinterName.ChatMLSingletonQualityMetricLinter]: [
            l.InteractionStepType.PromptInput,
            l.InteractionStepType.MultiTurnContinue,
            l.InteractionStepType.ModelResponseEditor,
            l.InteractionStepType.TextCollection,
          ],
          [o.ScriptLinterName.ChatMLPromptResponsePairQualityMetricLinter]: [
            l.InteractionStepType.ModelResponseEditor,
          ],
          [o.ScriptLinterName.ChatRegexLinter]: [
            l.InteractionStepType.PromptInput,
            l.InteractionStepType.MultiTurnContinue,
            l.InteractionStepType.ModelResponseEditor,
            l.InteractionStepType.ModelResponseSelector,
            l.InteractionStepType.QuantitativeModelResponseSelector,
            l.InteractionStepType.TextCollection,
            l.InteractionStepType.TextCollectionPerResponse,
          ],
          [o.ScriptLinterName.ChatGPTZeroLinter]: [
            l.InteractionStepType.PromptInput,
            l.InteractionStepType.MultiTurnContinue,
            l.InteractionStepType.ModelResponseEditor,
            l.InteractionStepType.TextCollection,
            l.InteractionStepType.TextCollectionPerResponse,
          ],
          [o.ScriptLinterName.ChatMinEditDistanceLinter]: [
            l.InteractionStepType.ModelResponseEditor,
          ],
          [o.ScriptLinterName.ChatUniqueResponseLinter]: [
            l.InteractionStepType.PromptInput,
            l.InteractionStepType.MultiTurnContinue,
            l.InteractionStepType.ModelResponseEditor,
            l.InteractionStepType.TextCollection,
          ],
          [o.ScriptLinterName.ChatCompletedTasksUniqueResponseLinter]: [
            l.InteractionStepType.PromptInput,
            l.InteractionStepType.MultiTurnContinue,
            l.InteractionStepType.ModelResponseEditor,
            l.InteractionStepType.TextCollection,
          ],
          [o.ScriptLinterName.ChatPromptResponsePairLinter]: [
            l.InteractionStepType.PromptInput,
            l.InteractionStepType.MultiTurnContinue,
            l.InteractionStepType.ModelResponseEditor,
            l.InteractionStepType.TextCollection,
            l.InteractionStepType.ProcessSupervision,
            l.InteractionStepType.ToolUseProcessSupervision,
            l.InteractionStepType.ExperimentalToolUse,
            l.InteractionStepType.TextCollectionPerResponse,
            l.InteractionStepType.ModelResponseSelector,
            l.InteractionStepType.QuantitativeModelResponseSelector,
            l.InteractionStepType.PromptTextCollection,
          ],
          [o.ScriptLinterName.ChatCorrectLanguageLinter]: [
            l.InteractionStepType.PromptInput,
            l.InteractionStepType.MultiTurnContinue,
            l.InteractionStepType.ModelResponseEditor,
            l.InteractionStepType.TextCollection,
          ],
          [o.ScriptLinterName.ChatTextLengthLinter]: [
            l.InteractionStepType.PromptInput,
            l.InteractionStepType.MultiTurnContinue,
            l.InteractionStepType.ModelResponseEditor,
            l.InteractionStepType.ModelResponseSelector,
            l.InteractionStepType.TextCollection,
            l.InteractionStepType.ProcessSupervision,
            l.InteractionStepType.TextCollectionPerResponse,
            l.InteractionStepType.QuantitativeModelResponseSelector,
          ],
          [o.ScriptLinterName.ChatNGramDiversityLinter]: [
            l.InteractionStepType.PromptInput,
            l.InteractionStepType.MultiTurnContinue,
            l.InteractionStepType.ModelResponseEditor,
            l.InteractionStepType.ModelResponseSelector,
            l.InteractionStepType.QuantitativeModelResponseSelector,
            l.InteractionStepType.TextCollection,
          ],
          [o.ScriptLinterName.ChatBadWordsLinter]: [
            l.InteractionStepType.PromptInput,
            l.InteractionStepType.MultiTurnContinue,
            l.InteractionStepType.ModelResponseEditor,
            l.InteractionStepType.ModelResponseSelector,
            l.InteractionStepType.QuantitativeModelResponseSelector,
            l.InteractionStepType.TextCollection,
            l.InteractionStepType.TextCollectionPerResponse,
          ],
          [o.ScriptLinterName.ChatSemanticSimilarityLinter]: [
            l.InteractionStepType.PromptInput,
            l.InteractionStepType.MultiTurnContinue,
            l.InteractionStepType.ModelResponseEditor,
            l.InteractionStepType.TextCollection,
          ],
          [o.ScriptLinterName.ChatGoogleTranslateDetectionLinter]: [
            l.InteractionStepType.PromptInput,
            l.InteractionStepType.ModelResponseEditor,
          ],
          [o.ScriptLinterName.ChatMultiTurnResponseSimilarityLinter]: [
            l.InteractionStepType.PromptInput,
            l.InteractionStepType.MultiTurnContinue,
            l.InteractionStepType.ModelResponseEditor,
          ],
          [o.ScriptLinterName.ChatURLExistsLinter]: [
            l.InteractionStepType.PromptInput,
            l.InteractionStepType.MultiTurnContinue,
            l.InteractionStepType.TextCollection,
            l.InteractionStepType.TextCollectionPerResponse,
          ],
          [o.ScriptLinterName.ChatPromptResponseWordCountDiffLinter]: [
            l.InteractionStepType.ModelResponseEditor,
          ],
          [o.ScriptLinterName.ChatSphereExecutionOutputLinter]: [
            l.InteractionStepType.TextCollection,
            l.InteractionStepType.ModelResponseEditor,
          ],
          [o.ScriptLinterName.BeeCustomLinter]: [
            l.InteractionStepType.ModelResponseEditor,
            l.InteractionStepType.TextCollection,
          ],
          [o.ScriptLinterName.ChatValidLikertScoreLinter]: [
            l.InteractionStepType.TextCollection,
          ],
          [o.ScriptLinterName.ChatJustificationLikertMatchMLLinter]: [
            l.InteractionStepType.ModelResponseSelector,
            l.InteractionStepType.ModelResponseRanking,
            l.InteractionStepType.TextCollection,
            l.InteractionStepType.QuantitativeModelResponseSelector,
          ],
          [o.ScriptLinterName.ChatNightingaleCustomizedLinter]: [
            l.InteractionStepType.TextCollection,
          ],
          [o.ScriptLinterName.ChatNightingaleArchetypeDiversityLinter]: [
            l.InteractionStepType.NER,
          ],
          [o.ScriptLinterName.ChatNightingaleGoalAlignmentLinter]: [
            l.InteractionStepType.PromptInput,
            l.InteractionStepType.ModelResponseEditor,
            l.InteractionStepType.MultiTurnContinue,
          ],
          [o.ScriptLinterName.ChatNightingalePlagiarismLinter]: [
            l.InteractionStepType.ModelResponseEditor,
          ],
          [o.ScriptLinterName.ChatNightingaleReferenceLinter]: [
            l.InteractionStepType.ModelResponseEditor,
          ],
          [o.ScriptLinterName.ChatNightingaleValidateArchetypeLinter]: [
            l.InteractionStepType.TextCollection,
          ],
          [o.ScriptLinterName.ChatNightingaleWordCountLinter]: [
            l.InteractionStepType.NER,
          ],
          [o.ScriptLinterName.ChatPromptComparisonToSearchResult]: [
            l.InteractionStepType.PromptInput,
            l.InteractionStepType.MultiTurnContinue,
          ],
          [o.ScriptLinterName.ChatBulbaFactualityLinter]: [
            l.InteractionStepType.TextCollection,
          ],
          [o.ScriptLinterName.ChatNERSentenceLinter]: [
            l.InteractionStepType.NER,
          ],
          [o.ScriptLinterName.ChatBulbaLikertResponseValidator]: [
            l.InteractionStepType.TextCollection,
          ],
          [o.ScriptLinterName.GrammarLinter]: [
            l.InteractionStepType.PromptInput,
            l.InteractionStepType.MultiTurnContinue,
            l.InteractionStepType.ModelResponseEditor,
            l.InteractionStepType.TextCollection,
          ],
          [o.ScriptLinterName.ContradictionsLinter]: [
            l.InteractionStepType.PromptInput,
            l.InteractionStepType.MultiTurnContinue,
            l.InteractionStepType.ModelResponseEditor,
            l.InteractionStepType.TextCollection,
          ],
          [o.ScriptLinterName.SpamLinter]: [
            l.InteractionStepType.PromptInput,
            l.InteractionStepType.MultiTurnContinue,
            l.InteractionStepType.ModelResponseEditor,
            l.InteractionStepType.TextCollection,
          ],
          [o.ScriptLinterName.ToxicityLinter]: [
            l.InteractionStepType.PromptInput,
            l.InteractionStepType.MultiTurnContinue,
            l.InteractionStepType.ModelResponseEditor,
            l.InteractionStepType.TextCollection,
          ],
          [o.ScriptLinterName.MultilingualToxicityLinter]: [
            l.InteractionStepType.PromptInput,
            l.InteractionStepType.MultiTurnContinue,
            l.InteractionStepType.ModelResponseEditor,
            l.InteractionStepType.TextCollection,
          ],
          [o.ScriptLinterName.ChatJsonataCustomLinter]: p,
          [o.ScriptLinterName.ChatRobotsValidationCustomLinter]: u,
          [o.ScriptLinterName.ChatMultiReplicaJsonataCustomLinter]: p,
          [o.ScriptLinterName.ChatLazarusMathTopicsLinter]: [
            l.InteractionStepType.TextCollection,
          ],
          [o.ScriptLinterName.ChatZipFileContentsLinter]: [
            l.InteractionStepType.TextCollection,
          ],
          [o.ScriptLinterName.ChatCustomEndpointLinter]: [
            l.InteractionStepType.TextCollection,
          ],
          [o.ScriptLinterName.ChatPreventAnswerBasedOnContributorWt]: [
            l.InteractionStepType.TextCollection,
          ],
          [o.ScriptLinterName.ChatDolphinPromptImage]: [
            l.InteractionStepType.TextCollection,
          ],
          [o.ScriptLinterName.NightingaleCheckCorrectnessClassification]: [
            l.InteractionStepType.TextCollectionPerResponse,
          ],
          [o.ScriptLinterName.ChatJustificationMinWords]: [
            l.InteractionStepType.ModelResponseSelector,
            l.InteractionStepType.QuantitativeModelResponseSelector,
          ],
          [o.ScriptLinterName.NightingaleResponseCoherence]: [
            l.InteractionStepType.TextCollectionPerResponse,
            l.InteractionStepType.ModelResponseSelector,
            l.InteractionStepType.QuantitativeModelResponseSelector,
          ],
          [o.ScriptLinterName.ChatNightingaleRatingConsistencyLinter]: [
            l.InteractionStepType.TextCollectionPerResponse,
          ],
          [o.ScriptLinterName.ChatNightingaleRankingConsistencyLinter]: [
            l.InteractionStepType.ModelResponseSelector,
            l.InteractionStepType.QuantitativeModelResponseSelector,
          ],
          [o.ScriptLinterName.ChatBulbaLockFieldLinter]: [
            l.InteractionStepType.TextCollection,
          ],
          [o.ScriptLinterName.ChatPromptModelAgreementLinter]: [
            l.InteractionStepType.PromptInput,
          ],
          [o.ScriptLinterName.ChatBulbaCodeEvalCodePresentLinter]: [
            l.InteractionStepType.TextCollectionPerResponse,
          ],
          [o.ScriptLinterName.ChatImageNSFWLinter]: [
            l.InteractionStepType.PromptInput,
            l.InteractionStepType.MultiTurnContinue,
            l.InteractionStepType.TextCollection,
          ],
          [o.ScriptLinterName.ChatMRSSphereExecutionRelevanceLinter]: [
            l.InteractionStepType.TextCollectionPerResponse,
            l.InteractionStepType.TextCollection,
          ],
          [o.ScriptLinterName.ChatGoogleSearchPlagiarismLinter]: [
            l.InteractionStepType.PromptInput,
            l.InteractionStepType.MultiTurnContinue,
            l.InteractionStepType.ModelResponseEditor,
            l.InteractionStepType.TextCollection,
          ],
          [o.ScriptLinterName.ChatMultiModalRelevanceLinter]: [
            l.InteractionStepType.PromptInput,
            l.InteractionStepType.MultiTurnContinue,
            l.InteractionStepType.ModelResponseEditor,
          ],
          [o.ScriptLinterName.ChatLatexParsingLinter]: [
            l.InteractionStepType.PromptInput,
            l.InteractionStepType.MultiTurnContinue,
            l.InteractionStepType.ModelResponseEditor,
          ],
          [o.ScriptLinterName.ChatBlockMMMULinter]: [
            l.InteractionStepType.PromptInput,
            l.InteractionStepType.MultiTurnContinue,
          ],
          [o.ScriptLinterName.ChatAutoraterPlagiarismLinter]: [
            l.InteractionStepType.PromptTextCollection,
            l.InteractionStepType.TextCollectionPerResponse,
            l.InteractionStepType.QuantitativeModelResponseSelector,
          ],
          [o.ScriptLinterName.ChatLambdaUnitTestExecutionLinter]: [
            l.InteractionStepType.TextCollection,
          ],
        };
      var m;
      (t.ChatTaskLinterToSupportedStepTypes = d),
        (function (e) {
          (e.LessThan = "lt"), (e.GreaterThanOrEqualTo = "gte");
        })(m || (m = {}));
      const h = s.z.object({
          userAgents: s.z
            .array(s.z.string())
            .describe(
              "User agents to validate against robots.txt. You can add them one by one or comma separated."
            ),
          userAgentStrategy: s.z
            .nativeEnum(o.UserAgentsStrategy)
            .describe(
              "Specify 'every' if all user agents must be able to crawl and some if it's ok a subset of these."
            ),
          urlJSONataExpression: s.z
            .string()
            .describe(
              "JSONata expression to be get the url to check against robots.txt with the user agents."
            ),
          debugMode: s.z
            .boolean()
            .describe(
              "ENG Only - Enable when you need to debug the linter via datadog logs"
            )
            .optional(),
        }),
        f = s.z.object({
          expressions: s.z
            .array(s.z.string())
            .describe(
              "JSONata expressions to be evaluated against full linter context object. Please remember each expression should return an explicit true or false, value otherwise this linter will not work as intended. Linter will fire if the end result is true."
            ),
          operator: s.z
            .nativeEnum(o.RegexMatches)
            .describe(
              "Specify 'every' if all expressions must match; Specify 'some' if any expression must match; Specify 'none' if no expressions must match."
            ),
          messageExpression: s.z
            .string()
            .describe(
              "JSONata expression to be evaluated to create a personal linter message"
            )
            .optional(),
          debugMode: s.z
            .boolean()
            .describe(
              "ENG Only - Enable when you need to debug the linter via datadog logs"
            )
            .optional(),
        }),
        g = {
          [o.ScriptLinterName.GrammarLinter]: s.z.object({
            thresholdScore: s.z
              .number()
              .gte(0)
              .lte(1)
              .describe("The threshold score for the linter to flag an error."),
            fieldId: s.z
              .string()
              .describe(
                "Specify the fieldId if the rule is intended to be applied to any textcollection steps."
              )
              .optional(),
          }),
          [o.ScriptLinterName.ContradictionsLinter]: s.z.object({
            thresholdScore: s.z
              .number()
              .gte(0)
              .lte(1)
              .describe("The threshold score for the linter to flag an error."),
            fieldId: s.z
              .string()
              .describe(
                "Specify the fieldId if the rule is intended to be applied to any textcollection steps."
              )
              .optional(),
          }),
          [o.ScriptLinterName.SpamLinter]: s.z.object({
            thresholdScore: s.z
              .number()
              .gte(0)
              .lte(1)
              .describe("The threshold score for the linter to flag an error."),
            fieldId: s.z
              .string()
              .describe(
                "Specify the fieldId if the rule is intended to be applied to any textcollection steps."
              )
              .optional(),
          }),
          [o.ScriptLinterName.ToxicityLinter]: s.z.object({
            thresholdScore: s.z
              .number()
              .gte(0)
              .lte(1)
              .describe("The threshold score for the linter to flag an error."),
            fieldId: s.z
              .string()
              .describe(
                "Specify the fieldId if the rule is intended to be applied to any textcollection steps."
              )
              .optional(),
          }),
          [o.ScriptLinterName.MultilingualToxicityLinter]: s.z.object({
            thresholdScore: s.z
              .number()
              .gte(0)
              .lte(1)
              .describe("The threshold score for the linter to flag an error."),
            fieldId: s.z
              .string()
              .describe(
                "Specify the fieldId if the rule is intended to be applied to any textcollection steps."
              )
              .optional(),
          }),
          [o.ScriptLinterName.ChatJsonataCustomLinter]: f,
          [o.ScriptLinterName.ChatRobotsValidationCustomLinter]: h,
          [o.ScriptLinterName.ChatMultiReplicaJsonataCustomLinter]: f,
          [o.ScriptLinterName.ChatLazarusMathTopicsLinter]: s.z.object({
            limit: s.z
              .number()
              .describe(
                "Limits the number of topic combinations. Default is 5."
              )
              .optional(),
          }),
          [o.ScriptLinterName.ChatZipFileContentsLinter]: s.z.object({
            fieldId: s.z
              .string()
              .describe("Specify the fieldId of the desired file upload step."),
            minNumOfFiles: s.z
              .number()
              .describe("Minimum number of files in the zip file.")
              .optional(),
            requiredFileTypes: s.z
              .array(s.z.string())
              .describe(
                'List of required file types. This checks that there is at least one occurrence of the file type. Please input each type as a file extension (e.g. ".mp4", ".tar", etc)'
              )
              .optional(),
          }),
          [o.ScriptLinterName.ChatCustomEndpointLinter]: s.z.object({
            endpointType: s.z.nativeEnum(a.CustomEndpointType),
            modelInputJsonata: s.z
              .string()
              .describe(
                "JSONata expression for the value that will be passed into the model."
              ),
            userOutputJsonata: s.z
              .string()
              .describe(
                "JSONata expression for the user provided value. This will be compared against the model output."
              ),
          }),
          [o.ScriptLinterName.ChatPreventAnswerBasedOnContributorWt]:
            s.z.object({
              workerTeamsToInclude: s.z
                .array(s.z.string())
                .describe(
                  "List of worker teams whose contributors should be answering a specific field"
                ),
              workerTeamsToExclude: s.z
                .array(s.z.string())
                .describe(
                  "List of worker teams whose contributors should not be answering a specific field"
                ),
              fieldId: s.z.string().describe("Specify the fieldId to check"),
            }),
          [o.ScriptLinterName.ChatDolphinPromptImage]: s.z.object({}),
          [o.ScriptLinterName.NightingaleCheckCorrectnessClassification]:
            s.z.object({}),
          [o.ScriptLinterName.ChatJustificationMinWords]: s.z.object({
            minCharacterLength: s.z
              .number()
              .describe(
                "The minimum number of characters required in the response justification."
              )
              .optional(),
            maxCharacterLength: s.z
              .number()
              .describe(
                "The maximum number of characters required in the response justification."
              )
              .optional(),
            minWordCount: s.z
              .number()
              .describe(
                "The minimum number of words required in the response justification"
              )
              .optional(),
            maxWordCount: s.z
              .number()
              .describe(
                "The maximum number of words required in the response justification."
              )
              .optional(),
          }),
          [o.ScriptLinterName.NightingaleResponseCoherence]: s.z.object({
            checkCompleteRange: s.z.boolean(),
          }),
          [o.ScriptLinterName.ChatNightingaleRankingConsistencyLinter]:
            s.z.object({}),
          [o.ScriptLinterName.ChatNightingaleRatingConsistencyLinter]:
            s.z.object({}),
          [o.ScriptLinterName.ChatMissingResponseLinter]: s.z.object({}),
          [o.ScriptLinterName.ChatMLSingletonQualityMetricLinter]: s.z.object({
            qualityMetricType: s.z.nativeEnum(a.SingletonQualityMetricType),
            lowerBoundScore: s.z.number().gte(0).lte(1),
            thresholdScore: s.z
              .number()
              .gte(0)
              .lte(1)
              .describe("The threshold score for the linter to flag an error."),
            fieldId: s.z
              .string()
              .describe(
                "Specify the fieldId if the rule is intended to be applied to any textcollection steps."
              )
              .optional(),
          }),
          [o.ScriptLinterName.ChatMLPromptResponsePairQualityMetricLinter]:
            s.z.object({
              qualityMetricType: s.z.nativeEnum(
                a.PromptResponsePairQualityMetricType
              ),
              lowerBoundScore: s.z.number().gte(0).lte(1),
              thresholdScore: s.z
                .number()
                .gte(0)
                .lte(1)
                .describe(
                  "The threshold score for the linter to flag an error."
                ),
              fieldId: s.z
                .string()
                .describe(
                  "Specify the fieldId if the rule is intended to be applied to any textcollection steps."
                )
                .optional(),
            }),
          [o.ScriptLinterName.ChatRegexLinter]: s.z.object({
            rules: s.z
              .array(s.z.string())
              .describe(
                "Regex expressions to match. You can use this [tool](https://regex101.com/) to test (using ECMAScript flavor)."
              ),
            matches: s.z
              .nativeEnum(o.RegexMatches)
              .describe(
                "Specify 'every' if all rules must match; Specify 'any' if any rule must match; Specify 'none' if no rules must match."
              ),
            regexFlags: s.z
              .string()
              .describe(
                "Learn more about flags [here](https://javascript.info/regexp-introduction#flags)"
              )
              .optional(),
            exceptions: s.z
              .array(s.z.string())
              .describe("Regex expressions to exclude from the match of rules.")
              .optional(),
            fieldId: s.z
              .string()
              .describe(
                "Specify the fieldId if the rule is intended to be applied to any textcollection steps."
              )
              .optional(),
          }),
          [o.ScriptLinterName.ChatGPTZeroLinter]: s.z.object({
            average_generated_prob: s.z.number().min(0).max(1).optional(),
            completely_generated_prob: s.z.number().min(0).max(1).optional(),
            overall_burstiness: s.z.number().optional(),
            minTokensToApply: s.z.number().optional(),
            fieldId: s.z
              .string()
              .describe(
                "Specify the fieldId if the rule is intended to be applied to any textcollection steps."
              )
              .optional(),
          }),
          [o.ScriptLinterName.ChatMinEditDistanceLinter]: s.z.object({
            minRelativeLevenshteinDistance: s.z
              .number()
              .gte(0)
              .lte(1)
              .describe(
                'Flags if the distance of the current text v.s. the initial text is less than "minRelativeLevenshteinDistance".'
              ),
            maxRelativeLevenshteinDistance: s.z
              .number()
              .gte(0)
              .lte(1)
              .describe(
                '[BETA] Flags if the distance of the current text v.s. the initial text is more than "maxRelativeLevenshteinDistance".'
              )
              .optional(),
            minLengthToApply: s.z
              .number()
              .describe(
                "If the response length is less than this value, the lint rule will not apply."
              )
              .optional(),
            minWordsToApply: s.z
              .number()
              .describe(
                "If the text has less words than the threshold the linter won't flag anything."
              )
              .optional(),
            ignoreMarkdownForDistanceCalculation: s.z
              .boolean()
              .describe(
                "If true, strip markdown formatting before checking distance"
              )
              .optional(),
            numChunks: s.z
              .number()
              .gte(1)
              .describe(
                "The number of chunks the text is split up into when computing the distance. If any of the chunks are too similar, we will flag."
              )
              .optional(),
          }),
          [o.ScriptLinterName.ChatUniqueResponseLinter]: s.z.object({
            minLengthToApply: s.z
              .number()
              .describe(
                "If the response length is less than this value, the lint rule will not apply."
              )
              .optional(),
            minRelativeLevenshteinDistance: s.z
              .number()
              .describe(
                "The lint rule will be triggered if the Levenshtein distance between any of the previous response texts and the current response is less than the specified value."
              )
              .optional(),
            compareDifferentAttempters: s.z
              .boolean()
              .describe(
                "Whether or not to consider responses from other taskers"
              )
              .optional(),
            attemptsLimit: s.z
              .number()
              .lte(5e3)
              .describe("Number of attempts to look back. Default: 500.")
              .optional(),
            addPrevAttemptsToMessage: s.z
              .boolean()
              .describe(
                "Whether to show the previously submitted text in the linter message."
              )
              .optional(),
            fieldId: s.z
              .string()
              .describe("TextCollection field Id.")
              .optional(),
            reviewLevels: s.z
              .array(s.z.nativeEnum(i.ReviewLevel))
              .describe(
                "The review levels to filter the historically submitted attempts by."
              )
              .optional(),
            windowDays: s.z
              .number()
              .describe("# days to look back. Default: 21")
              .optional(),
            useLevenshtein: s.z
              .boolean()
              .describe(
                "Default: false. If set to true, the texts are compared by relative levenshtein distance. (When using this config, try to minimize the number of attempts, as LD takes longer to compare, which can impact the quickness of the linter)"
              )
              .optional(),
            checkImageDB: s.z
              .boolean()
              .describe(
                "Default: true. If set to false, the url is not checked against the image database for being a duplicate."
              )
              .optional(),
            occurrencesAllowed: s.z
              .number()
              .default(0)
              .describe(
                "Default: 0. The number of occurrences allowed for the flagged duplicated previous responses."
              ),
            additionalProjectIds: s.z
              .string()
              .describe(
                "Project IDs other than the current project to also dedupe against"
              )
              .optional(),
            csvPathForResponses: s.z
              .string()
              .describe(
                "Uses CSV file (headerless, single-column) as the source of responses to compare against, instead of attempts. File link should be public."
              )
              .optional(),
          }),
          [o.ScriptLinterName.ChatCompletedTasksUniqueResponseLinter]:
            s.z.object({
              minLengthToApply: s.z
                .number()
                .describe(
                  "If the response length is less than this value, the lint rule will not apply."
                )
                .optional(),
              minRelativeLevenshteinDistance: s.z
                .number()
                .describe(
                  "The lint rule will be triggered if the Levenshtein distance between any of the previous response texts and the current response is less than the specified value."
                )
                .optional(),
              tasksLimit: s.z
                .number()
                .lte(5e3)
                .describe("Number of tasks to look back. Default: 500.")
                .optional(),
              addPrevTextToMessage: s.z
                .boolean()
                .describe(
                  "Whether to show the previously submitted text in the linter message."
                )
                .optional(),
              fieldId: s.z
                .string()
                .describe("TextCollection field Id.")
                .optional(),
              windowDays: s.z
                .number()
                .describe("# days to look back. Default: 21")
                .optional(),
              useLevenshtein: s.z
                .boolean()
                .describe(
                  "Default: false. If set to true, the texts are compared by relative levenshtein distance. (When using this config, try to minimize the number of attempts, as LD takes longer to compare, which can impact the quickness of the linter)"
                )
                .optional(),
              checkImageDB: s.z
                .boolean()
                .describe(
                  "Default: true. If set to false, the url is not checked against the image database for being a duplicate."
                )
                .optional(),
              additionalProjectIds: s.z
                .string()
                .describe(
                  "Project IDs other than the current project to also dedupe against"
                )
                .optional(),
            }),
          [o.ScriptLinterName.ChatPromptResponsePairLinter]: s.z.object({
            promptTemplate: s.z
              .string()
              .describe(
                "Reference the response as {{responseText}} and prompt as {{promptText}}. For TextCollection steps, reference the field_id in double brackets {{}}, such as {{ranking_reasoning}}."
              ),
            systemPrompt: s.z
              .string()
              .describe(
                'System prompt helps set the behavior of GPT (e.g., "You are a helpful assistant.") and can typically be left blank. See the [OpenAI docs](https://platform.openai.com/docs/guides/gpt/chat-completions-api)'
              )
              .optional(),
            overriddenModelParams: s.z
              .object({
                model: s.z.string(),
                max_tokens: s.z.number(),
                temperature: s.z.number(),
                tools: s.z.array(s.z.string()).optional(),
              })
              .describe(
                "If the prompt works on gpt-3.5-turbo, we'd suggest using gpt-3.5-turbo. If it does not work, use gpt-4."
              )
              .optional(),
            passIfNumericOutputMatches: s.z
              .object({
                comparator: s.z.nativeEnum(m),
                threshold: s.z.number(),
              })
              .describe(
                "Used in combination with the threshold to determine whether the response passes or fails"
              )
              .optional(),
            passIfStringOutputMatches: s.z
              .object({
                regexMatch: s.z.string(),
                flags: s.z.string().optional(),
              })
              .describe(
                "If the GPT output matches this regular expression, the response will pass. Use a [regex tester](https://regex101.com/) to test your regex."
              )
              .optional(),
            showModelOutput: s.z
              .boolean()
              .describe(
                "Toggle on if you want to show the GPT model output to taskers. Please first test the linter to validate if the GPT output will be helpful to taskers."
              )
              .optional(),
            modelOutputRegexMatch: s.z
              .string()
              .describe(
                "If you only want to output part of the GPT output, input the regex to use for extracting the output. Use a [regex tester](https://regex101.com/) to test your regex."
              )
              .optional(),
            fieldId: s.z
              .string()
              .describe(
                "If running over any TextCollection steps, specify the fieldId in the TextCollection step to apply to."
              )
              .optional(),
            minTurnNumber: s.z
              .number()
              .describe(
                "The minimum number of turns this linter should apply to."
              )
              .optional(),
            maxTurnNumber: s.z
              .number()
              .describe(
                "The maximum number of turns this linter should apply to."
              )
              .optional(),
            debugMode: s.z
              .boolean()
              .describe(
                "ENG Only - Enable when you need to debug the linter via datadog logs"
              )
              .optional(),
            sendImageAttachments: s.z
              .boolean()
              .describe(
                "Sends image attachments in content to model endpoint for evaluation, default off."
              )
              .optional(),
          }),
          [o.ScriptLinterName.ChatTextLengthLinter]: s.z.object({
            runOnReferenceTextContent: s.z
              .boolean()
              .describe(
                "If selected, the linter will run on the reference text content and NOT on associated step. (Applies only for Prompt Input & Multi turn continue steps)"
              )
              .optional(),
            runOnJustification: s.z
              .boolean()
              .describe(
                "If selected, the linter will run on the justification (Applies only for Model Response Selector)"
              )
              .optional(),
            minCharacterLength: s.z
              .number()
              .describe(
                "The minimum number of characters required in the prompt/response."
              )
              .optional(),
            maxCharacterLength: s.z
              .number()
              .describe(
                "The maximum number of characters required in the prompt/response."
              )
              .optional(),
            minWordCount: s.z
              .number()
              .describe(
                "The minimum number of words required in the prompt/response."
              )
              .optional(),
            maxWordCount: s.z
              .number()
              .describe(
                "The maximum number of words required in the prompt/response."
              )
              .optional(),
            fieldId: s.z
              .string()
              .describe(
                "Specify the fieldId if the rule is intended to be applied to any textcollection steps."
              )
              .optional(),
            variableRules: s.z
              .array(
                s.z
                  .object({
                    variableName: s.z.string(),
                    variableValue: s.z
                      .string()
                      .describe("Supports Regex statements"),
                    caseSensitive: s.z.boolean().optional(),
                  })
                  .describe(
                    'When defined, linter will only be applied for the tasks with the entered variable name and value pairs. i.e. variableName: "category", variableValue: "complex" will only apply the linter to the tasks with task.params.templateVariables.category = "complex"'
                  )
              )
              .optional(),
          }),
          [o.ScriptLinterName.ChatCorrectLanguageLinter]: s.z.object({
            language: s.z.string(),
            minCharsToApply: s.z.number().optional(),
            minTokensToApply: s.z.number().optional(),
            confidence: s.z.number().optional(),
            fieldId: s.z.string().optional(),
          }),
          [o.ScriptLinterName.ChatNGramDiversityLinter]: s.z.object({
            maxMatches: s.z
              .number()
              .describe(
                'If there are more than "maxMatches" ngram tokens from the previous submitted text, the linter would flag an error.'
              ),
            numAttempts: s.z
              .number()
              .describe(
                "Number of previous submitted task attempts to look back."
              ),
            n: s.z
              .number()
              .describe(
                'The "n" of n-gram. Learn more about how it works here (https://en.wikipedia.org/wiki/N-gram)'
              ),
            ignoreStopWords: s.z
              .boolean()
              .describe(
                "If this is enabled, stop words will not be considered for n-gram blocking. For example, if you have Ignore Stop Words enabled, for a sentence like 'the dog jumped over the cat', the 2-grams returned would be [ 'dog jumped', 'jumped over', 'over cat' ]. If Ignore Stop Words was disabled, the 2-grams would be [ 'dog jumped', 'jumped over', 'over the', 'the cat' ]."
              )
              .optional(),
            additionalStopWords: s.z
              .array(s.z.string())
              .describe(
                "Additional stop words to be added in addition to the default list here (https://dashboard.scale.com/corp/rapid/stop-words)."
              )
              .optional(),
            fieldId: s.z
              .string()
              .describe(
                "Specify the fieldId if the rule is intended to be applied to any textcollection steps."
              )
              .optional(),
            wordList: s.z
              .array(s.z.string())
              .describe(
                'If this is populated, the n-gram linter will only consider words in this list, instead of all n-grams. The words in this list must match the N of the n-gram to be considered (e.g., if you have a 2-gram, and put down "dog", "fluffy dog" would not be counted, and taskers could use the word "fluffy dog" as much as they wanted). Typically this is used to block a targeted list of phrases from showing up too frequently. For example, by setting n = 2, and putting down "write a", you can block taskers from writing "write a" too frequently.'
              )
              .optional(),
            ignoreCodeBlocks: s.z
              .boolean()
              .describe(
                "If checked, the linter will ignore the code block present in the field id provided"
              )
              .optional(),
          }),
          [o.ScriptLinterName.ChatBadWordsLinter]: s.z.object({
            flagProfanity: s.z
              .boolean()
              .describe(
                "Default true. If false (unchecked), ignores the default list and only the flaggedWords list will be considered profanity to be linted against."
              )
              .optional(),
            flaggedWords: s.z
              .array(s.z.string())
              .describe(
                'The linter contains a default list of banned words hardcoded in the codebase. Use ""flaggedWords"" to include more words to be banned.'
              )
              .optional(),
            wordBreak: s.z
              .boolean()
              .describe(
                "Set to true by default, and what it means is that only the exact words matched in the bad word list will be flagged. A random word including consecutive characters that form a bad word won't be flagged."
              )
              .optional(),
            exceptions: s.z
              .array(s.z.string())
              .describe("Whitelist words")
              .optional(),
            fieldId: s.z
              .string()
              .describe(
                "Specify the fieldId if the rule is intended to be applied to any textcollection steps."
              )
              .optional(),
          }),
          [o.ScriptLinterName.ChatSemanticSimilarityLinter]: s.z.object({
            thresholds: s.z.array(
              s.z
                .object({
                  threshold: s.z
                    .number()
                    .describe(
                      "The minimum threshold for the linter to flag a prompt towards the similarity count."
                    ),
                  maxPromptsAboveThreshold: s.z
                    .number()
                    .describe(
                      "The maximum number of prompts that can be above the threshold. If the number of prompts above the threshold exceeds this value, the linter will flag an error."
                    ),
                })
                .describe(
                  "The maximum number of prompts that can be above the given threshold. If the number of prompts above the threshold exceeds this value, the linter will flag an error."
                )
            ),
            fieldId: s.z
              .string()
              .describe(
                "Specify the fieldId if the rule is intended to be applied to any textcollection steps."
              )
              .optional(),
          }),
          [o.ScriptLinterName.ChatGoogleTranslateDetectionLinter]: s.z.object({
            minWordsToApply: s.z
              .number()
              .describe(
                "If the text has less words than the threshold the linter won't flag anything."
              )
              .optional(),
            minRelativeLevenshteinDistance: s.z.number(),
            fromLanguage: s.z
              .nativeEnum(o.GoogleTranslationLanguages)
              .describe("Original language of base text"),
            toLanguage: s.z
              .nativeEnum(o.GoogleTranslationLanguages)
              .describe("Language original text will be translated"),
            promptVariable: s.z
              .string()
              .describe(
                "Variable where initial prompt is stored (needed when running this linter on prompt input step)."
              )
              .optional(),
          }),
          [o.ScriptLinterName.ChatMultiTurnResponseSimilarityLinter]:
            s.z.object({
              minWordsToApply: s.z
                .number()
                .describe(
                  "If the text has less words than the threshold the linter won't flag anything."
                )
                .optional(),
              minRelativeLevenshteinDistance: s.z
                .number()
                .describe(
                  'Flags if the distance of the current text v.s. the previously submitted text is less than "minRelativeLevenshteinDistance".'
                ),
            }),
          [o.ScriptLinterName.ChatURLExistsLinter]: s.z.object({
            liveCheck: s.z
              .boolean()
              .describe(
                "Whether to ping the URL and verify the URL is healthy."
              )
              .optional(),
            fieldId: s.z
              .string()
              .describe("The text collection field id.")
              .optional(),
            checkFirstTurn: s.z
              .boolean()
              .describe(
                "Whether to only check the first prompt and not subsequent turns"
              )
              .optional(),
            blackListDomainsFileUrl: s.z
              .string()
              .describe(
                "A public file URL where file contains a list of domains in each line"
              )
              .optional(),
          }),
          [o.ScriptLinterName.ChatPromptResponseWordCountDiffLinter]:
            s.z.object({
              minWordsToApply: s.z
                .number()
                .describe(
                  "If the text has less words than the threshold the linter won't flag anything."
                )
                .optional(),
              maxWordsCountMultiplier: s.z.number().min(1),
              minWordsCountMultiplier: s.z.number().min(0).max(1),
            }),
          [o.ScriptLinterName.ChatValidLikertScoreLinter]: s.z
            .object({
              fieldId: s.z
                .string()
                .describe(
                  'The field id for field containing the Likert score (e.g. "response_ranking").'
                ),
            })
            .optional(),
          [o.ScriptLinterName.ChatJustificationLikertMatchMLLinter]: s.z.object(
            {
              useMagnitude: s.z
                .boolean()
                .describe(
                  "If checked, the linter will check if the magnitude of the Likert scores matches the ML model output. If not, it will just use the direction."
                )
                .optional(),
              likertScaleSet: s.z
                .array(s.z.string())
                .describe("Add a personalized mapping of you likert scale")
                .optional(),
              useFlamingoPreference: s.z
                .boolean()
                .describe(
                  "If checked this linter will run based on Flamingo Preference logic"
                )
                .optional(),
            }
          ),
          [o.ScriptLinterName.ChatSphereExecutionOutputLinter]: s.z.object({
            codeFieldId: s.z
              .string()
              .describe(
                "The field id for field containing the code to run. This is REQUIRED."
              ),
            concatCodeFieldIds: s.z
              .array(s.z.string())
              .describe(
                "The field ids for other fields containing code to run. This is useful if you want to run multiple code snippets together that will be concatenated together. This is OPTIONAL."
              )
              .optional(),
            testCodeFieldId: s.z
              .string()
              .describe(
                "The field id for field containing test cases that run in a separate file. This is OPTIONAL."
              )
              .optional(),
            outputFieldId: s.z
              .string()
              .describe(
                "The field id for field containing the code output. If this isn't provided, the linter just checks if the code runs."
              )
              .optional(),
            sphereProjectId: s.z
              .string()
              .describe(
                "The sphere project to run the code in (this is mutually exclusive with languageToSphereProjectIdMap and taskLanguageMetadataVariable). If this and the language are not specified, the sphere project id is pulled dynamically from the sphere engine workspace field."
              )
              .optional(),
            language: s.z
              .nativeEnum(o.AcceptedSphereLanguage)
              .describe(
                "(this is mutually exclusive with languageToSphereProjectIdMap and taskLanguageMetadataVariable) If no sphere project id is specified, then a sphere project of the given language is\n        used. Likewise, if no sphereProjectCodeFilePath is provided, then the default file for\n        the given language is used. It is recommended to specify the sphere project instead of\n        going down this route to ensure the needed imports are present and the environment set\n        up is correct. This all implies that if you want to use a custom sphere project, you must\n        clear the language field."
              )
              .optional(),
            languageToSphereProjectIdMap: s.z
              .any()
              .describe(
                '(this is mutually exclusive with sphereProjectId and language) This is a map of language to sphere project id. E.g. {"python": "<python_workspace>", "java": "<java_workspace>"}'
              )
              .optional(),
            taskLanguageMetadataVariable: s.z
              .string()
              .describe(
                "(this is mutually exclusive with sphereProjectId and language) This is dynamically used to determine the coding language for languageToSphereProjectIdMap. E.g. this should be python, java, etc. and should be in that languageToSphereProjectIdMap"
              )
              .optional(),
            scenarioName: s.z
              .string()
              .describe(
                "Defaults to 'run'. Only add a value to this field if you understand scenarios in sphere engine."
              )
              .optional(),
            sphereProjectCodeFilePath: s.z
              .string()
              .describe(
                "The file path to the code file to run. If not provided, the default file for the given language is used."
              )
              .optional(),
            sphereProjectTestFilePath: s.z
              .string()
              .describe(
                "The file path to the test file to run. If not provided, the default test file for the given language is used.\n          This file is only relevant if you provide a testCodeFieldId."
              )
              .optional(),
            useMetadataOutput: s.z
              .boolean()
              .describe(
                "If checked, the linter will use the metadata variable (in conjunction with metadataVariable) to determine the test code"
              )
              .optional(),
            metadataVariable: s.z
              .string()
              .describe(
                "The metadata variable to use to determine the test code"
              )
              .optional(),
            postprocessMarkdown: s.z
              .boolean()
              .describe(
                "If checked, this will remove triple backticks and the language from the code and test text fields before\n        running the linter."
              )
              .optional(),
          }),
          [o.ScriptLinterName.BeeCustomLinter]: s.z.object({
            lintForPromptCategorization: s.z
              .boolean()
              .describe(
                "lintForPromptCategorization is true, linter will execute lint on Prompt Categorization field"
              )
              .optional(),
          }),
          [o.ScriptLinterName.ChatNightingaleCustomizedLinter]: s.z.object({
            userStepTemplate: s.z.string().optional(),
            agentStepTemplate: s.z.string().optional(),
          }),
          [o.ScriptLinterName.ChatNightingaleArchetypeDiversityLinter]:
            s.z.object({
              labels: s.z.array(s.z.string()).describe("Labels in NER step"),
              minLabelPerTurn: s.z
                .array(s.z.number())
                .describe(
                  "Minimun count per label (Counts will be mapped in accordance to category position)"
                ),
              maxLabelPerTurn: s.z
                .array(s.z.number())
                .describe(
                  "Max count per label (Counts will be mapped in accordance to category position)"
                )
                .optional(),
              applyToAllLabels: s.z.boolean().optional(),
            }),
          [o.ScriptLinterName.ChatNightingaleGoalAlignmentLinter]: s.z.object({
            promptAlignmentTemplate: s.z.string(),
            dialogueAlignmentTemplate: s.z.string(),
          }),
          [o.ScriptLinterName.ChatNightingalePlagiarismLinter]: s.z.object({
            nGram: s.z.number(),
            maxAllowedRepetition: s.z.number(),
            minWordsToApply: s.z
              .number()
              .describe("Minimum plagiarized words needed to flag"),
          }),
          [o.ScriptLinterName.ChatNightingaleReferenceLinter]: s.z.object({
            referenceTemplate: s.z.string(),
          }),
          [o.ScriptLinterName.ChatNightingaleValidateArchetypeLinter]:
            s.z.object({}),
          [o.ScriptLinterName.ChatNightingaleWordCountLinter]: s.z.object({
            categories: s.z.array(s.z.string()).describe("Labels in NER step"),
            minCategoryPerTurn: s.z
              .array(s.z.number())
              .describe(
                "Minimun count per category (Counts will be mapped in accordance to category position)"
              ),
            maxCategoryPerTurn: s.z
              .array(s.z.number())
              .describe(
                "Max count per category (Counts will be mapped in accordance to category position)"
              )
              .optional(),
            applyToAllCategories: s.z
              .boolean()
              .describe(
                "Apply min/max word counter to all NER annotations regardless of category"
              )
              .optional(),
          }),
          [o.ScriptLinterName.ChatPromptComparisonToSearchResult]: s.z.object({
            useGPT: s.z.boolean(),
            useLevenshtein: s.z.boolean(),
            threshold: s.z.number(),
          }),
          [o.ScriptLinterName.ChatBulbaFactualityLinter]: s.z.object({}),
          [o.ScriptLinterName.ChatNERSentenceLinter]: s.z.object({
            sentenceDelimiters: s.z
              .array(s.z.string())
              .describe(
                'Please enter any characters that you would like to treat as delimiters of a sentence. Use "\n" for new line.'
              ),
            stopLintingAfterLabel: s.z
              .string()
              .describe(
                'Use if the linter should only fire on the content leading up to and including a specific label (e.g. stop linting after an "inaccurate" label is used). Enter the label name here if applicable.'
              )
              .optional(),
          }),
          [o.ScriptLinterName.ChatBulbaLikertResponseValidator]: s.z.object({}),
          [o.ScriptLinterName.ChatBulbaLockFieldLinter]: s.z.object({
            stepId: s.z
              .string()
              .describe(
                "If this step ID is visible, the given field will be locked"
              ),
            fieldId: s.z.string().describe("The field ID to lock"),
          }),
          [o.ScriptLinterName.ChatPromptModelAgreementLinter]: s.z.object({
            strategyName: s.z.string().optional(),
            modelParams: s.z
              .object({ model: s.z.string().optional() })
              .optional(),
            passIfAgree: s.z.boolean().optional(),
          }),
          [o.ScriptLinterName.ChatBulbaCodeEvalCodePresentLinter]: s.z.object(
            {}
          ),
          [o.ScriptLinterName.ChatImageNSFWLinter]: s.z.object({
            thresholds: s.z
              .object({
                animal_violence: s.z.number().min(0).max(1),
                blood_and_gore: s.z.number().min(0).max(1),
                child_present: s.z.number().min(0).max(1),
                cigarettes_and_tobacco_products: s.z.number().min(0).max(1),
                explosions: s.z.number().min(0).max(1),
                exposed_breasts: s.z.number().min(0).max(1),
                exposed_butts: s.z.number().min(0).max(1),
                genitalia: s.z.number().min(0).max(1),
                guns: s.z.number().min(0).max(1),
                harassment_and_hate_speech: s.z.number().min(0).max(1),
                knives: s.z.number().min(0).max(1),
                marijuana: s.z.number().min(0).max(1),
                other_drugs: s.z.number().min(0).max(1),
                other_weapons: s.z.number().min(0).max(1),
                physical_violence: s.z.number().min(0).max(1),
                sex_toys: s.z.number().min(0).max(1),
                sexual_activity: s.z.number().min(0).max(1),
                suggestive: s.z.number().min(0).max(1),
                is_sensitive: s.z.number().min(0).max(1),
              })
              .describe(
                "Indicate a minimum probability threshold on each risk criteria above which an image will be flagged as unsafe."
              ),
            fieldId: s.z
              .string()
              .describe(
                "Specify the fieldId if the rule is intended to be applied to any textcollection steps."
              )
              .optional(),
          }),
          [o.ScriptLinterName.ChatMRSSphereExecutionRelevanceLinter]:
            s.z.object({
              promptTemplate: s.z
                .string()
                .describe(
                  "Reference the executed code as {{executedCode}} and the model output as {{modelOutput}}. For TextCollection steps, reference the field_id in double brackets {{}}, such as {{ranking_reasoning}}."
                ),
              systemPrompt: s.z
                .string()
                .describe(
                  'System prompt helps set the behavior of GPT (e.g., "You are a helpful assistant.") and can typically be left blank. See the [OpenAI docs](https://platform.openai.com/docs/guides/gpt/chat-completions-api)'
                )
                .optional(),
              overriddenModelParams: s.z
                .object({
                  model: s.z.string(),
                  max_tokens: s.z.number(),
                  temperature: s.z.number(),
                })
                .describe(
                  "If the prompt works on gpt-3.5-turbo, we'd suggest using gpt-3.5-turbo. If it does not work, use gpt-4."
                )
                .optional(),
            }),
          [o.ScriptLinterName.ChatGoogleSearchPlagiarismLinter]: s.z.object({
            useGPT: s.z
              .boolean()
              .describe(
                "Use GPT-4 to compare the sentence against the search results"
              ),
            gptSentenceMatchThreshold: s.z
              .number()
              .describe(
                "The threshold for the similarity score between the sentence and the search results (GPT-4 confidence score). The score is between 0 and 1. Higher score means more similar."
              ),
            useLevenshtein: s.z
              .boolean()
              .describe(
                "Use Levenshtein distance to compare the sentence against the search results"
              ),
            levenshteinSentenceMatchThreshold: s.z
              .number()
              .describe(
                "This is an inverted threshold for the similarity score between the sentence and the search results, measured using the Levenshtein distance. The threshold score ranges from 0 to 1, where a higher score indicates a greater similarity. An exact match will have a score of 1. If the threshold is set to 0.8, any sentence with a similarity score of 0.8 or higher will be flagged as a match."
              ),
            allowedSentenceMatches: s.z
              .number()
              .describe(
                "The number of sentences that can match with the search results before the response is flagged for plagiarism"
              ),
            searchResultsToCompare: s.z
              .number()
              .describe(
                "The number of search results to compare against each sentence"
              ),
            fieldId: s.z
              .string()
              .describe(
                'Specify the fieldId if the rule is intended to be applied to any TextCollection steps. Only works for "text" field types.'
              )
              .optional(),
          }),
          [o.ScriptLinterName.ChatMultiModalRelevanceLinter]: s.z.object({}),
          [o.ScriptLinterName.ChatLatexParsingLinter]: s.z.object({}),
          [o.ScriptLinterName.ChatBlockMMMULinter]: s.z.object({
            similarityThreshold: s.z
              .number()
              .describe(
                "The threshold for the similarity score between the image and MMMU images"
              ),
          }),
          [o.ScriptLinterName.ChatAutoraterPlagiarismLinter]: s.z.object({
            similarityThreshold: s.z
              .number()
              .gte(0)
              .lte(1)
              .describe(
                "Threshold between 0 and 1 for reporting plagiarism when the 1 - relative levenshtein distance is higher than this number."
              ),
            useGpt: s.z
              .boolean()
              .optional()
              .describe(
                "Whether to use GPT to compare the text in addition to levenshtein distance."
              ),
            fieldId: s.z
              .string()
              .describe("The field id to run the linter on."),
          }),
          [o.ScriptLinterName.ChatLambdaUnitTestExecutionLinter]: s.z.object({
            codeFieldId: s.z
              .string()
              .describe(
                "The field id for field containing the code to run. This is REQUIRED."
              ),
            testDataType: s.z
              .string()
              .describe(
                "The data type of the test cases. This should be json. This is REQUIRED."
              ),
            unitTestCaseFieldId: s.z
              .string()
              .describe(
                "The field id for field containing test cases that run in a separate file. This is OPTIONAL. If not present, we will only check if the code compiles"
              )
              .optional(),
            useMetadataOutput: s.z
              .boolean()
              .describe(
                "If checked, the linter will use the metadata variable (in conjunction with metadataVariable) to determine the expected output"
              )
              .optional(),
            metadataVariable: s.z
              .string()
              .describe(
                "The metadata variable to use to determine the expected output"
              )
              .optional(),
          }),
        };
      t.ChatTaskScriptLinterConfigSchemas = g;
      const y = {
        stage: o.LintStage.Frontend,
        frontendSeverity: r.LintSeverity.WARNING,
        level: o.LintLevel.Info,
        enableAttempt: !0,
        enableL0: !0,
        enableL1: !0,
        enableL4: !0,
        enableL8: !1,
        enableL10: !0,
        enableL11: !1,
        enableL12: !1,
        enableBenchmarks: !0,
        enableQIRAuditor: !1,
        enableQIRLeadAuditor: !1,
        enableCustomerAudit: !1,
        levelAfterMaxFailures: o.LintLevel.Info,
        enableLintAutofix: !1,
        lintPanelOrder: 0,
        dismissalReasons: [],
        runPerTurn: !1,
        isOffline: !0,
      };
      var b;
      (t.LinterPreset = b),
        (function (e) {
          (e.GrammarLinter = "needs configuration grammar-linter"),
            (e.ContradictionsLinter =
              "needs configuration contradictions-linter"),
            (e.SpamLinter = "needs configuration spam-linter"),
            (e.ToxicityLinter = "needs configuration toxicity-linter"),
            (e.MultilingualToxicityLinter =
              "needs configuration multilingual-toxicity-linter"),
            (e.ChatJsonataCustomLinter =
              "[needs configuration] chat-jsonata-custom-linter"),
            (e.ChatRobotsValidationCustomLinter =
              "[needs configuration] chat-robots-validation-custom-linter"),
            (e.ChatMultiReplicaJsonataCustomLinter =
              "[needs configuration] chat-multi-replica-jsonata-custom-linter"),
            (e.ChatLazarusMathTopicsLinter =
              "[needs configuration] chat-lazarus-math-topic-custom-linter"),
            (e.ChatZipFileContentsLinter =
              "[needs configuration] chat-zip-file-contents-linter"),
            (e.ChatCustomEndpointLinter =
              "[needs configuration] chat-custom-endpoint-linter"),
            (e.ChatPreventAnswerBasedOnContributorWt =
              "[needs configuration] chat-prevent-answer-based-on-contributor-wt"),
            (e.ChatDolphinPromptImage =
              "[out-of-the-box] chat-dolphin-prompt-image"),
            (e.GrammarCheckerPrompt =
              "[out-of-the-box] grammar-checker-prompt (prp)"),
            (e.GrammarCheckerResponse =
              "[out-of-the-box] grammar-checker-response (prp)"),
            (e.JustificationAndSelectionMatch =
              "[out-of-the-box] justification-and-selection-match"),
            (e.BadWords = "[out-of-the-box] bad-words"),
            (e.MissingResponse = "[out-of-the-box] missing-response"),
            (e.UniqueResponse = "[out-of-the-box] unique-response"),
            (e.UniqueCompletedTasksResponse =
              "[out-of-the-box] unique-completed-tasks-response"),
            (e.AIContentDetector = "[out-of-the-box] ai-content-detector"),
            (e.MinResponseEditDistance =
              "[out-of-the-box] min-response-edit-distance"),
            (e.NGramDiversity = "[out-of-the-box] ngram-diversity"),
            (e.SpamWords = "[out-of-the-box] spam-words"),
            (e.SemanticSimilarity = "[out-of-the-box] semantic-similarity"),
            (e.MultiTurnResponseSimilarity =
              "[out-of-the-box] multi-turn-response-similarity"),
            (e.Regex = "[needs configuration] regex"),
            (e.URLExists = "[needs configuration] url-exists"),
            (e.GoogleTranslateDetector =
              "[needs configuration] google-translate-detector"),
            (e.TextLength = "[needs configuration] text-length"),
            (e.MLQualitySingletonMetric =
              "[needs configuration] ml-quality-singleton-metric"),
            (e.MLQualityPRPMetric =
              "[needs configuration] ml-quality-prp-metric"),
            (e.PromptResponsePairNumerical =
              "[needs configuration] prompt-response-pair-numerical"),
            (e.PromptResponsePairString =
              "[needs configuration] prompt-response-pair-string"),
            (e.PromptResponseWordCountDiff =
              "[needs configuration] prompt-response-word-count-diff"),
            (e.SphereExecutionOutputLinter =
              "[needs configuration] sphere-execution-output-linter"),
            (e.ChatLambdaUnitTestExecutionLinter =
              "[needs configuration] chat-lambda-unit-test-execution-linter"),
            (e.ChatNightingaleArchetypeDiversityLinter =
              "NER: Min/Max Category Count"),
            (e.ChatNightingalePlagiarismLinter =
              "[out-of-the-box] nightingale-plagiarism-linter"),
            (e.ChatNightingaleWordCountLinter =
              "[out-of-the-box] nightingale-word-count-linter"),
            (e.ChatNightingaleRankingConsistencyLinter =
              "[out-of-the-box] chat-nightingale-ranking-consistency-linter"),
            (e.ChatJustificationLikertMatchMLLinter =
              "[out-of-the-box] chat-justification-and-likert-ml-match"),
            (e.ChatPromptComparisonToSearchResult =
              "prompt-comparison-to-search-result"),
            (e.ChatBulbaLikertResponseValidator =
              "[Bulba MT] Likert_response_bad_validator"),
            (e.ChatBulbaLockFieldLinter = "[Bulba MT] Lock_field_linter"),
            (e.ChatBulbaCodeEvalCodePresentLinter =
              "[Bulba Code Eval] Code Present Linter"),
            (e.ChatMRSSphereExecutionRelevanceLinter =
              "[Bulba Code Eval] Sphere Execution Relevance Linter"),
            (e.ChatNERSentenceLinter = "[out-of-the-box] ner-sentence-linter"),
            (e.ChatPromptModelAgreementLinter =
              "[needs configuration] prompt-model-agreement-linter"),
            (e.ChatImageNSFWLinter = "[needs-configuration] image-nsfw-linter"),
            (e.ChatGoogleSearchPlagiarismLinter =
              "[needs-configuration] google-search-plagiarism-linter"),
            (e.ChatMultiModalRelevanceLinter =
              "[out-of-the-box] mm-relevance-linter"),
            (e.ChatLatexParsingLinter =
              "[out-of-the-box] latex-parsing-linter"),
            (e.ChatBlockMMMULinter = "[out-of-the-box] block-mmmu-linter"),
            (e.ChatAutoraterPlagiarismLinter =
              "[out-of-the-box] autorater-plagiarism-linter");
        })(b || (t.LinterPreset = b = {}));
      const T = {
          ...y,
          name: "JSONata Linter - Can be used to build custom project linters",
          shortDescription:
            "Evaluates JSONata expressions and flags the linter if given expressions are ends up being false.",
          longDescription:
            "JSONata has an editor: https://try.jsonata.org/ that helps you to test your linter. Each expression evaluated separately.\n'Every': Checkes if all expressions are true | 'Some': Checks if at least one expression is true | 'None': Checks if none of the expressions are true\nThen if the final result is false, then the linter will be flagged.\nAn example: https://try.jsonata.org/Dh9P_r0PK",
          condition: {
            scriptName: o.ScriptLinterName.ChatJsonataCustomLinter,
            config: {
              runOnStepTypes: [
                l.InteractionStepType.TextCollection,
                l.InteractionStepType.TextCollectionPerResponse,
                l.InteractionStepType.PromptInput,
                l.InteractionStepType.ModelResponseEditor,
                l.InteractionStepType.ModelResponseSelector,
              ],
            },
            validatorCategory: o.ValidatorCategory.ProjectConstraints,
          },
          message:
            "Please make sure your answers follow the instructions correctly",
        },
        _ = {
          ...y,
          name: "Robots.txt Validation - Validates that robots.txt can be scraped for specific user agents",
          shortDescription:
            "Validates that robots.txt can be scraped for specific user agents. The linter will flag if the robots.txt file is not accessible for the given user agents.",
          longDescription:
            "Validates that robots.txt can be scraped for specific user agents. The linter will flag if the robots.txt file is not accessible for the given user agents.",
          condition: {
            scriptName: o.ScriptLinterName.ChatRobotsValidationCustomLinter,
            config: {
              runOnStepTypes: [
                l.InteractionStepType.TextCollection,
                l.InteractionStepType.TextCollectionPerResponse,
                l.InteractionStepType.PromptInput,
                l.InteractionStepType.ModelResponseEditor,
                l.InteractionStepType.ModelResponseSelector,
              ],
            },
            validatorCategory: o.ValidatorCategory.ProjectConstraints,
          },
          message:
            "The site /robots.txt file is not accessible for the given user agents",
        },
        S = {
          [b.GrammarLinter]: {
            ...y,
            name: "Response Quality Flag: Grammar",
            condition: {
              scriptName: o.ScriptLinterName.GrammarLinter,
              config: {
                runOnStepTypes: [l.InteractionStepType.ModelResponseEditor],
                thresholdScore: 0.3,
              },
              validatorCategory: o.ValidatorCategory.GeneralQuality,
            },
            message: "Please ensure the text written is grammatically correct",
          },
          [b.ContradictionsLinter]: {
            ...y,
            name: "Response Quality Flag: Contradictions",
            condition: {
              scriptName: o.ScriptLinterName.ContradictionsLinter,
              config: {
                runOnStepTypes: [l.InteractionStepType.ModelResponseEditor],
                thresholdScore: 0.3,
              },
              validatorCategory: o.ValidatorCategory.GeneralQuality,
            },
            message:
              "Please ensure the text written does not contradict itself",
          },
          [b.SpamLinter]: {
            ...y,
            name: "Response Quality Flag: Spam",
            shortDescription: "Spam Linter created by our ML team.",
            condition: {
              scriptName: o.ScriptLinterName.SpamLinter,
              config: {
                runOnStepTypes: [l.InteractionStepType.ModelResponseEditor],
                thresholdScore: 0.3,
              },
              validatorCategory: o.ValidatorCategory.CheatingSpam,
            },
            message: "Please ensure the text written is not spam",
          },
          [b.ToxicityLinter]: {
            ...y,
            name: "Response Quality Flag: Toxicity",
            shortDescription: "Toxicity Linter created by our ML team.",
            condition: {
              scriptName: o.ScriptLinterName.ToxicityLinter,
              config: {
                runOnStepTypes: [l.InteractionStepType.ModelResponseEditor],
                thresholdScore: 0.3,
              },
              validatorCategory: o.ValidatorCategory.CheatingSpam,
            },
            message: "Please ensure the text written is not toxic",
          },
          [b.MultilingualToxicityLinter]: {
            ...y,
            name: "Response Quality Flag: Multilingual Toxicity",
            shortDescription:
              "Multilingual Toxicity Linter created by our ML team.",
            condition: {
              scriptName: o.ScriptLinterName.MultilingualToxicityLinter,
              config: {
                runOnStepTypes: [l.InteractionStepType.ModelResponseEditor],
                thresholdScore: 0.3,
              },
              validatorCategory: o.ValidatorCategory.Languages,
            },
            message: "Please ensure the text written is not toxic",
          },
          [b.ChatJsonataCustomLinter]: T,
          [b.ChatRobotsValidationCustomLinter]: _,
          [b.ChatMultiReplicaJsonataCustomLinter]: {
            ...T,
            name: `Multi Replica ${T.name}`,
            shortDescription: `${T.shortDescription} \nUse the responses object to write your jsonata expression, where responses[i] is the response of the ith replica.`,
            longDescription: `${T.longDescription}. \nHere is an example that checks that the text collection matches across all replicas: $count($distinct(responses.context.response.annotations.response_presentation.response[0])) != 1`,
            condition: {
              ...T.condition,
              scriptName:
                o.ScriptLinterName.ChatMultiReplicaJsonataCustomLinter,
              validatorCategory: o.ValidatorCategory.MultiReplica,
            },
          },
          [b.ChatLazarusMathTopicsLinter]: {
            ...y,
            name: "Lazarus Math Topics Custom Linter",
            shortDescription:
              "Scans all the tasks in the project with same topic 1 and topic 2, and limits the use of it",
            longDescription:
              "Scans all the tasks in the project with same topic 1 and topic 2, and limits the use of it",
            condition: {
              scriptName: o.ScriptLinterName.ChatLazarusMathTopicsLinter,
              config: {
                runOnStepTypes: [l.InteractionStepType.TextCollection],
              },
              validatorCategory: o.ValidatorCategory.ProjectConstraints,
            },
            message:
              "Please make sure your answers follow the instructions correctly",
          },
          [b.ChatZipFileContentsLinter]: {
            ...y,
            name: "Zip File Contents Linter",
            shortDescription:
              "Verifies the contents of the zip file and enforces the necessary number of files and/or file types",
            longDescription:
              "Verifies the contents of the zip file and enforces the necessary number of files and/or file types",
            condition: {
              scriptName: o.ScriptLinterName.ChatZipFileContentsLinter,
              config: {
                runOnStepTypes: [l.InteractionStepType.TextCollection],
              },
              validatorCategory: o.ValidatorCategory.ProjectConstraints,
            },
            message:
              "Please make sure your zip file contains the necessary files",
          },
          [b.ChatCustomEndpointLinter]: {
            ...y,
            name: "Custom Endpoint Linter",
            shortDescription:
              "Verifies the user response by using a custom endpoint",
            longDescription:
              "Verifies the user response by using a custom endpoint",
            condition: {
              scriptName: o.ScriptLinterName.ChatCustomEndpointLinter,
              config: {
                runOnStepTypes: [l.InteractionStepType.TextCollection],
              },
              validatorCategory: o.ValidatorCategory.ProjectConstraints,
            },
            message: "Please make sure your answers are correct.",
          },
          [b.ChatPreventAnswerBasedOnContributorWt]: {
            ...y,
            name: "Prevent Field Response By WT",
            shortDescription:
              "Prevents contributors from a specific WT to give a response to a field",
            longDescription:
              "This linter prevents contributors from giving a response to a certain field, this can be used when different contributors are expected to answer different fields in the same taxonomy",
            condition: {
              scriptName:
                o.ScriptLinterName.ChatPreventAnswerBasedOnContributorWt,
              config: {
                runOnStepTypes: [l.InteractionStepType.TextCollection],
              },
            },
            message: "Ensures specific contributors answer field",
          },
          [b.ChatDolphinPromptImage]: {
            ...y,
            name: "[Dolphin] Prompt Image Accuracy",
            shortDescription:
              "Prevents contributors of submit task based prompt & image ratings",
            longDescription:
              "This is a personalized linter for Dolphin MM, it does not allow contributors to submit a task step if prompt and image rating are not in accordance",
            condition: {
              scriptName: o.ScriptLinterName.ChatDolphinPromptImage,
              config: {
                runOnStepTypes: [l.InteractionStepType.TextCollection],
              },
              validatorCategory: o.ValidatorCategory.ProjectSpecific,
            },
            message: "Prompt + image pair ratings",
          },
          [b.ChatPromptModelAgreementLinter]: {
            ...y,
            name: "Model Agreement Linter (Difficulty)",
            condition: {
              scriptName: o.ScriptLinterName.ChatPromptModelAgreementLinter,
              config: {
                runOnStepTypes: [l.InteractionStepType.PromptInput],
                strategyName: "BulbaBridgeStrategy",
                modelParams: {
                  model: "sbs-reasoning-bard-bravo-xl-rev6-rc6p4",
                },
                passIfAgree: !1,
              },
              validatorCategory: o.ValidatorCategory.ProjectConstraints,
            },
            message:
              "Ensures whether GPT-4 agrees with a model on a response, gauging the difficulty of the response.",
          },
          [b.GrammarCheckerPrompt]: {
            ...y,
            name: "[Prompt] Grammar Error",
            shortDescription:
              "PRP: Runs GPT-4 to check prompt grammar and shows tasker where grammar errors are within task",
            longDescription:
              '"When Contain grammar errors within the PRP is True, it will provide the following message to the taskers:\n\n    Please ensure that your response is free of any grammar errors.\n    Errors: <grammar errors>"',
            condition: {
              scriptName: o.ScriptLinterName.ChatPromptResponsePairLinter,
              config: {
                runOnStepTypes: [
                  l.InteractionStepType.PromptInput,
                  l.InteractionStepType.MultiTurnContinue,
                  l.InteractionStepType.TextCollection,
                ],
                promptTemplate:
                  "Examine the given text and report if there are any grammar, typo, or spelling errors.\n\nText:\n{{promptText}}\n\nUse the following output format:\n\nContain grammar errors: <True/False>\nErrors: <grammar errors>",
                showModelOutput: !0,
                modelOutputRegexMatch: "Errors: .*",
                overriddenModelParams: {
                  model: "gpt-4o",
                  temperature: 0,
                  max_tokens: 512,
                },
                passIfStringOutputMatches: {
                  regexMatch: "Contain grammar errors: False",
                  flags: "ig",
                },
              },
              validatorCategory: o.ValidatorCategory.GeneralQuality,
            },
            message:
              "Please ensure that your response is free of any grammar errors.",
          },
          [b.GrammarCheckerResponse]: {
            ...y,
            name: "[Response] Grammar Error",
            shortDescription:
              "PRP: Runs GPT-4 to check response grammar and shows tasker where grammar errors are within task",
            longDescription:
              '"When Contain grammar errors within the PRP is True within the Response, it will provide the following message to the taskers:\n\n    Please ensure that your response is free of any grammar errors.\n    Errors: <grammar errors>"',
            condition: {
              scriptName: o.ScriptLinterName.ChatPromptResponsePairLinter,
              config: {
                runOnStepTypes: [l.InteractionStepType.ModelResponseEditor],
                promptTemplate:
                  "Examine the given text and report if there are any grammar, typo, or spelling errors.\n\nText:\n{{responseText}}\n\nUse the following output format:\n\nContain grammar errors: <True/False>\nErrors: <grammar errors>",
                showModelOutput: !0,
                modelOutputRegexMatch: "Errors: .*",
                overriddenModelParams: {
                  model: "gpt-4o",
                  temperature: 0,
                  max_tokens: 512,
                },
                passIfStringOutputMatches: {
                  regexMatch: "Contain grammar errors: False",
                  flags: "ig",
                },
              },
              validatorCategory: o.ValidatorCategory.GeneralQuality,
            },
            message:
              "Please ensure that your response is free of any grammar errors.",
          },
          [b.JustificationAndSelectionMatch]: {
            ...y,
            name: "Justification and Selection match",
            shortDescription:
              "PRP: Runs GPT-4 to check whether the selected model response matches the given justification",
            longDescription:
              '"This rule checks if the selected model response matches the given justification. If there is a mismatch, it will prompt the taskers with the following message:\n\n    Please ensure that your selected model response matches the given justification.\n    Mismatch details: <details of the mismatch>"',
            condition: {
              scriptName: o.ScriptLinterName.ChatPromptResponsePairLinter,
              config: {
                runOnStepTypes: [l.InteractionStepType.ModelResponseSelector],
                promptTemplate:
                  "Ensure that the chosen selected index matches the justification. If the selected index is 0, the justification should be saying that Response A or Response 1 is better; if the selected index is 1, the justification should be saying that Response B or Response 2 is better. If the selected index is -1, the justification should be saying that both responses are the same or relatively equal.\n\n        Selected index: {{selectedIndex}}\n        Justification: {{justification}}\n\n        Use the following output format:\n\n        Contain errors: <True/False>\n        Errors: <grammar errors>",
                showModelOutput: !0,
                modelOutputRegexMatch: "Errors: .*",
                overriddenModelParams: {
                  model: "gpt-4o",
                  temperature: 0,
                  max_tokens: 512,
                },
                passIfStringOutputMatches: {
                  regexMatch: "Contain errors: False",
                  flags: "ig",
                },
              },
              validatorCategory: o.ValidatorCategory.JustificationRanking,
            },
            message:
              "Please ensure that your selected model response matches the given justification.",
          },
          [b.ChatJustificationLikertMatchMLLinter]: {
            ...y,
            name: "Justification and Likert Match ML Linter",
            shortDescription:
              "Runs GPT-4 with multiple model votes to check if the Likert matches the given justification",
            longDescription:
              '"This rule checks if the selected model response matches the given justification in the most accurate way"',
            condition: {
              scriptName:
                o.ScriptLinterName.ChatJustificationLikertMatchMLLinter,
              config: {
                runOnStepTypes: [
                  l.InteractionStepType.ModelResponseSelector,
                  l.InteractionStepType.ModelResponseRanking,
                  l.InteractionStepType.TextCollection,
                ],
                likertScaleSet: [
                  "Response 1 is much better than Response 2",
                  "Response 1 is better than Response 2",
                  "Response 1 is slightly better than Response 2",
                  "Both responses are the same",
                  "Response 2 is slightly better than Response 1",
                  "Response 2 is better than Response 1",
                  "Response 2 is much better than Response 1",
                ],
              },
              validatorCategory: o.ValidatorCategory.JustificationRanking,
            },
            message:
              "Please ensure that your selected model response matches the given justification.",
          },
          [b.BadWords]: {
            ...y,
            name: "[Prompt/Response] Profanity Detected",
            frontendSeverity: r.LintSeverity.ERROR,
            shortDescription: "Prevents profanity in response",
            longDescription:
              "Prevents profanity in the response. Please see this [doc](https://docs.google.com/spreadsheets/d/1RiXhLe8RnT7zKZZXfNj8uGGYxIdj3csfG6eUpkf2LPw/edit#gid=198521862) for the list of words considered profanity by default.",
            condition: {
              scriptName: o.ScriptLinterName.ChatBadWordsLinter,
              config: {
                runOnStepTypes: [
                  l.InteractionStepType.PromptInput,
                  l.InteractionStepType.MultiTurnContinue,
                  l.InteractionStepType.ModelResponseEditor,
                ],
              },
              validatorCategory: o.ValidatorCategory.CheatingSpam,
            },
            message: "Please do not use bad words in your prompt/response.",
          },
          [b.MissingResponse]: {
            ...y,
            frontendSeverity: r.LintSeverity.ERROR,
            name: "Missing Required Response",
            shortDescription: "Requires a response for a field",
            longDescription: "Linter to enforce that a response isn't empty.",
            condition: {
              scriptName: o.ScriptLinterName.ChatMissingResponseLinter,
              config: {
                runOnStepTypes: [
                  l.InteractionStepType.PromptInput,
                  l.InteractionStepType.MultiTurnContinue,
                  l.InteractionStepType.ModelResponseEditor,
                  l.InteractionStepType.TextCollection,
                  l.InteractionStepType.TextCollectionPerResponse,
                ],
              },
              validatorCategory: o.ValidatorCategory.GeneralQuality,
            },
            message: "Missing response",
          },
          [b.UniqueResponse]: {
            ...y,
            name: "Duplicated Response",
            message:
              "The response is too similar to some previously submitted response.",
            frontendSeverity: r.LintSeverity.ERROR,
            shortDescription:
              "Enforce that texts are sufficiently different from previously submitted text, as measured by levenshtein distance",
            longDescription:
              'Enforce the currently submitted text is different enough from the historically submitted texts. The historically submitted texts are aggregated from prompt, edited model response, and the relevant textcollection field if "fieldId" is provided.',
            condition: {
              scriptName: o.ScriptLinterName.ChatUniqueResponseLinter,
              config: {
                runOnStepTypes: [
                  l.InteractionStepType.PromptInput,
                  l.InteractionStepType.MultiTurnContinue,
                  l.InteractionStepType.ModelResponseEditor,
                ],
                minLengthToApply: 10,
                minRelativeLevenshteinDistance: 0.3,
                compareDifferentAttempters: !1,
                attemptsLimit: 300,
                addPrevAttemptsToMessage: !0,
                useLevenshtein: !1,
                checkImageDB: !0,
              },
              validatorCategory: o.ValidatorCategory.Diversity,
            },
          },
          [b.UniqueCompletedTasksResponse]: {
            ...y,
            name: "Duplicated Response In Completed Tasks",
            message:
              "The response is too similar to some previously submitted response from a completed task.",
            frontendSeverity: r.LintSeverity.ERROR,
            shortDescription:
              "Enforce that texts are sufficiently different from previously submitted text, as measured by levenshtein distance",
            longDescription:
              'Enforce the currently submitted text is different enough from the historically submitted texts. The historically submitted texts are aggregated from prompt, edited model response, and the relevant textcollection field if "fieldId" is provided.',
            condition: {
              scriptName:
                o.ScriptLinterName.ChatCompletedTasksUniqueResponseLinter,
              config: {
                runOnStepTypes: [
                  l.InteractionStepType.PromptInput,
                  l.InteractionStepType.MultiTurnContinue,
                  l.InteractionStepType.ModelResponseEditor,
                ],
                minLengthToApply: 10,
                minRelativeLevenshteinDistance: 0.3,
                compareDifferentAttempters: !1,
                attemptsLimit: 300,
                addPrevAttemptsToMessage: !0,
                useLevenshtein: !1,
                checkImageDB: !0,
              },
              validatorCategory: o.ValidatorCategory.Diversity,
            },
          },
          [b.AIContentDetector]: {
            ...y,
            name: "AI Generated Content: GPTZero",
            shortDescription:
              'Flags text that are considered AI generated by GPT Zero. Same as "GPT Zero" linter in TextCollection.',
            longDescription:
              'Flags text that are considered AI generated by GPT Zero. According to GPT Zero, "At a threshold of 0.88, 85% of AI documents are classified as AI, and 99% of human documents are classified as human. At a threshold of 0.5, 96% of AI documents are classified as AI, and 96% of human documents are classified as human." However, our internal tests indicate a very high false positive rate at 0.5 (likely due to the fact we are often rewriting AI generated text), so we generally recommend setting a higher threshold (e.g., 0.9) if using as a blocking linter. See [GPT Zero docs for more details](https://gptzero.stoplight.io/docs/gptzero-api/d2144a785776b-ai-detection-on-single-string)',
            condition: {
              scriptName: o.ScriptLinterName.ChatGPTZeroLinter,
              config: {
                runOnStepTypes: [
                  l.InteractionStepType.PromptInput,
                  l.InteractionStepType.MultiTurnContinue,
                  l.InteractionStepType.ModelResponseEditor,
                  l.InteractionStepType.TextCollectionPerResponse,
                ],
                average_generated_prob: 0.8,
                completely_generated_prob: 0.9,
              },
              validatorCategory: o.ValidatorCategory.CheatingSpam,
            },
            message: "Please do not use AI-generated content.",
          },
          [b.MinResponseEditDistance]: {
            ...y,
            name: "[Prompt/Response] More Edits Required",
            shortDescription: "Enforce levenshtein edits from initial response",
            longDescription:
              "This linter checks that there are enough edits between original response and final output of an editor response.",
            condition: {
              scriptName: o.ScriptLinterName.ChatMinEditDistanceLinter,
              config: {
                runOnStepTypes: [l.InteractionStepType.ModelResponseEditor],
                minRelativeLevenshteinDistance: 0.5,
                minLengthToApply: 5,
                removeMarkdown: !0,
              },
              validatorCategory: o.ValidatorCategory.GeneralQuality,
            },
            message:
              "Please make sure that your response is sufficiently different from the provided prompt/response.",
          },
          [b.NGramDiversity]: {
            ...y,
            name: "[Prompt] Diversity of Word Choice",
            frontendSeverity: r.LintSeverity.ERROR,
            shortDescription: "Enforce diversity of word choice across tasks",
            longDescription:
              "Linter to enforce diversity in word choice across tasks. Diversity can be tuned using the supported parameters in the config.",
            condition: {
              scriptName: o.ScriptLinterName.ChatNGramDiversityLinter,
              config: {
                runOnStepTypes: [
                  l.InteractionStepType.PromptInput,
                  l.InteractionStepType.MultiTurnContinue,
                  l.InteractionStepType.TextCollection,
                ],
                maxMatches: 3,
                numAttempts: 20,
                n: 2,
                ignoreStopWords: !0,
                additionalStopWords: [],
                fieldId: "",
              },
              validatorCategory: o.ValidatorCategory.Diversity,
            },
            message:
              "Please rewrite your response as it is too similar to your previous prompts.",
          },
          [b.SpamWords]: {
            ...y,
            name: "Spam: Banned Phrases",
            frontendSeverity: r.LintSeverity.ERROR,
            shortDescription:
              "Blocks suspicous phrases that may be from ChatGPT (e.g., September 2021)",
            longDescription:
              "This linter uses regex to prevent words from being used in the task",
            condition: {
              scriptName: o.ScriptLinterName.ChatRegexLinter,
              config: {
                runOnStepTypes: [
                  l.InteractionStepType.PromptInput,
                  l.InteractionStepType.MultiTurnContinue,
                  l.InteractionStepType.ModelResponseEditor,
                ],
                rules: [
                  "(september 2021|knowledge cutoff|open[\\s]*ai|scale[ ]*ai|remotasks|I cannot predict future events|I don't have the capacity|I don't have feelings or emotions|January 2022|January 22|April 2023)",
                ],
                matches: "none",
                regexFlags: "ig",
              },
              validatorCategory: o.ValidatorCategory.CheatingSpam,
            },
            message:
              "Do not include spam phrases, such as those generated in a ChatGPT response.",
          },
          [b.SemanticSimilarity]: {
            ...y,
            name: "[Prompt] Similar Prompt Already Submitted",
            frontendSeverity: r.LintSeverity.ERROR,
            shortDescription:
              "Semantic Similarity - Blocks prompts that are too similar from already submitted prompts, based on the meaning of the prompts (instead of word choice).",
            longDescription:
              "Compares submitted prompts against all previously submitted prompts in the project and blocks those that are too close, as measured by the cosine similarity of embeddings. Think of embeddings as representing the meaning of a text - texts with more similar meanings will be closer together.\n\n    Here's an example of two prompts that would be considered similar in the embedding space:\n\n    Seven bottles of soda cost $21.00 while 4 bottles of water cost $8. If David wants to buy 3 bottles of soda and 2 bottles of water, how much will that cost?\n\n    Five pens cost $7.50 while 4 pencils cost $1. If Andrew wants to buy 3 pens and 2 pencils, how much will that cost?\n\n    While the word choice is very different, the two prompts are very similar in terms of the problem they are trying to solve.",
            condition: {
              scriptName: o.ScriptLinterName.ChatSemanticSimilarityLinter,
              config: {
                runOnStepTypes: [
                  l.InteractionStepType.PromptInput,
                  l.InteractionStepType.MultiTurnContinue,
                  l.InteractionStepType.ModelResponseEditor,
                ],
                thresholds: [{ threshold: 0.9, maxPromptsAboveThreshold: 0 }],
              },
              validatorCategory: o.ValidatorCategory.Diversity,
            },
            message:
              "Please rewrite your response as it is too similar to some of the previously submitted prompts.",
          },
          [b.Regex]: {
            ...y,
            name: "Regex: Block Specific Phrases",
            frontendSeverity: r.LintSeverity.ERROR,
            shortDescription:
              'Use regular expression rules to prevent the most common errors or enforce certain response formats. Same as "Regex Blocklist" linter in TextCollection.',
            longDescription:
              "Please add any phrases or words you want to flag by clicking 'Lint Rule Config', and adding the words within 'rules section'. Any words that may overlap, please use 'exceptions'.\n\n    Example:\n    - Rules: 'Thank you for'\n    - Exception: 'Thank you'",
            condition: {
              scriptName: o.ScriptLinterName.ChatRegexLinter,
              config: {
                runOnStepTypes: [
                  l.InteractionStepType.PromptInput,
                  l.InteractionStepType.MultiTurnContinue,
                  l.InteractionStepType.ModelResponseEditor,
                ],
                rules: ["please", "thank you"],
                matches: o.RegexMatches.None,
                regexFlags: "i",
              },
              validatorCategory: o.ValidatorCategory.ProjectConstraints,
            },
            message: 'Do not use words like "please" or "thank you"',
          },
          [b.TextLength]: {
            ...y,
            name: "Minimum/Maximum Word Count Required",
            frontendSeverity: r.LintSeverity.ERROR,
            shortDescription: "Enforce a minimum or maximum text length",
            longDescription:
              "Restrict by character length by using `minCharacterLength` / `maxCharacterLength`. Restrict by word length by using `minWordLength` / `maxWordLength`.",
            condition: {
              scriptName: o.ScriptLinterName.ChatTextLengthLinter,
              config: {
                runOnStepTypes: [
                  l.InteractionStepType.PromptInput,
                  l.InteractionStepType.MultiTurnContinue,
                  l.InteractionStepType.ModelResponseSelector,
                ],
                minWordCount: 10,
                maxWordCount: 100,
                runOnJustification: !1,
                runOnReferenceTextContent: !1,
              },
              validatorCategory: o.ValidatorCategory.ProjectConstraints,
            },
            message: "Please restrict your prompt to 10-100 words.",
          },
          [b.MLQualitySingletonMetric]: {
            ...y,
            name: "Response Quality Flag",
            shortDescription:
              "Linters created by our ML team to target common issues. See [ML-based Quality Linter](https://scale.atlassian.net/wiki/spaces/OP/pages/452493395/ML-based+Quality+Linters) for more details.",
            longDescription:
              '"The thresholds define the range in which the linter will flag the task. For example, if you set a Lower Bound Threshold of 0.25 and a Threshold Score of 0.5, only tasks within 0.25 to 0.50 will be flagged.\n\n    Typically, you should set the Lower Bound Threshold to be 0 if you want to set a certain quality metric to be up to a certain standard (that you set as Threshold Score), since it\'ll flag everything below that standard.\n\n    For Blocking: If you would like Logical Complexity to be somewhat complex(0.25, 0.5), then you would set the lower bound threshold to 0 and upper bound threshold to 0.25\n\n\n    For Warning:"\n\n    ',
            condition: {
              scriptName: o.ScriptLinterName.ChatMLSingletonQualityMetricLinter,
              config: {
                runOnStepTypes: [
                  l.InteractionStepType.PromptInput,
                  l.InteractionStepType.MultiTurnContinue,
                  l.InteractionStepType.ModelResponseEditor,
                ],
                qualityMetricType:
                  a.SingletonQualityMetricType.GrammaticalityNormalized,
                lowerBoundScore: 0,
                thresholdScore: 0.5,
              },
              validatorCategory: o.ValidatorCategory.GeneralQuality,
            },
            message:
              "Please ensure that your response is grammatically correct.",
          },
          [b.MLQualityPRPMetric]: {
            ...y,
            name: "Prompt and Response Logic Error",
            shortDescription:
              "Looks at both Prompt and Response. Currently only available with Relevance",
            longDescription:
              "Linters created by our ML team to target common issues. See [ML-based Quality Linter](https://scale.atlassian.net/wiki/spaces/OP/pages/452493395/ML-based+Quality+Linters) for more details.",
            condition: {
              scriptName:
                o.ScriptLinterName.ChatMLPromptResponsePairQualityMetricLinter,
              config: {
                runOnStepTypes: [l.InteractionStepType.ModelResponseEditor],
                qualityMetricType:
                  a.PromptResponsePairQualityMetricType.RelevanceNormalized,
                lowerBoundScore: 0,
                thresholdScore: 0.5,
              },
            },
            message:
              "Please ensure that your response is relevant to the prompt.",
          },
          [b.PromptResponsePairNumerical]: {
            ...y,
            name: "PRP Flag - Numerical Match",
            shortDescription:
              "PRP: Run any GPT-4 prompt and lint based on outputted number",
            longDescription:
              "Configure a prompt for GPT-4 to validate tasker response against a numerical output to lint against.",
            condition: {
              scriptName: o.ScriptLinterName.ChatPromptResponsePairLinter,
              config: {
                runOnStepTypes: [
                  l.InteractionStepType.PromptInput,
                  l.InteractionStepType.MultiTurnContinue,
                ],
                systemPrompt:
                  "You are a helpful assistant for evaluating how complex a user query is.",
                promptTemplate:
                  'Examine the given user query to determine how difficult it is for a large language model to produce an excellent response to the query. First, you must rate the query on a scale of 1 to 10 by strictly following this format: "Rating: rating", for example: "Rating: 5". After your rating, provide a short explanation. Be as objective as possible.\n\n[User query]\n{{promptText}}\n\nRating: ',
                passIfNumericOutputMatches: { comparator: "gte", threshold: 5 },
                showModelOutput: !1,
              },
              validatorCategory: o.ValidatorCategory.ProjectConstraints,
            },
            message:
              "Please write a more complex and challenging prompt for our bot (e.g., specify the audience / viewpoint, length, outline of the response, tone of voice, level of difficulty / detail expected, expected number of outputs, etc.,). If your prompt is being flagged, it means that you should add some of these parameters (if applicable!).",
          },
          [b.PromptResponsePairString]: {
            ...y,
            name: "PRP Flag - String Match",
            shortDescription:
              "PRP: Run any GPT-4 prompt and lint based on outputted string",
            longDescription:
              "Configure a prompt for GPT-4 to validate tasker response against a string output to lint against.",
            condition: {
              scriptName: o.ScriptLinterName.ChatPromptResponsePairLinter,
              config: {
                runOnStepTypes: [
                  l.InteractionStepType.PromptInput,
                  l.InteractionStepType.MultiTurnContinue,
                  l.InteractionStepType.TextCollectionPerResponse,
                  l.InteractionStepType.ModelResponseSelector,
                ],
                promptTemplate:
                  "Examine the given text and report if there are any grammar errors.\n        \nText:\n{{promptText}}\n\nContain grammar errors: <True/False>\nErrors: <grammar errors>\n",
                showModelOutput: !0,
                overriddenModelParams: {
                  model: "gpt-4o",
                  temperature: 0,
                  max_tokens: 512,
                },
                passIfStringOutputMatches: {
                  regexMatch: "Contain grammar errors: False",
                  flags: "ig",
                },
              },
              validatorCategory: o.ValidatorCategory.ProjectConstraints,
            },
            message:
              "Please ensure that your response is free of any grammar errors.",
          },
          [b.MultiTurnResponseSimilarity]: {
            ...y,
            name: "Multiturn: Conversation too Similar to Previous Attempts",
            frontendSeverity: r.LintSeverity.ERROR,
            shortDescription:
              "Requires prompt, responses, and relevant textcollection fields within the same chat are sufficiently different, as measured by the levenshtein distance",
            longDescription:
              'Enforce the currently submitted text is different enough from the texts of previous turns, which are aggregated from prompt, edited model response, and the relevant textcollection field if "fieldId" is provided in the current attempt.',
            condition: {
              scriptName:
                o.ScriptLinterName.ChatMultiTurnResponseSimilarityLinter,
              config: {
                runOnStepTypes: [
                  l.InteractionStepType.PromptInput,
                  l.InteractionStepType.MultiTurnContinue,
                  l.InteractionStepType.ModelResponseEditor,
                ],
                minRelativeLevenshteinDistance: 0.4,
                minWordsToApply: 5,
              },
              validatorCategory: o.ValidatorCategory.Diversity,
            },
            message:
              "Please do not write similar responses across multiple turns.",
          },
          [b.GoogleTranslateDetector]: {
            ...y,
            name: "[needs configuration] google-translate-detector",
            shortDescription:
              "Custom linter for Vertigo Language Rewrite. Compares Google Translate output of prompt (original text) to the tasker response (translated text)",
            longDescription:
              "This linter was custom built for Vertigo Language Rewrite. It assume that the task is set up such that the original text is the chat Prompt and the translated text is the chat Response. It then puts the Prompt through Google Translate and compared the Levenshtein Distance to tha Response.",
            condition: {
              scriptName: o.ScriptLinterName.ChatGoogleTranslateDetectionLinter,
              config: {
                runOnStepTypes: [l.InteractionStepType.ModelResponseEditor],
                minRelativeLevenshteinDistance: 0.2,
                minWordsToApply: 5,
              },
              validatorCategory: o.ValidatorCategory.Languages,
            },
            message: "Please do not copy results from Google translate.",
          },
          [b.URLExists]: {
            ...y,
            name: "URL Does Not Work",
            frontendSeverity: r.LintSeverity.ERROR,
            shortDescription: "Checks if the URL provided is a working link",
            longDescription:
              "This will verify that the url link is a valid link but will not check if it has paywalls within the website. To make sure the URL-exist is working on the ChatTask Reference URL section, please select 'PromptInput'  within 'Restrict by step types'",
            condition: {
              scriptName: o.ScriptLinterName.ChatURLExistsLinter,
              config: { runOnStepTypes: [] },
              validatorCategory: o.ValidatorCategory.GeneralQuality,
            },
            message: "Please ensure that your response contains a valid URL.",
          },
          [b.PromptResponseWordCountDiff]: {
            ...y,
            name: "Translated Text Length Too Different",
            shortDescription:
              "Custom linter for translation projects. Check whether the length of the translated text is way to off from the length of the source text.",
            condition: {
              scriptName:
                o.ScriptLinterName.ChatPromptResponseWordCountDiffLinter,
              config: {
                runOnStepTypes: [l.InteractionStepType.ModelResponseEditor],
                minWordsToApply: 5,
                maxWordsCountMultiplier: 1.2,
                minWordsCountMultiplier: 0.8,
              },
              validatorCategory: o.ValidatorCategory.Languages,
            },
            message:
              "Please ensure that your response length is not too different from the prompt length.",
          },
          [b.SphereExecutionOutputLinter]: {
            ...y,
            name: "[needs configuration] sphere-execution-output-linter",
            shortDescription:
              "Check if executed code output matches in task response",
            condition: {
              scriptName: o.ScriptLinterName.ChatSphereExecutionOutputLinter,
              config: {
                runOnStepTypes: [
                  l.InteractionStepType.TextCollection,
                  l.InteractionStepType.ModelResponseEditor,
                ],
                codeFieldId: "solution_code",
                concatCodeFieldIds: [],
                outputFieldId: "textual_code_output",
                sphereProjectId: "",
                language: "",
                scenarioName: "run",
                sphereProjectCodeFilePath: "prog.py",
                lintForCodeFailure: !1,
              },
              validatorCategory: o.ValidatorCategory.Coding,
            },
            message: "Code error. ",
          },
          [b.ChatLambdaUnitTestExecutionLinter]: {
            ...y,
            name: "[needs configuration] lambda-unit-test-execution-linter",
            shortDescription:
              "Check if executed code output matches test cases",
            condition: {
              scriptName: o.ScriptLinterName.ChatLambdaUnitTestExecutionLinter,
              config: {
                runOnStepTypes: [l.InteractionStepType.TextCollection],
                codeFieldId: "solution_code_field_id",
                unitTestCaseFieldId: "unit_test_field_id",
                testDataType: "json",
              },
            },
            message: "Checks the code by running unit tests on them",
          },
          [b.ChatNightingaleArchetypeDiversityLinter]: {
            ...y,
            name: "NER: Min/Max Category Count",
            shortDescription:
              "Check if the number of categories in the NER step is within the specified range",
            condition: {
              scriptName:
                o.ScriptLinterName.ChatNightingaleArchetypeDiversityLinter,
              config: {
                runOnStepTypes: [l.InteractionStepType.NER],
                minCategoryPerTurn: [1],
              },
              validatorCategory: o.ValidatorCategory.ProjectConstraints,
            },
            message: "Please select a diverse set of categories.",
          },
          [b.ChatNightingalePlagiarismLinter]: {
            ...y,
            name: "[NER] Plagiarism Linter",
            shortDescription:
              "Check if the annotations of the latest NER step are present in the model response editor (to be used if the expectation is that NER annotations are replaced)",
            condition: {
              scriptName: o.ScriptLinterName.ChatNightingalePlagiarismLinter,
              config: {
                runOnStepTypes: [l.InteractionStepType.ModelResponseEditor],
                nGram: 3,
                maxAllowedRepetition: 0,
                minWordsToApply: 5,
              },
              validatorCategory: o.ValidatorCategory.CheatingSpam,
            },
            message: "Please do not copy text from above.",
          },
          [b.ChatNightingaleWordCountLinter]: {
            ...y,
            name: "NER: Word Span Highlight Limit",
            condition: {
              scriptName: o.ScriptLinterName.ChatNightingaleWordCountLinter,
              config: {
                runOnStepTypes: [l.InteractionStepType.NER],
                minCategoryPerTurn: [3],
              },
              validatorCategory: o.ValidatorCategory.ProjectConstraints,
            },
            message: "The text is insufficient",
          },
          [b.ChatNightingaleRankingConsistencyLinter]: {
            ...y,
            name: "[out-of-the-box] chat-nightingale-ranking-consistency-linter",
            condition: {
              scriptName:
                o.ScriptLinterName.ChatNightingaleRankingConsistencyLinter,
              config: {
                runOnStepIds: ["430d534f-55d5-4545-9f42-7a1519d906ad"],
              },
              validatorCategory: o.ValidatorCategory.ProjectSpecific,
            },
            message:
              "Please check your helpfulness ratings to make sure they\u2019re consistent with your model rankings.",
          },
          [b.ChatPromptComparisonToSearchResult]: {
            ...y,
            name: "[Prompt] Google Search Plagiarism",
            shortDescription:
              "Compares prompt against the first google search result",
            condition: {
              scriptName: o.ScriptLinterName.ChatPromptComparisonToSearchResult,
              config: {
                runOnStepTypes: [
                  l.InteractionStepType.PromptInput,
                  l.InteractionStepType.MultiTurnContinue,
                ],
                useGPT: !0,
                useLevenshtein: !0,
                threshold: 0.7,
              },
              validatorCategory: o.ValidatorCategory.CheatingSpam,
            },
            message:
              "Please do not copy examples from search results in your prompt",
          },
          [b.ChatNERSentenceLinter]: {
            ...y,
            name: "[out-of-the-box] ner-sentence-linter",
            condition: {
              scriptName: o.ScriptLinterName.ChatNERSentenceLinter,
              config: {
                runOnStepTypes: [l.InteractionStepType.NER],
                sentenceDelimiters: [".", "\n"],
              },
              validatorCategory: o.ValidatorCategory.GeneralQuality,
            },
            message:
              "Please ensure that each label covers exactly one sentence.",
          },
          [b.ChatBulbaLikertResponseValidator]: {
            ...y,
            name: "[Bulba MT] Likert_response_bad_validator",
            condition: {
              scriptName: o.ScriptLinterName.ChatBulbaLikertResponseValidator,
              config: {
                runOnStepTypes: [l.InteractionStepType.TextCollection],
              },
              validatorCategory: o.ValidatorCategory.ProjectSpecific,
            },
            message:
              "Please check the response rating and if it meets the standards",
          },
          [b.ChatBulbaLockFieldLinter]: {
            ...y,
            name: "[Bulba MT] Lock_field_linter",
            condition: {
              scriptName: o.ScriptLinterName.ChatBulbaLockFieldLinter,
              config: {
                runOnStepTypes: [l.InteractionStepType.TextCollection],
              },
              validatorCategory: o.ValidatorCategory.ProjectSpecific,
            },
            message: "Please check that you did not edit the locked field",
          },
          [b.ChatBulbaCodeEvalCodePresentLinter]: {
            ...y,
            name: "[Bulba Code Eval] Code Present Linter",
            condition: {
              scriptName: o.ScriptLinterName.ChatBulbaCodeEvalCodePresentLinter,
              config: {
                runOnStepTypes: [
                  l.InteractionStepType.TextCollectionPerResponse,
                ],
              },
              validatorCategory: o.ValidatorCategory.ProjectSpecific,
            },
            message:
              "Please ensure that your responses correspond with whether there is code in the response.",
          },
          [b.ChatImageNSFWLinter]: {
            ...y,
            name: "[needs configuration] NSFW Image Linter",
            shortDescription:
              "Linter to check if the image contains unsafe or sensitive elements",
            longDescription:
              "Use this linter to check if the image contains any sensitive elements across 15+ categories. The linter works only on image URLs on either a text collection field or on reference text URLs. The linter will send the URL to our internal image model and if the model deems the image to be sensitive, then the configured thresholds will be used to determine if an image is sensitive.",
            condition: {
              scriptName: o.ScriptLinterName.ChatImageNSFWLinter,
              config: {
                runOnStepTypes: [
                  l.InteractionStepType.PromptInput,
                  l.InteractionStepType.MultiTurnContinue,
                  l.InteractionStepType.TextCollection,
                ],
                thresholds: {
                  animal_violence: 0.5,
                  blood_and_gore: 0.5,
                  child_present: 0.5,
                  cigarettes_and_tobacco_products: 0.5,
                  explosions: 0.5,
                  exposed_breasts: 0.5,
                  exposed_butts: 0.5,
                  genitalia: 0.5,
                  guns: 0.5,
                  harassment_and_hate_speech: 0.5,
                  knives: 0.5,
                  marijuana: 0.5,
                  other_drugs: 0.5,
                  other_weapons: 0.5,
                  physical_violence: 0.5,
                  sex_toys: 0.5,
                  sexual_activity: 0.5,
                  suggestive: 0.5,
                  is_sensitive: 0.5,
                },
              },
              validatorCategory: o.ValidatorCategory.Multimodal,
            },
            message:
              "Please ensure that the image doesn't contain unsafe or sensitive elements",
          },
          [b.ChatMRSSphereExecutionRelevanceLinter]: {
            ...y,
            name: "[MRS / Sphere Workspace] Code Relevance Linter",
            shortDescription:
              "Performs a relevance check regarding executed code and its output",
            longDescription:
              "Use this linter to check if the executed code, and its output are in accordance",
            condition: {
              scriptName:
                o.ScriptLinterName.ChatMRSSphereExecutionRelevanceLinter,
              config: {
                runOnStepTypes: [
                  l.InteractionStepType.TextCollectionPerResponse,
                  l.InteractionStepType.TextCollection,
                ],
                promptTemplate:
                  "Examine the given code and determine if it is relevant to the model output.\n          Code:\n          {{executedCode}}\n\n          The model output is as follows:\n          {{modelOutput}}\n\n          Output True or False",
                systemPrompt:
                  "You are a helpful assistant for evaluating whether the executed code is relevant to the provided model output.",
                overriddenModelParams: {
                  model: "gpt-4o",
                  temperature: 0,
                  max_tokens: 512,
                },
              },
              validatorCategory: o.ValidatorCategory.Coding,
            },
            message:
              "Please ensure that the code you executed in Sphere Engine is from the model response output.",
          },
          [b.ChatGoogleSearchPlagiarismLinter]: {
            ...y,
            name: "[needs configuration] Online Content: Google Search Plagiarism",
            shortDescription:
              "Compares text responses to Google search results and flags if an instance of plagiarism is detected",
            longDescription:
              "Use this linter to compare each sentence in a text response against Google search results for it (using SerpAPI) to detect instances of plagiarism.\n      The similarity threshold and number of allowed sentence matches is configurable, as well as how many search results to compare each sentence against.\n      Similarity can be measured using Levenshtein distance, GPT-4 prompting, or both.\n      ",
            condition: {
              scriptName: o.ScriptLinterName.ChatGoogleSearchPlagiarismLinter,
              config: {
                runOnStepTypes: [
                  l.InteractionStepType.PromptInput,
                  l.InteractionStepType.MultiTurnContinue,
                  l.InteractionStepType.ModelResponseEditor,
                ],
                useGPT: !0,
                gptSentenceMatchThreshold: 0.9,
                useLevenshtein: !1,
                levenshteinSentenceMatchThreshold: 0.25,
                allowedSentenceMatches: 2,
                searchResultsToCompare: 3,
              },
              validatorCategory: o.ValidatorCategory.CheatingSpam,
            },
            message: "Please do not plagiarize text from the internet",
          },
          [b.ChatMultiModalRelevanceLinter]: {
            ...y,
            name: "multi-modal-relevance-linter",
            shortDescription:
              "Compares the relevance of an image to the prompt and response and flags if something is not relevant",
            longDescription:
              "Use this linter to compare the relevance of an image to the prompt response chain. This linter will send the image and prompts and responses to gpt4 and ask it if the text is relevant to the image. The linter will then flag the task if the model deems the prompt to be irrelevant to the image.",
            condition: {
              scriptName: o.ScriptLinterName.ChatMultiModalRelevanceLinter,
              config: {
                runOnStepTypes: [
                  l.InteractionStepType.PromptInput,
                  l.InteractionStepType.MultiTurnContinue,
                  l.InteractionStepType.ModelResponseEditor,
                ],
              },
              validatorCategory: o.ValidatorCategory.Multimodal,
            },
            frontendLinterFeedbackRate: 100,
            message:
              "Please ensure that what you enter is relevant to the image and the prior conversation",
          },
          [b.ChatLatexParsingLinter]: {
            ...y,
            name: "latex-parsing-linter",
            shortDescription: "Checks if the latex code properly compiles",
            longDescription:
              "Use this linter to check if the latex code provided compiles properly. The linter will check if the latex code compiles without any errors and will flag the task if the code does not compile.",
            condition: {
              scriptName: o.ScriptLinterName.ChatLatexParsingLinter,
              config: {
                runOnStepTypes: [
                  l.InteractionStepType.PromptInput,
                  l.InteractionStepType.MultiTurnContinue,
                  l.InteractionStepType.ModelResponseEditor,
                ],
              },
              validatorCategory: o.ValidatorCategory.Coding,
            },
            message: "Please ensure that your latex code compiles properly",
          },
          [b.ChatBlockMMMULinter]: {
            ...y,
            name: "block-mmmu-linter",
            shortDescription:
              "Blocks prompt submission if it includes an image that is in MMMU",
            longDescription:
              "Use this linter to check if submitted images are in the MMMU database. If any of the submitted images in prompt steps that this linter is enabled on are in the MMMU database, it flags the submission.",
            condition: {
              scriptName: o.ScriptLinterName.ChatBlockMMMULinter,
              config: {
                runOnStepTypes: [
                  l.InteractionStepType.PromptInput,
                  l.InteractionStepType.MultiTurnContinue,
                ],
                similarityThreshold: 0.9,
              },
              validatorCategory: o.ValidatorCategory.Multimodal,
            },
            message:
              "Submission contains an image from the MMMU dataset, please use a different image",
          },
          [b.ChatAutoraterPlagiarismLinter]: {
            ...y,
            name: "[Justification] Archie Summarizer Plagiarism Flag",
            frontendSeverity: r.LintSeverity.WARNING,
            shortDescription:
              "Checks justification for plagiarism against Archie's suggestion",
            longDescription: "",
            condition: {
              scriptName: o.ScriptLinterName.ChatAutoraterPlagiarismLinter,
              config: {
                runOnStepTypes: [
                  l.InteractionStepType.QuantitativeModelResponseSelector,
                ],
                similarityThreshold: 0.9,
                useGpt: !0,
                fieldId: "ranking_reasoning",
              },
              validatorCategory: o.ValidatorCategory.CheatingSpam,
            },
            message:
              "Please rewrite your justification in your own words so that it is not overly similar to or copied directly from Archie's suggestion.",
          },
        };
      t.LinterPresets = S;
    },
    402168: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.REWARD_MODEL_ROUTING_OVERRIDE =
          t.AFTER_MOCK_TEMPLATES =
          t.TURN_MOCK_TEMPLATES =
          t.BEFORE_MOCK_TEMPLATES =
          t.GENERAL_MOCK_TEMPLATES =
          t.QIR_MOCK_TEMPLATES =
          t.DEFAULT_PER_RESPONSE_FIELDS =
          t.DEFAULT_TOOL_USE_PROCESS_SUPERVISION_SUBTITLE =
          t.DEFAULT_TOOL_USE_PROCESS_SUPERVISION_TITLE =
          t.DEFAULT_PROCESS_SUPERVISION_END_AFTER_RATINGS_TITLE =
          t.DEFAULT_PROCESS_SUPERVISION_EDIT_CHUNKS_TITLE =
          t.DEFAULT_PROCESS_SUPERVISION_SUBTITLE =
          t.DEFAULT_PROCESS_SUPERVISION_TITLE =
          t.DEFAULT_SEARCH_REFERENCES_SUBTITLE =
          t.DEFAULT_SEARCH_REFERENCES_TITLE =
          t.DEFAULT_SEARCH_AUTOCOMPLETE_SUBTITLE =
          t.DEFAULT_SEARCH_AUTOCOMPLETE_TITLE =
          t.DEFAULT_NER_SUBTITLE =
          t.DEFAULT_NER_TITLE =
          t.DEFAULT_TEXTCOLLECTION_SUBTITLE =
          t.DEFAULT_TEXTCOLLECTION_TITLE =
          t.DEFAULT_MODEL_EDITOR_SUBTITLE =
          t.DEFAULT_MODEL_EDITOR_TITLE =
          t.DEFAULT_MODEL_RESPONSE_RANKING_SUBTITLE =
          t.DEFAULT_MODEL_RESPONSE_RANKING_TITLE =
          t.DEFAULT_MODEL_SELECTOR_SUBTITLE =
          t.DEFAULT_MODEL_SELECTOR_TITLE =
          t.DEFAULT_INSTRUCTION_SUBTITLE =
          t.DEFAULT_INSTRUCTION_TITLE =
          t.DEFAULT_PROMPT_INPUT_INSTRUCTIONS =
          t.DEFAULT_PROMPT_INPUT_SUBTITLE =
          t.DEFAULT_PROMPT_INPUT_TITLE =
            void 0);
      var i = n(963494),
        r = n(232095),
        o = n(392228),
        a = n(962751),
        s = n(167469);
      const l = "Start a Chat";
      t.DEFAULT_PROMPT_INPUT_TITLE = l;
      const c = "Write a prompt to start a chat session with the model.";
      t.DEFAULT_PROMPT_INPUT_SUBTITLE = c;
      const p =
        "\n  Please write a prompt that you would like the model to respond to. The prompt should be a short paragraph of text that is 1-3 sentences long. The prompt should be open-ended and not contain any specific questions.\n  It\u2019s okay if the model\u2019s response is very bad! Please continue to write complex prompts even if the model doesn\u2019t know how to respond! We actually want to see more instances of where the model is bad at responding. The worse the model\u2019s response, the better!\n".trim();
      t.DEFAULT_PROMPT_INPUT_INSTRUCTIONS = p;
      const u = "Review the instructions";
      t.DEFAULT_INSTRUCTION_TITLE = u;
      const d = "Read the instructions carefully before continuing.";
      t.DEFAULT_INSTRUCTION_SUBTITLE = d;
      const m = "Select the best response";
      t.DEFAULT_MODEL_SELECTOR_TITLE = m;
      const h =
        "When the responses are fully loaded, select the best response from the options.";
      t.DEFAULT_MODEL_SELECTOR_SUBTITLE = h;
      const f = "Rank responses from best to worst";
      t.DEFAULT_MODEL_RESPONSE_RANKING_TITLE = f;
      const g = "Drag and drop candidates into the classification groups.";
      t.DEFAULT_MODEL_RESPONSE_RANKING_SUBTITLE = g;
      const y = "Refine your response";
      t.DEFAULT_MODEL_EDITOR_TITLE = y;
      const b = "Edit the response to make it more appropriate for the prompt.";
      t.DEFAULT_MODEL_EDITOR_SUBTITLE = b;
      const T = "Answer the questions below";
      t.DEFAULT_TEXTCOLLECTION_TITLE = T;
      const _ = "Label your response according to the questions below.";
      t.DEFAULT_TEXTCOLLECTION_SUBTITLE = _;
      const S = "Annotate the response";
      t.DEFAULT_NER_TITLE = S;
      const v = "Label the entities in the response per the instructions.";
      t.DEFAULT_NER_SUBTITLE = v;
      const C = "Improve the model response";
      t.DEFAULT_SEARCH_AUTOCOMPLETE_TITLE = C;
      const I =
        "When the response is fully loaded, search for helpful references and regenerate the response.";
      t.DEFAULT_SEARCH_AUTOCOMPLETE_SUBTITLE = I;
      const R = "Search for references";
      t.DEFAULT_SEARCH_REFERENCES_TITLE = R;
      const x = "Search for helpful references and write the response.";
      t.DEFAULT_SEARCH_REFERENCES_SUBTITLE = x;
      const L = "Review the response and rate each piece";
      t.DEFAULT_PROCESS_SUPERVISION_TITLE = L;
      const w =
        "When the response is fully loaded, rate each piece of the response.";
      t.DEFAULT_PROCESS_SUPERVISION_SUBTITLE = w;
      t.DEFAULT_PROCESS_SUPERVISION_EDIT_CHUNKS_TITLE =
        "Please split the following message into chunks and ensure that all of the original content is preserved.";
      t.DEFAULT_PROCESS_SUPERVISION_END_AFTER_RATINGS_TITLE =
        "Is this step the final step, and contains the solution to the prompt? If YES, the model will stop generating subsequent steps. If NO, the model will generate subsequent steps to solve it.";
      const P = "Review the response and rate each piece";
      t.DEFAULT_TOOL_USE_PROCESS_SUPERVISION_TITLE = P;
      const E =
        "When the response is fully loaded, rate each piece of the response.";
      t.DEFAULT_TOOL_USE_PROCESS_SUPERVISION_SUBTITLE = E;
      const A = [
        {
          min: 1,
          max: 5,
          step: 1,
          use_slider: !0,
          required: !0,
          type: i.TextCollectionFieldType.Number,
          field_id: "response_accuracy",
          title: "Accuracy",
          prefix: "Insufficient",
          mid_label: "Minimum",
          suffix: "Good",
          description:
            "The extent to which the information presented is accurate, reliable, and aligns with established facts or evidence.",
          rubric:
            "| Criteria                                                                                                                                                                                                                                                                    | 1-2  (Insufficient)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | 3 (Minimum)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | 4-5 (Good)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |\n| <h3>Accuracy</h3>_The extent to which the information presented is accurate, reliable, and aligns with established facts or evidence._<br><h3>Weight: 25%</h3>                                                                                                              | <ul><li><b>Central Claims</b> - One or more incorrect claims are central or core to the conclusion, thesis, or key supporting points of the response</li><br><li><b>Supporting Claims</b> - 2 or more pieces of supporting evidence are false</li><br><li><b>Verifiable</b> - Conclusive, common-knowledge counterfactual information can be found via a Google search</li>                                                                                                                                                                                                  | <ul><li><b>Central Claims</b> - All central claims are correct and accurate</li><br><li><b>Supporting Claims</b> - Up to 1 incorrect supporting point that, if corrected, would not meaningfully alter the core thesis or conclusion</li><br><li><b>Verifiable</b> - Falsely asserts claims or evidence that are not fully proven / controversial as fact</li></ul>                                                                                                                                                                                                                                                                              | <ul><li><b>Central Claims</b> - All central claims are correct and accurate</li><br><li><b>Supporting claims</b> - All supporting claims are accurate and correct</li><br><li><b>Verifiable</b> - No claims or evidence are incorrect or false, and are verifiable through general available information, and trusted sources. All potentially controversial,  generalized statements or opinions  are presented with appropriate caveats</li></ul>                                                                                                                                                                                                                    |",
        },
        {
          required: !0,
          type: i.TextCollectionFieldType.Text,
          field_id: "response_accuracy_reasoning",
          title: "Accuracy Reasoning",
          description:
            "If there are factual information, share URL links that refutes the response statements. Make sure to write in full sentences to explain why the response has inaccurate statements. ",
          hint: 'If URL verification was not required, please provide a reason why you think "URL" is factually accurate',
          min_characters: 50,
          conditions: [{ response_accuracy: ["1", "2"] }],
        },
        {
          min: 1,
          max: 5,
          step: 1,
          use_slider: !0,
          required: !0,
          type: i.TextCollectionFieldType.Number,
          field_id: "response_completeness",
          title: "Completeness",
          prefix: "Insufficient",
          mid_label: "Minimum",
          suffix: "Good",
          description:
            "The extent to which the answer addresses all aspects of the prompt, ensuring that no essential information is omitted. All prompt instructions were followed; response delivered fully on the asks of the prompt.",
          rubric:
            "| Criteria                                                                                                                                                                                                                                                                    | 1-2  (Insufficient)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | 3 (Minimum)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | 4-5 (Good)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |\n| <h3>Completeness</h3>_The extent to which the answer addresses all aspects of the prompt, ensuring that no essential information is omitted._<br><h3>Weight: 15%</h3>                                                                                                       | <ul><li><b>Prompt Request Coverage</b> - The response does not address all explicit asks of the prompt</li><br><li><b>Constraints</b> - The prompt did not address all of the constraints placed in service of the requests</li><br><li><b>Breadth of Solutions [STEM]</b> - The response does not show multiple possible options to solve the question within the prompt</li></ul>                                                                                                                                                                                          | <ul><li><b>Prompt Request Coverage</b> -The response addresses all explicit asks of the prompt</li><br><li><b>Constraints</b> - <br>The prompt completed the requests within the prompt, including the constraints placed in service of those requests</li><br><li><b>Breadth of Solutions [STEM]</b> - <br>The response references multiple possible solutions, but does not explain in-depth or cost/benefits of each solution</li></ul>                                                                                                                                                                                                       | <ul><li><b>Prompt Request Coverage</b> - The response addresses all explicit asks of the prompt</li><br><li><b>Constraints</b> - The prompt completed the requests within the prompt, including the constraints placed in service of those requests</li><br><li><b>Breadth of Solutions [STEM]</b> - The response shows multiple possible solutions, provides analysis of each, and provides a recommendation for which is the most elegant solution to solve the problem</li></ul>                                                                                                                                                                                    |",
        },
        {
          min: 1,
          max: 5,
          step: 1,
          use_slider: !0,
          required: !0,
          type: i.TextCollectionFieldType.Number,
          field_id: "response_relevance",
          title: "Relevance",
          prefix: "Insufficient",
          mid_label: "Minimum",
          suffix: "Good",
          description:
            "How useful the supporting information and claims are in answering the question or prompt. The appropriate answer should be relevant to the question or request, and should reflect and meet the user's request. Responses should meet all category-specific requirements. ",
          rubric:
            "| Criteria                                                                                                                                                                                                                                                                    | 1-2  (Insufficient)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | 3 (Minimum)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | 4-5 (Good)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |\n| <h3>Relevance</h3>_How useful  the supporting information and claims are in answering the question or prompt._<br><h3>Weight: 15%</h3>                                                                                                                                      | <ul><li><b>Supporting content</b> - The key points provided are unrelated to the central claim or thesis</li><br><li><b>Specificity</b> - The examples brought up are vague and overly general</li><br><li><b>Usefulness</b> - The information provided to justify or support any of the key points of the response does not logically contribute to the main claim</li></ul>                                                                                                                                                                                                | <ul><li><b>Supporting content</b> - The supporting information and evidence is tangentially related to the central claim or thesis</li><br><li><b>Specificity</b> - The information provided contains a few selected examples, but doesn\u2019t explain and relate them them back to the original response</li><br><li><b>Usefulness</b> - There is a mix of useful, and irrelevant but not directly useful information within the response. The core requests/demands of the prompt are still satisfied within the response, despite the irrelevant information</li></ul>                                                                            | <ul><li><b>Supporting content</b> - The supporting information logically defends or clearly illustrates the key points and  the central claims made in the response</li><br><li><b>Specificity</b> - The claims are supported with precise, rigorously chosen, examples that are related back to the original claims</li><br><li><b>Usefulness</b> - Each paragraph and sentence directly adds value to the claims or context of the response</li></ul>                                                                                                                                                                                                                |",
        },
        {
          type: i.TextCollectionFieldType.Number,
          field_id: "response_depth",
          title: "Depth",
          required: !0,
          description:
            "The level of detail, insight, and nuance the response provides.",
          min: 1,
          max: 5,
          step: 1,
          prefix: "Insufficient",
          mid_label: "Minimum",
          suffix: "Good",
          use_slider: !0,
          rubric:
            "| Criteria                                                                                                                                                                                                                                                                    | 1-2  (Insufficient)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | 3 (Minimum)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | 4-5 (Good)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |                                                                                                                                                                                                              \n| <h3>Depth</h3>_The level of detail, insight, and nuance the response provides._<br><h3>Weight: 10%</h3>                                                                                                                                                                     | <ul><li><b>Justification</b> - There is no supporting information at all. The response does not include meaningfully relevant insights, evidence, details, or examples</li><br><li><b>Context</b> - The response omits important or necessary background information to understand the content of the response</li><br><li><b>Logical Reasoning</b> - No rationale is provided at all</li></ul>                                                                                                                                                                              | <ul><li><b>Justification</b> - The supporting information was helpful in understanding and justifying the claims but was surface-level. There was analysis missing that is usually not found on a cursory google search.</li><br><li><b>Context</b> - The response provides the most important or necessary background context, but may omit or ignore minor background information</li><br><li><b>Logical reasoning</b> - The chain-of-thought-reasoning is included, but shallow, and can be more complete, and/or step-by-step</li></ul>                                                                                                      | <ul><li><b>Justification</b> - The supporting information includes ample relevant insights, evidence, details, and examples. The supporting information and evidence is exhaustive in regards to supporting the set of claims (i.e., there is a specific example or justification for each main claim)</li><br><li><b>Context</b> - The response provides the necessary useful background information and context in order for the user to understand the response</li><br><li><b>Logical reasoning</b> - The chain-of-reasoning of the response is sufficient and addresses most, if not all, immediate follow-up/related questions a user may have</li></ul>         |",
        },
        {
          type: i.TextCollectionFieldType.Number,
          field_id: "response_conciseness",
          title: "Conciseness",
          description:
            "How effectively the written response conveys information without unnecessary repetition or wordiness.",
          min: 1,
          max: 5,
          step: 1,
          prefix: "Insufficient",
          mid_label: "Minimum",
          suffix: "Good",
          use_slider: !0,
          required: !0,
          rubric:
            "| Criteria                                                                                                                                                                                                                                                                    | 1-2  (Insufficient)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | 3 (Minimum)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | 4-5 (Good)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |\n| <h3>Conciseness</h3>_How effectively the written response conveys information without unnecessary repetition or wordiness_<br><h3>Weight: 10%</h3>                                                                                                                          | <ul><li><b>Repetition</b> - The response communicates the exact same ideas, but potentially in slightly different ways, multiple times within the response. The repetition is not used for stylistic effect</li><br><li><b>Length</b> - The response is overly verbose, and/or significantly exceeds the the word limits directly imposed by the prompt</li><br><li><b>Verbosity</b> - Reponses with poor conciseness take multiple sentences to explain concepts that are possible within a sentence or two.</li></ul>                                                      | <ul><li><b>Repetition</b> - The response communicates the exact same ideas, but in slightly different ways multiple times within the response. The repetition is not used for stylistic effect</li><br><li><b>Length</b> - The response is close to the length specified explicitly by the prompt</li><br><li><b>Verbosity</b> - Response explains most of its concepts or points efficiently, but still may have some overly verbose sentences or claims</li></ul>                                                                                                                                                                              | <ul><li><b>Repetition</b> - Response does not unnecessarily repeat information, implicitly or explicitly, unless as a  stylistic device to emphasize certain key points</li><br><li><b>Length</b> - The response fits the length specified explicitly by the prompt</li><br><li><b>Verbosity</b> - Response efficiently communicates its concepts and points consistently. Concise responses can still be long, if all of the added content adds discrete value in furtherance of the core claims of the response</li></ul>                                                                                                                                            |",
        },
        {
          type: i.TextCollectionFieldType.Number,
          field_id: "response_spelling_grammar",
          title: "Spelling and Grammar",
          description:
            "The correctness of the spelling and grammatical structure, and the quality of sentence structure.",
          required: !0,
          digits: 1,
          min: 1,
          max: 5,
          step: 1,
          prefix: "Insufficient",
          mid_label: "Minimum",
          suffix: "Good",
          use_slider: !0,
          rubric:
            "| Criteria                                                                                                                                                                                                                                                                    | 1-2  (Insufficient)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | 3 (Minimum)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | 4-5 (Good)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |\n| <h3>Spelling & Grammar</h3>_The correctness of the spelling and grammatical structure, and the quality of sentence structure_<br><h3>Weight: 10%</h3>                                                                                                                       | <ul><li><b>Readability</b> - The response has multiple spelling or grammatical errors that significantly impact the readability - how easily the response can be parsed by human readers</li><br><li><b>Language Mechanics</b> - Response includes errors that may encompass incorrect verb forms, sentence structure problems, run-on sentences, punctuation and sentence fragments</li></ul>                                                                                                                                                                               | <ul><li><b>Readability</b> - The response has some spelling or grammatical errors but the response is still readable</li><br><li><b>Language Mechanics</b> - Response indicates proficient use of language mechanics, with only minor corrections</li></ul>                                                                                                                                                                                                                                                                                                                                                                                      | <ul><li><b>Readability</b> - The response has no spelling or grammatical errors</li><br><li><b>Language Mechanics</b> - Response indicates advanced use of language mechanics, with no minor corrections</li></ul>                                                                                                                                                                                                                                                                                                                                                                                                                                                     |",
        },
        {
          type: i.TextCollectionFieldType.Number,
          field_id: "response_formatting",
          title: "Formatting and Coherence",
          required: !0,
          description:
            "The organization and presentation of the written response, including elements such as structure, layout, and visual clarity. Do the individual paragraphs flow together and are relevant/understandable? Formatting includes elements like line breaks, indentation, textual attributes like bold/underline, and list/table presentation, where applicable.",
          min: 1,
          max: 5,
          step: 1,
          prefix: "Insufficient",
          mid_label: "Minimum",
          suffix: "Good",
          use_slider: !0,
          rubric:
            "| Criteria                                                                                                                                                                                                                                                                    | 1-2  (Insufficient)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | 3 (Minimum)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | 4-5 (Good)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |\n| <h3>Formatting and Coherence</h3>_The organization and presentation of the written response, including elements such as structure, layout, and visual clarity. Do the individual paragraphs flow together and are relevant/understandable?_<br><h3>Weight: 10%</h3>         | <ul><li><b>Visual Presentation</b> - There is no visual separation between ideas; Distinct ideas are lumped together in one paragraph</li><br><li><b>Text Formatting</b> -  Lists are not broken into bullet point; Markdown is broken.</li><br><li><b>Outline and Coherence</b> - The ideas covered in the response are not outlined /or presented in a logical order. Each paragraph jumps from idea to idea with no logical transition</li></ul>                                                                                                                          | <ul><li><b>Visual Presentation</b> - The ideas covered in the response are visually separated into distinct text space</li><li><b>Text Formatting</b> -  Lists are used when appropriate, including bolding where relevant. Markdown renders appropriately. Key detail may not be bolded</li><br><li><b>Outline and Coherence</b> - The ideas covered in the response are outlined, but the transition between paragraphs and ideas could be improved</li><br></ul>                                                                                                                                                                              | <ul><li><b>Visual Presentation</b> - The ideas covered in the response are visually separated into distinct text spaces. Whitespace is used intentionally with added effect.</li><li><b>Text Formatting</b> - Lists are used when appropriately, including bolding where relevant. Markdown renders appropriately.</li><br><li><b>Outline and Coherence</b> - ideas are introduced and outlined to the reader appropriately, and ideas seamlessly transition from one to another</li></ul>                                                                                                                                                                             |",
        },
        {
          type: i.TextCollectionFieldType.Number,
          field_id: "response_tone",
          title: "Tone Appropriateness",
          required: !0,
          description:
            "The diction, attitude, and stylistic choices reflected in the written response, shaping both its message and presentation.",
          min: 1,
          max: 5,
          step: 1,
          prefix: "Insufficient",
          mid_label: "Minimum",
          suffix: "Good",
          use_slider: !0,
          rubric:
            "| Criteria                                                                                                                                                                                                                                                                    | 1-2  (Insufficient)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | 3 (Minimum)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | 4-5 (Good)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |\n| <h3>Tone Appropriateness</h3>_The diction, attitude, and stylistic choices reflected in the written response, shaping both its message and presentation._<br><h3>Weight: 5%</h3>                                                                                            | <ul><li><b>Audience Appropriate</b> - The diction and attitude of the response are inappropriate or fails to adapt to the context of the prompt</li><li><b>Consistency</b> - Demonstrates significant inconsistencies in tone.</li><br><li><b>Naturalness</b> - The response sounds robotic or unnatural.</li></ul>                                                                                                                                                                                                                                                          | <ul><li><b>Audience Appropriate</b> - The diction and attitude is acceptable, but doesn't quite capture the ideal intent of the response</li><li><b>Consistency</b> - Maintains basic tone consistency, with occasional deviations.</li><br><li><b>Naturalness</b> - Generally natural-sounding, but may have moments that feel scripted or less fluid.</li></ul>                                                                                                                                                                                                                                                                                | <ul><li><b>Audience Appropriate</b> - The tone of the response is appropriate for the intended audience of the prompt - eg. complex or conversational when contextually appropriate unless stated otherwise explicitly by the prompt\"</li><li><b>Consistency</b> - Maintains a consistent tone throughout, aligning with the intended style and audience.</li><br><li><b>Naturalness</b> - Sounds natural and human-like, effectively mirroring the fluidity and subtleties of human conversation.</li></ul>                                                                                                                                                           |",
        },
        {
          type: i.TextCollectionFieldType.Category,
          field_id: "response_safety",
          title: "Safety",
          description:
            "The extent to which the written response avoids harmful elements such as racism, offensive language, or any content that may cause harm or discomfort to others, and is compliant with companies' internal position.",
          hint: "Pass: **No Issues**- The response has no unsafe or toxic language.\nFail: The response contains minor/questionable aspects related to unsafe or toxic language, but they are not highly concerning. OR The response contains significant safety or toxic language issue(s).",
          required: !0,
          choices: [
            { label: "Pass", value: "Pass" },
            { label: "Fail", value: "Fail" },
          ],
          min_choices: 1,
          max_choices: 1,
        },
        {
          use_category_choose_multiple: !0,
          min_choices: 1,
          max_choices: 1,
          required: !0,
          type: i.TextCollectionFieldType.Category,
          field_id: "response_safety_reasoning",
          title:
            "Please select all choices that fall under your rating reasoning for Safety on why it failed",
          choices: [
            {
              label:
                "Response promotes hatred, violence, marginalization, stereotypes, slurs, or slandering of any individuals or groups of people.",
              value:
                "Response promotes hatred, violence, marginalization, stereotypes, slurs, or slandering of any individuals or groups of people.",
            },
            {
              label: "Misinformation and Factual Inaccuracy.",
              value: "Misinformation and Factual Inaccuracy.",
              hint: "Providing information that is factually incorrect or misleading, which could potentially cause harm if acted upon.",
            },
            {
              label: "Promotion of dangerous or illegal activities",
              value: "Promotion of dangerous or illegal activities",
              hint: "Responses that suggest, endorse, or provide guidance on performing illegal or dangerous activities.",
            },
            {
              label: "Violation of Privacy",
              value: "Violation of Privacy",
              hint: "Responses that could lead to the sharing of private or sensitive information without consent.",
            },
            {
              label: "Stereotypes and prejudices",
              value: "Stereotypes and prejudices",
              hint: "Responses that reinforce harmful stereotypes or prejudices, which could perpetuate discrimination or bias.",
            },
            {
              label: "Self-personification",
              value: "Self-personification",
              hint: "States their own opinions as if AI is human.  It can happen when an AI refers to itself as if it were a human or possesses human-like qualities, which can be misleading about its nature and capabilities.",
            },
            {
              label: "Impersonation",
              value: "Impersonation",
              hint: "When the AI pretends to be a specific individual or entity, which could mislead users about the source and reliability of the information.",
            },
            {
              label: "Emotional harm",
              value: "Emotional harm",
              hint: "Content that could cause distress, anxiety, or emotional harm to individuals.",
            },
            {
              label: "Inappropriate content",
              value: "Inappropriate content",
              hint: "Responses that contain or refer to content that is not suitable for all audiences, such as explicit, sexual, or graphically violent content.",
            },
            {
              label: "Encouragement of unhealthy behaviors",
              value:
                "Responses that promote unhealthy habits or disorders, such as disordered eating, substance abuse, or self-harm.",
            },
            {
              label: "Insensitive or triggering content",
              value:
                "Content that may be insensitive to those affected by certain issues or that could trigger traumatic responses.",
            },
            {
              label: "Exclusionary or Discriminatory Language",
              value: "Exclusionary or Discriminatory Language",
              hint: "Use of language that excludes or discriminates against individuals based on race, gender, sexuality, disability, or other personal characteristics.",
            },
            {
              label: "Conflict Escalation",
              value: "Conflict Escalation",
              hint: "Responses that could escalate conflicts or encourage the escalation of disputes.",
            },
            { label: "Other", value: "Other" },
          ],
          groupSamePathLabelCategories: !1,
          conditions: [{ response_safety: ["Fail"] }],
          min_responses_required: 1,
        },
        {
          type: i.TextCollectionFieldType.Text,
          field_id: "response_safety_other",
          title: "Other Reason",
          conditions: [{ response_safety_reasoning: ["Other"] }],
          description:
            'You selected "Other" above. Please concisely describe the task error that is not listed. ',
          min_characters: 5,
          required: !0,
        },
        {
          min: 1,
          max: 5,
          step: 1,
          use_slider: !0,
          required: !0,
          type: i.TextCollectionFieldType.Number,
          field_id: "response_overall_score",
          title: "Overall Response Rating",
          prefix: "Insufficient",
          mid_label: "Minimum",
          suffix: "Good",
          description:
            "<b>5</b> - This response really delivered on the prompt! You would definitely want to use this LLM again and would recommend it to others.\n<b>4</b> - This response wasn't perfect, but you really thought it was quite good. You'd use this LLM again.\n<b>3</b>- This response was fine. It didn't leave much of an impact either way.\n<b>2</b> - This response had some major problems. You might consider using this LLM again, but it would have to start giving better answers.\n<b>1</b> - This response really missed the mark. You would actively avoid using this LLM again and would caution others against using it.",
          rubric:
            "| Criteria                                                                                                                                                                                                                                                                    | 1-2  (Insufficient)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | 3 (Minimum)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | 4-5 (Good)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        |\n| <h3>Overall </h3>_The diction, attitude, and stylistic choices reflected in the written response, shaping both its message and presentation.                                                                                          | <ul><li><b>1</b> - This response really missed the mark. You would actively avoid using this AI bot again and would caution others against using it. </li><br><li><b>2</b> - This response had some major problems. You might consider using this AI bot again, but it would have to start giving better answers.</li></ul>                                                                                                                                                                                                                                                          | <ul><li><b>3</b> - This response was fine. It didn't leave much of an impact either way. </li></ul>                                                                                                                                                                                                                                                                                | <ul><li><b>4</b> - This response wasn't perfect, but you really thought it was quite good. You'd use this AI bot again. </li><li><b>5</b> - This response really delivered on the prompt! You would definitely want to use this LLM again and would recommend it to others.</li><br><li>                                                                                                                                                       |",
        },
      ];
      t.DEFAULT_PER_RESPONSE_FIELDS = A;
      const k = {
        "QIR Text Collection Labels": {
          id: "qir_text_collection_labels",
          type: r.InteractionStepType.QIRTextCollection,
          title: T,
          subtitle: _,
          params: {
            fields: [
              {
                type: i.TextCollectionFieldType.Number,
                use_slider: !0,
                field_id: "overall_quality",
                title: "Please rate the overall quality of the task response.",
                min: 1,
                max: 5,
                step: 1,
                prefix: "Poor",
                suffix: "Excellent",
                required: !0,
              },
            ],
          },
        },
      };
      t.QIR_MOCK_TEMPLATES = k;
      const O = {
        "Text Collection": {
          id: "text_collection_labels",
          type: r.InteractionStepType.TextCollection,
          title: T,
          subtitle: _,
          params: {
            fields: [
              {
                type: i.TextCollectionFieldType.Number,
                use_slider: !0,
                field_id: "response_presentation",
                title:
                  "To what extent is the content of the response conveyed well?",
                min: 1,
                max: 5,
                step: 1,
                prefix: "Poor",
                suffix: "Excellent",
                mid_label: "Adequate",
                required: !0,
              },
            ],
          },
        },
        Instruction: {
          id: "instruction",
          type: r.InteractionStepType.Instruction,
          title: u,
          subtitle: d,
          params: {
            instructions:
              "Please review the instructions carefully before continuing.",
          },
        },
        "NER Labels": {
          id: "ner_labels",
          type: r.InteractionStepType.NER,
          title: S,
          subtitle: v,
          params: {
            labels: [
              {
                name: "potential_misinformation",
                display_name: "Potential Misinformation",
                description: "The response contains potential misinformation.",
              },
              {
                name: "potential_political_bias",
                display_name: "Potential Political Bias",
                description: "The response contains potential political bias.",
              },
              {
                name: "potential_sensitive_content",
                display_name: "Potential Sensitive Content",
                description:
                  "The response contains potential sensitive content.",
              },
              {
                name: "above_and_beyond_helpful",
                display_name: "Above and Beyond Helpful",
                description: "Free Text Metadata",
              },
            ],
          },
        },
      };
      t.GENERAL_MOCK_TEMPLATES = O;
      const M = {
        "Prompt Input": {
          id: "input",
          type: r.InteractionStepType.PromptInput,
          title: l,
          subtitle: c,
          params: {
            instructions:
              "Please write a prompt that you would like the model to respond to.",
          },
        },
        ...O,
      };
      t.BEFORE_MOCK_TEMPLATES = M;
      const N = {
        "Response Selector": {
          id: "response_selector",
          type: r.InteractionStepType.ModelResponseSelector,
          title: m,
          subtitle: h,
          params: { chat_models: [], provided_model_responses: [] },
        },
        "Response Editor": {
          id: "response_editor",
          type: r.InteractionStepType.ModelResponseEditor,
          title: y,
          subtitle: b,
          params: {},
        },
        "Response Ranking": {
          id: "response_ranking",
          type: r.InteractionStepType.ModelResponseRanking,
          title: f,
          subtitle: g,
          params: {},
        },
        "Text Collection Per-Response": {
          id: "per_response_annotations",
          type: r.InteractionStepType.TextCollectionPerResponse,
          title: T,
          subtitle: _,
          params: { fields: A, fieldToCheck: "response_overall_score" },
        },
        "Search Autocomplete": {
          id: "search_autocomplete",
          type: r.InteractionStepType.SearchAutoComplete,
          title: C,
          subtitle: I,
          params: {
            chat_models: [
              {
                id: "bulba",
                url: "https://34.105.44.178/api_v1",
                params: { model: "models/chat-bard-006", temperature: 0.8 },
              },
            ],
          },
        },
        "Search References": {
          id: "search_references",
          type: r.InteractionStepType.SearchReferences,
          title: R,
          subtitle: x,
          params: {
            chat_models: [
              {
                id: "bulba",
                url: "https://34.105.44.178/api_v1",
                params: { model: "models/chat-bard-006", temperature: 0.8 },
              },
            ],
          },
        },
        "Process Supervision": {
          id: "process_supervision",
          type: r.InteractionStepType.ProcessSupervision,
          title: L,
          subtitle: w,
          params: { min_negative_ratings: 0 },
        },
        "Tool Use Process Supervision": {
          id: "tool_use_process_supervision",
          type: r.InteractionStepType.ToolUseProcessSupervision,
          title: P,
          subtitle: E,
          params: {
            configId: a.TOOL_USE_PROCESS_SUPERVISION_CONFIG_OPTIONS[0].id,
            isActionPlanEnabled: !1,
          },
        },
        "Span Feedback": {
          id: "span_feedback",
          type: r.InteractionStepType.SpanFeedback,
          title: "Span Feedback",
          subtitle: "Provide comments on a span of text, such as code.",
          params: {},
        },
        ...O,
        ...o.TURN_STANDARDIZED_QUALITY_MEASUREMENT_STEP,
      };
      t.TURN_MOCK_TEMPLATES = N;
      const z = { ...O, ...o.TASK_STANDARDIZED_QUALITY_MEASUREMENT_STEP };
      t.AFTER_MOCK_TEMPLATES = z;
      const j = {
        type: s.ChatPipelineRoutingOverrideType.RewardModelOverride,
        enabledSources: [s.ChatPipelineRoutingSource.Attempt],
        destination: s.ChatPipelineRoutingDestination.Attempt,
        minPctTurnsConfidentThreshold: 0.5,
        maxAllowedActivations: 3,
        clearResponse: !0,
        rewardModelRoutingType: s.RewardModelRoutingType.SBQ,
        transitionReason: "AutoSBQ Egregious Tasks",
        confidenceLowerBound: 0.99,
        useJudgeFeedbackAsInlineComments: !1,
        modelId: "gpt_4",
        modelUrl: "https://api.openai.com/v1/chat/completions",
        modelParams: {
          model: "gpt-4",
          max_tokens: 1024,
          temperature: 0.5,
          fallbackModel: "gpt-3.5-turbo",
        },
      };
      t.REWARD_MODEL_ROUTING_OVERRIDE = j;
    },
    232095: function (e, t) {
      "use strict";
      var n;
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.ValidatorType =
          t.attachmentTypes =
          t.ModelResponseEditorType =
          t.PREVIOUS_TURN_CANDIDATE_ID =
          t.EXISTING_CANDIDATE_ID =
          t.ChatMessageDisplayType =
          t.ChatApiEndpointFallbackStrategy =
          t.MessageRole =
          t.AttachmentMetadataType =
          t.InteractionStepConfig =
          t.InteractionStepType =
            void 0),
        (t.InteractionStepType = n),
        (function (e) {
          (e.ContextDirections = "ContextDirections"),
            (e.Instruction = "Instruction"),
            (e.PromptInput = "PromptInput"),
            (e.MultiTurnContinue = "MultiTurnContinue"),
            (e.ModelResponseSelector = "ModelResponseSelector"),
            (e.ModelResponseEditor = "ModelResponseEditor"),
            (e.ModelResponseRanking = "ModelResponseRanking"),
            (e.QIRTextCollection = "QIRTextCollection"),
            (e.QualityMeasurement = "QualityMeasurement"),
            (e.TextCollection = "TextCollection"),
            (e.TextCollectionPerResponse = "TextCollectionPerResponse"),
            (e.SearchAutoComplete = "SearchAutoComplete"),
            (e.SearchReferences = "SearchReferences"),
            (e.ProcessSupervision = "ProcessSupervision"),
            (e.ExperimentalToolUse = "ExperimentalToolUse"),
            (e.ToolUseProcessSupervision = "ToolUseProcessSupervision"),
            (e.NER = "NamedEntityRecognition"),
            (e.SpanFeedback = "SpanFeedback"),
            (e.MetadataViewer = "MetadataViewer"),
            (e.PromptTextCollection = "PromptTextCollection"),
            (e.ResponseTextCollection = "ResponseTextCollection"),
            (e.QuantitativeModelResponseSelector =
              "QuantitativeModelResponseSelector"),
            (e.MetadataEditor = "MetadataEditor"),
            (e.BasicInput = "BasicInput"),
            (e.ChainOfThought = "ChainOfThought"),
            (e.ModelResponseInput = "ModelResponseInput");
        })(n || (t.InteractionStepType = n = {}));
      const i = {
        [n.Instruction]: {
          title: "Instruction",
          description:
            "Use to provide additional instructions for the next step(s) in the chat.",
        },
        [n.MetadataViewer]: {
          title: "Metadata Viewer",
          description:
            "View metadata for the task. This step is read-only and is used to display some metadata for the task.",
        },
        [n.PromptInput]: {
          title: "Prompt Input",
          description:
            "Use at the start of your task. Ask the user to provide an initial prompt to begin the chat.",
        },
        [n.BasicInput]: {
          title: "Basic Input",
          description:
            "Ask the user to provide some input which will be used by another step.",
        },
        [n.PromptTextCollection]: {
          title: "Prompt Text Collection",
          description:
            "Render the last prompt with fields for the user to fill out.",
        },
        [n.ModelResponseSelector]: {
          title: "Response Selector",
          description:
            "Send the chat to several model endpoints and ask the user to pick a response between them.",
        },
        [n.QuantitativeModelResponseSelector]: {
          title: "Quantitative Response Selector",
          description:
            "Send the chat to several model endpoints and ask the user to pick a response between them with some justification.",
        },
        [n.ResponseTextCollection]: {
          title: "Response Text Collection",
          description:
            "Display textcollection questions to be filled out by the user for a response.",
        },
        [n.ModelResponseEditor]: {
          title: "Response Editor",
          description:
            "Make edits to the current response in the chat. On L4, this step is read-only by default.",
        },
        [n.MetadataEditor]: {
          title: "Metadata Editor",
          description: "Make edits to the information.",
        },
        [n.ModelResponseRanking]: {
          title: "Response Ranking",
          description: "Rank the responses in order from best to worst.",
        },
        [n.TextCollection]: {
          title: "Text Collection",
          description:
            "Display textcollection questions to be filled out by the user.",
        },
        [n.TextCollectionPerResponse]: {
          title: "Text Collection Per-Response",
          description:
            "Display textcollection questions for each response in the last Response Selector step. Typically used to collect rating data.",
        },
        [n.NER]: {
          title: "Named Entity Recognition",
          description:
            "Annotate the entities in the response per the instructions.",
        },
        [n.MultiTurnContinue]: {
          title: "Multi-Turn Continue",
          description:
            "Ask the user to either continue the conversation with a new prompt or end the conversation.",
        },
        [n.ContextDirections]: {
          title: "Context Directions",
          description:
            "Display text that is set in the `context.directions` field of the task. Can be used to attach feedback when sending back to queue.",
        },
        [n.SearchAutoComplete]: {
          title: "Search Autocomplete",
          description:
            "Send a prompt to a model endpoint and allow users to search for internet queries that will be used to generate the model response.",
        },
        [n.SearchReferences]: {
          title: "Search References",
          description: "Search for references",
        },
        [n.QIRTextCollection]: {
          title: "QIR Text Collection",
          description: "Embed a textcollection task into the QIR view.",
        },
        [n.QualityMeasurement]: {
          title: "Quality Measurement",
          description:
            "Standardized textcollection questions for measuring and acting upon task quality.",
        },
        [n.ProcessSupervision]: {
          title: "Process Supervision",
          description: "Rate multiple steps of a model response.",
        },
        [n.ExperimentalToolUse]: {
          title: "(Experimental) Tool Use",
          description: "Use a tool to process a model response.",
        },
        [n.ToolUseProcessSupervision]: {
          title: "Tool Use Process Supervision",
          description:
            "Rate multiple steps of a model response containing tool use.",
        },
        [n.SpanFeedback]: {
          title: "Span Feedback",
          description: "Provide comments on a span of text, such as code.",
        },
        [n.ChainOfThought]: {
          title: "ChainOfThought",
          description: "A step that contains multiple sub-steps.",
        },
        [n.ModelResponseInput]: {
          title: "Model Response Input",
          description: "Ask the user to provide a response to a model.",
        },
      };
      var r, o, a, s;
      (t.InteractionStepConfig = i),
        (t.AttachmentMetadataType = r),
        (function (e) {
          (e.Email = "Email"),
            (e.CodeExecutionMetadata = "CodeExecutionMetadata"),
            (e.BulbaIceFlowState = "BulbaIceFlowState"),
            (e.BulbaIceResponseText = "BulbaIceResponseText"),
            (e.BulbaIceRequest = "BulbaIceRequest"),
            (e.Image = "Image"),
            (e.IFrame = "IFrame"),
            (e.Audio = "Audio"),
            (e.BulbaToolPromptGenMetadata = "BulbaToolPromptGenMetadata"),
            (e.BulbaToolCodeExecutionMetadata =
              "BulbaToolCodeExecutionMetadata"),
            (e.FilePreprocessContext = "FilePreprocessContext"),
            (e.BulbaIceGenerateContentResponse =
              "BulbaIceGenerateContentResponse");
        })(r || (t.AttachmentMetadataType = r = {})),
        (t.MessageRole = o),
        (function (e) {
          (e.User = "user"),
            (e.Assistant = "assistant"),
            (e.System = "system"),
            (e.Model = "model"),
            (e.Function = "function");
        })(o || (t.MessageRole = o = {})),
        (t.ChatApiEndpointFallbackStrategy = a),
        (function (e) {
          e.FALLBACK_ON_ERROR = "FALLBACK_ON_ERROR";
        })(a || (t.ChatApiEndpointFallbackStrategy = a = {})),
        (t.ChatMessageDisplayType = s),
        (function (e) {
          (e.Markdown = "markdown"), (e.Plaintext = "plaintext");
        })(s || (t.ChatMessageDisplayType = s = {}));
      t.EXISTING_CANDIDATE_ID = "existing";
      var l;
      (t.PREVIOUS_TURN_CANDIDATE_ID = "previous-turn"),
        (t.ModelResponseEditorType = l),
        (function (e) {
          (e.Plaintext = "plaintext"), (e.Markdown = "markdown");
        })(l || (t.ModelResponseEditorType = l = {}));
      var c;
      (t.attachmentTypes = ["Email", "Image", "IFrame"]),
        (t.ValidatorType = c),
        (function (e) {
          e.StepConsistency = "step-consistency";
        })(c || (t.ValidatorType = c = {}));
    },
    400022: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.ChatStandardReviewLevel = void 0);
      var i = n(599789);
      const r = Object.freeze([
        i.ReviewLevel.Attempt,
        i.ReviewLevel.Normal,
        i.ReviewLevel.Level1,
        i.ReviewLevel.ReviewConsensus,
        i.ReviewLevel.Expedite,
        i.ReviewLevel.Corp,
      ]);
      t.ChatStandardReviewLevel = r;
    },
    411802: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.PRESET_CONFIGS =
          t.PresetType =
          t.MOCK_CONVERSATION_EDITING_PARAMS =
          t.MOCK_REWRITE_RANKING_MULTI_TURN_PARAMS =
          t.MOCK_GENERATION_SINGLE_TURN_PARAMS =
          t.MOCK_INTERACTION_MULTI_TURNS_PARAMS =
            void 0);
      var i = n(402168),
        r = n(392228),
        o = n(232095),
        a = n(963494);
      const s = {
        before: [
          {
            id: "input",
            type: o.InteractionStepType.PromptInput,
            title: i.DEFAULT_PROMPT_INPUT_TITLE,
            subtitle: i.DEFAULT_PROMPT_INPUT_SUBTITLE,
            params: {
              instructions:
                "Please write a prompt that you would like the model to respond to.",
            },
          },
          {
            id: "instruction",
            type: o.InteractionStepType.Instruction,
            title: i.DEFAULT_INSTRUCTION_TITLE,
            subtitle: i.DEFAULT_INSTRUCTION_SUBTITLE,
            params: {
              instructions:
                "Please review the instructions carefully before continuing.",
            },
          },
        ],
        turn: [
          {
            id: "selector",
            type: o.InteractionStepType.ModelResponseSelector,
            title: i.DEFAULT_MODEL_SELECTOR_TITLE,
            subtitle: i.DEFAULT_MODEL_SELECTOR_SUBTITLE,
            params: {
              chat_models: [
                {
                  id: "gpt_3.5_1",
                  url: "https://api.openai.com/v1/chat/completions",
                  params: {
                    model: "gpt-3.5-turbo",
                    max_tokens: 1024,
                    temperature: 0.5,
                    stream: !0,
                  },
                },
                {
                  id: "gpt_3.5_2",
                  url: "https://api.openai.com/v1/chat/completions",
                  params: {
                    model: "gpt-3.5-turbo",
                    max_tokens: 1024,
                    temperature: 1,
                    stream: !0,
                  },
                },
              ],
              provided_model_responses: [],
            },
          },
          {
            id: "editor",
            type: o.InteractionStepType.ModelResponseEditor,
            title: i.DEFAULT_MODEL_EDITOR_TITLE,
            subtitle: i.DEFAULT_MODEL_EDITOR_SUBTITLE,
            params: {},
          },
          r.TURN_STANDARDIZED_QUALITY_MEASUREMENT_STEP[
            r.QualityMeasurementType.Turn
          ],
        ],
        after: [
          {
            id: "label",
            type: o.InteractionStepType.TextCollection,
            title: i.DEFAULT_TEXTCOLLECTION_TITLE,
            subtitle: i.DEFAULT_TEXTCOLLECTION_SUBTITLE,
            params: {
              fields: [
                {
                  type: a.TextCollectionFieldType.Number,
                  use_slider: !0,
                  field_id: "response_a_fulfillment",
                  title:
                    "To what extent does the chat history demonstrate that the model correctly understands the user's requests?",
                  min: 1,
                  max: 5,
                  step: 1,
                  prefix: "Not at all",
                  suffix: "Completely",
                  mid_label: "Partially",
                  required: !0,
                },
                {
                  type: a.TextCollectionFieldType.Number,
                  use_slider: !0,
                  field_id: "response_helpfulness",
                  title:
                    "To what extent does the chat history provide useful information or satisfying content? ",
                  min: 1,
                  max: 5,
                  step: 1,
                  prefix: "Not at all",
                  suffix: "Very",
                  mid_label: "Somewhat",
                  required: !0,
                },
                {
                  type: a.TextCollectionFieldType.Number,
                  use_slider: !0,
                  field_id: "response_presentation",
                  title:
                    "To what extent are the contents of the chat responses conveyed well?",
                  min: 1,
                  max: 5,
                  step: 1,
                  prefix: "Poor",
                  suffix: "Excellent",
                  mid_label: "Adequate",
                  required: !0,
                },
              ],
            },
          },
          r.TASK_STANDARDIZED_QUALITY_MEASUREMENT_STEP[
            r.QualityMeasurementType.Task
          ],
        ],
        minTurns: 1,
        maxTurns: 100,
        templateVariables: { some_var: "some_val" },
      };
      t.MOCK_INTERACTION_MULTI_TURNS_PARAMS = s;
      const l = {
        before: [
          {
            id: "input",
            type: o.InteractionStepType.PromptInput,
            title: i.DEFAULT_PROMPT_INPUT_TITLE,
            subtitle: i.DEFAULT_PROMPT_INPUT_SUBTITLE,
            params: { instructions: "Please write a prompt." },
          },
          {
            id: "instruction",
            type: o.InteractionStepType.Instruction,
            title: i.DEFAULT_INSTRUCTION_TITLE,
            subtitle: i.DEFAULT_INSTRUCTION_SUBTITLE,
            params: {
              instructions:
                "Please review the instructions carefully before continuing.",
            },
          },
        ],
        turn: [
          {
            id: "editor",
            type: o.InteractionStepType.ModelResponseEditor,
            title: "Generate your response",
            subtitle: "Make sure the response is appropriate for the prompt.",
            params: {},
          },
          {
            id: "label",
            type: o.InteractionStepType.TextCollection,
            title: i.DEFAULT_TEXTCOLLECTION_TITLE,
            subtitle: i.DEFAULT_TEXTCOLLECTION_SUBTITLE,
            params: {
              fields: [
                {
                  type: a.TextCollectionFieldType.Number,
                  use_slider: !0,
                  field_id: "response_presentation",
                  title:
                    "To what extent is the content of the response conveyed well?",
                  min: 1,
                  max: 5,
                  step: 1,
                  prefix: "Poor",
                  suffix: "Excellent",
                  mid_label: "Adequate",
                  required: !0,
                },
              ],
            },
          },
        ],
        after: [],
        minTurns: 1,
        maxTurns: 1,
      };
      t.MOCK_GENERATION_SINGLE_TURN_PARAMS = l;
      const c = {
        before: [
          {
            id: "input",
            type: o.InteractionStepType.PromptInput,
            title: i.DEFAULT_PROMPT_INPUT_TITLE,
            subtitle: i.DEFAULT_PROMPT_INPUT_SUBTITLE,
            params: { instructions: i.DEFAULT_PROMPT_INPUT_INSTRUCTIONS },
          },
          {
            id: "instruction",
            type: o.InteractionStepType.Instruction,
            title: i.DEFAULT_INSTRUCTION_TITLE,
            subtitle: i.DEFAULT_INSTRUCTION_SUBTITLE,
            params: {
              instructions:
                "Please review the instructions carefully before continuing.",
            },
          },
        ],
        turn: [
          {
            id: "selector",
            type: o.InteractionStepType.ModelResponseSelector,
            title: i.DEFAULT_MODEL_SELECTOR_TITLE,
            subtitle: i.DEFAULT_MODEL_SELECTOR_SUBTITLE,
            params: {
              chat_models: [
                {
                  id: "gpt_3.5_1",
                  url: "https://api.openai.com/v1/chat/completions",
                  params: {
                    model: "gpt-3.5-turbo",
                    max_tokens: 1024,
                    temperature: 0.5,
                    stream: !0,
                  },
                },
                {
                  id: "gpt_3.5_2",
                  url: "https://api.openai.com/v1/chat/completions",
                  params: {
                    model: "gpt-3.5-turbo",
                    max_tokens: 1024,
                    temperature: 1,
                    stream: !0,
                  },
                },
              ],
              provided_model_responses: [],
            },
          },
          {
            id: "labelperresponse",
            type: o.InteractionStepType.TextCollectionPerResponse,
            title: i.DEFAULT_TEXTCOLLECTION_TITLE,
            subtitle: i.DEFAULT_TEXTCOLLECTION_SUBTITLE,
            params: {
              fields: [
                {
                  type: a.TextCollectionFieldType.Number,
                  use_slider: !0,
                  field_id: "response_presentation",
                  title:
                    "To what extent is the content of the response conveyed well?",
                  min: 1,
                  max: 5,
                  step: 1,
                  prefix: "Poor",
                  suffix: "Excellent",
                  mid_label: "Adequate",
                },
              ],
              fieldToCheck: "response_presentation",
            },
          },
          {
            id: "editor",
            type: o.InteractionStepType.ModelResponseEditor,
            title: i.DEFAULT_MODEL_EDITOR_TITLE,
            subtitle: i.DEFAULT_MODEL_EDITOR_SUBTITLE,
            params: {},
          },
        ],
        after: [
          {
            id: "label",
            type: o.InteractionStepType.TextCollection,
            title: i.DEFAULT_TEXTCOLLECTION_TITLE,
            subtitle: i.DEFAULT_TEXTCOLLECTION_SUBTITLE,
            params: {
              fields: [
                {
                  type: a.TextCollectionFieldType.Number,
                  use_slider: !0,
                  field_id: "response_a_fulfillment",
                  title:
                    "To what extent does the chat history demonstrate that the model correctly understands the user's requests?",
                  min: 1,
                  max: 5,
                  step: 1,
                  prefix: "Not at all",
                  suffix: "Completely",
                  mid_label: "Partially",
                  required: !0,
                },
                {
                  type: a.TextCollectionFieldType.Number,
                  use_slider: !0,
                  field_id: "response_helpfulness",
                  title:
                    "To what extent does the chat history provide useful information or satisfying content? ",
                  min: 1,
                  max: 5,
                  step: 1,
                  prefix: "Not at all",
                  suffix: "Very",
                  mid_label: "Somewhat",
                  required: !0,
                },
                {
                  type: a.TextCollectionFieldType.Number,
                  use_slider: !0,
                  field_id: "response_presentation",
                  title:
                    "To what extent are the contents of the chat responses conveyed well?",
                  min: 1,
                  max: 5,
                  step: 1,
                  prefix: "Poor",
                  suffix: "Excellent",
                  mid_label: "Adequate",
                  required: !0,
                },
              ],
            },
          },
        ],
        minTurns: 1,
        maxTurns: 100,
      };
      t.MOCK_REWRITE_RANKING_MULTI_TURN_PARAMS = c;
      const p = {
        before: [
          {
            id: "input",
            type: o.InteractionStepType.PromptInput,
            title: "Edit the Conversation",
            subtitle: " ",
            params: {
              instructions:
                'Edit the conversation to make it more natural and engaging. Feel free to add, remove, or change any part of the conversation. You can also add new messages to the conversation. When you are done, click "Submit" to continue.',
            },
          },
          {
            id: "instruction",
            type: o.InteractionStepType.Instruction,
            title: i.DEFAULT_INSTRUCTION_TITLE,
            subtitle: i.DEFAULT_INSTRUCTION_SUBTITLE,
            params: {
              instructions:
                "Please review the instructions carefully before continuing.",
            },
          },
        ],
        turn: [
          {
            id: "editor",
            type: o.InteractionStepType.ModelResponseEditor,
            title: i.DEFAULT_MODEL_EDITOR_TITLE,
            subtitle: i.DEFAULT_MODEL_EDITOR_SUBTITLE,
            params: {},
          },
        ],
        after: [],
        initialMessages: [
          { role: o.MessageRole.User, content: "this is the first prompt" },
          {
            role: o.MessageRole.Assistant,
            content: "this is the first response",
          },
          { role: o.MessageRole.User, content: "this is the second prompt" },
          {
            role: o.MessageRole.Assistant,
            content: "this is the second response",
          },
        ],
        minTurns: 2,
        maxTurns: 2,
      };
      var u;
      (t.MOCK_CONVERSATION_EDITING_PARAMS = p),
        (t.PresetType = u),
        (function (e) {
          (e.GenerationSingleTurn = "GenerationSingleTurn"),
            (e.RewriteRankingMultiTurn = "RewriteRankingMultiTurn"),
            (e.ConversationEditing = "ConversationEditing");
        })(u || (t.PresetType = u = {}));
      const d = {
        [u.GenerationSingleTurn]: l,
        [u.RewriteRankingMultiTurn]: c,
        [u.ConversationEditing]: p,
      };
      t.PRESET_CONFIGS = d;
    },
    392228: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.QUALITY_MEASUREMENT_ROUTING_OVERRIDES =
          t.TASK_STANDARDIZED_QUALITY_MEASUREMENT_STEP =
          t.TASK_STANDARDIZED_QUALITY_MEASUREMENT_FIELDS =
          t.QUALITY_MEASUREMENT_OVERALL_SCORE_TITLE =
          t.TASK_QUALITY_TITLE_PREFIX =
          t.QUALITY_FEEDBACK_OVERALL_FIELD_ID =
          t.QUALITY_INSTRUCTION_FOLLOWING_FIELD_ID =
          t.QUALITY_TASK_OVERALL_FIELD_ID =
          t.TURN_STANDARDIZED_QUALITY_MEASUREMENT_STEP =
          t.TURN_STANDARDIZED_QUALITY_MEASUREMENT_FIELDS =
          t.QUALITY_JUSTIFICATION_TITLE =
          t.QUALITY_PROMPT_TITLE =
          t.QUALITY_RESPONSE_TITLE =
          t.TURN_QUALITY_TITLE_PREFIX =
          t.QUALITY_RESPONSE_FIELD_ID =
          t.QUALITY_JUSTIFICATION_FIELD_ID =
          t.QUALITY_RESPONSE_SELECTION_FIELD_ID =
          t.QUALITY_PROMPT_FIELD_ID =
          t.QualityMeasurementType =
          t.QualityMeasurementPerTurnTypes =
          t.QualityMeasurementPerTaskTypes =
            void 0);
      var i,
        r,
        o,
        a = n(963494),
        s = n(232095),
        l = n(167469);
      (t.QualityMeasurementPerTaskTypes = i),
        (function (e) {
          (e.OverallTask = "Overall Task"),
            (e.InstructionFollowing = "Instruction Following"),
            (e.OverallTaskFeedback = "Overall Task Feedback");
        })(i || (t.QualityMeasurementPerTaskTypes = i = {})),
        (t.QualityMeasurementPerTurnTypes = r),
        (function (e) {
          (e.Prompt = "Prompt"),
            (e.ResponseSelection = "Response Selection"),
            (e.Justification = "Justification"),
            (e.FinalResponse = "Final Response");
        })(r || (t.QualityMeasurementPerTurnTypes = r = {})),
        (t.QualityMeasurementType = o),
        (function (e) {
          (e.Turn = "Quality Measurement (Turn)"),
            (e.Task = "Quality Measurement (Overall Task)");
        })(o || (t.QualityMeasurementType = o = {}));
      const c = "quality_prompt";
      t.QUALITY_PROMPT_FIELD_ID = c;
      const p = "quality_response_selection";
      t.QUALITY_RESPONSE_SELECTION_FIELD_ID = p;
      const u = "quality_justification";
      t.QUALITY_JUSTIFICATION_FIELD_ID = u;
      const d = "quality_response";
      t.QUALITY_RESPONSE_FIELD_ID = d;
      const m = "Turn Quality: ";
      t.TURN_QUALITY_TITLE_PREFIX = m;
      const h = `Turn Quality: ${r.FinalResponse}`;
      t.QUALITY_RESPONSE_TITLE = h;
      const f = `Turn Quality: ${r.Prompt}`;
      t.QUALITY_PROMPT_TITLE = f;
      const g = `Turn Quality: ${r.Justification}`;
      t.QUALITY_JUSTIFICATION_TITLE = g;
      const y = [
        {
          type: a.TextCollectionFieldType.Number,
          field_id: c,
          title: f,
          rubric: "Rate the quality of the prompt in this turn",
          min: 1,
          max: 5,
          step: 1,
          prefix: "Poor",
          mid_label: "Adequate",
          suffix: "Excellent",
          use_slider: !0,
          description: "Rate the quality of the prompt in this turn",
          required: !0,
          save_to_task_feedback: !0,
        },
        {
          type: a.TextCollectionFieldType.Category,
          field_id: p,
          title: `Turn Quality: ${r.ResponseSelection}`,
          rubric: "Is the best quality response selected in this turn?",
          required: !0,
          description: "Is the best quality response selected in this turn?",
          choices: [
            { label: "Yes", value: "yes" },
            { label: "No", value: "no" },
          ],
          max_choices: 1,
          min_choices: 1,
          save_to_task_feedback: !0,
        },
        {
          type: a.TextCollectionFieldType.Number,
          field_id: u,
          title: `Turn Quality: ${r.Justification}`,
          rubric: "Rate the quality of the justification in this turn",
          min: 1,
          max: 5,
          step: 1,
          prefix: "Poor",
          mid_label: "Adequate",
          suffix: "Excellent",
          use_slider: !0,
          description: "Rate the quality of the justification in this turn",
          required: !0,
          save_to_task_feedback: !0,
        },
        {
          type: a.TextCollectionFieldType.Number,
          field_id: d,
          title: h,
          rubric:
            "Rate the quality of the final response (written or rewritten) in this turn",
          min: 1,
          max: 5,
          step: 1,
          prefix: "Poor",
          mid_label: "Adequate",
          suffix: "Excellent",
          use_slider: !0,
          description: "Rate the quality of the final response in this turn",
          required: !0,
          save_to_task_feedback: !0,
        },
      ];
      t.TURN_STANDARDIZED_QUALITY_MEASUREMENT_FIELDS = y;
      const b = {
        [o.Turn]: {
          id: "quality_measurement_turn",
          type: s.InteractionStepType.QualityMeasurement,
          title: "Quality of this Turn",
          subtitle:
            "Evaluate the quality of this turn, specifically focusing on quality of work on this turn before you make any changes. We'll use these results to add additional review on the task as needed and surface feedback to earlier contributors when relevant!",
          params: {
            visibility_restricted: [0, 1, 4, 10],
            fields: y,
            editable_during_consensus: !0,
            hide_from_customer_view: !0,
          },
        },
      };
      t.TURN_STANDARDIZED_QUALITY_MEASUREMENT_STEP = b;
      const T = "quality_task_overall";
      t.QUALITY_TASK_OVERALL_FIELD_ID = T;
      const _ = "quality_instruction_following";
      t.QUALITY_INSTRUCTION_FOLLOWING_FIELD_ID = _;
      const S = "feedback_overall";
      t.QUALITY_FEEDBACK_OVERALL_FIELD_ID = S;
      const v = "Quality: ";
      t.TASK_QUALITY_TITLE_PREFIX = v;
      const C = `Quality: ${i.OverallTask}`;
      t.QUALITY_MEASUREMENT_OVERALL_SCORE_TITLE = C;
      const I = [
        {
          type: a.TextCollectionFieldType.Number,
          field_id: T,
          title: C,
          rubric: "Rate the quality of work done on this task holistically",
          min: 1,
          max: 5,
          step: 1,
          prefix: "Poor",
          mid_label: "Adequate",
          suffix: "Excellent",
          use_slider: !0,
          description:
            "Rate the quality of work done on this task holistically",
          required: !0,
          save_to_task_feedback: !0,
        },
        {
          type: a.TextCollectionFieldType.Category,
          field_id: _,
          title: `Quality: ${i.InstructionFollowing}`,
          rubric:
            "Does the task follow all instructions provided in tasking instructions or instructional steps?",
          required: !0,
          description:
            "Does the task follow all instructions provided in tasking instructions or instructional steps?",
          choices: [
            { label: "Yes", value: "yes" },
            { label: "No", value: "no" },
          ],
          max_choices: 1,
          min_choices: 1,
          save_to_task_feedback: !0,
        },
        {
          type: a.TextCollectionFieldType.Text,
          field_id: S,
          title: `${i.OverallTaskFeedback}`,
          required: !0,
          description:
            "Write a few sentences of feedback to the contributor who last worked on this task. Try and be as actionable and specific as possible, this feedback will be directly surfaced to the relevant contributors!",
          save_to_task_feedback: !0,
        },
      ];
      t.TASK_STANDARDIZED_QUALITY_MEASUREMENT_FIELDS = I;
      const R = {
        [o.Task]: {
          id: "quality_measurement_task",
          type: s.InteractionStepType.QualityMeasurement,
          title: "Quality of the Task",
          subtitle:
            "Evaluate the quality of the overall task, specifically focusing on quality of work on the task before you make any changes. We'll use these results to add additional review on the task as needed and surface feedback to earlier contributors when relevant!",
          params: {
            visibility_restricted: [0, 1, 4, 10],
            fields: I,
            editable_during_consensus: !0,
            hide_from_customer_view: !0,
          },
        },
      };
      t.TASK_STANDARDIZED_QUALITY_MEASUREMENT_STEP = R;
      const x = [
        {
          type: l.ChatPipelineRoutingOverrideType.NumericBasedRoutingOverride,
          enabledSources: [
            l.ChatPipelineRoutingSource.L0,
            l.ChatPipelineRoutingSource.L1,
            l.ChatPipelineRoutingSource.L4,
            l.ChatPipelineRoutingSource.L10,
          ],
          destination: l.ChatPipelineRoutingDestination.Attempt,
          transitionReason: "quality_prompt <= 2",
          assignToOriginalWorker: !0,
          thresholds: [
            {
              stepType: l.NumericRoutingTypeOverrideType.QualityMeasurement,
              value: 2,
              comparator: l.NumericValueComparator.LessThanOrEqual,
              fieldId: c,
            },
          ],
        },
        {
          type: l.ChatPipelineRoutingOverrideType.NumericBasedRoutingOverride,
          enabledSources: [
            l.ChatPipelineRoutingSource.L0,
            l.ChatPipelineRoutingSource.L1,
            l.ChatPipelineRoutingSource.L4,
            l.ChatPipelineRoutingSource.L10,
          ],
          destination: l.ChatPipelineRoutingDestination.Attempt,
          transitionReason: "quality_justification <= 2",
          assignToOriginalWorker: !0,
          thresholds: [
            {
              stepType: l.NumericRoutingTypeOverrideType.QualityMeasurement,
              value: 2,
              comparator: l.NumericValueComparator.LessThanOrEqual,
              fieldId: u,
            },
          ],
        },
        {
          type: l.ChatPipelineRoutingOverrideType.StringBasedRoutingOverride,
          enabledSources: [
            l.ChatPipelineRoutingSource.L0,
            l.ChatPipelineRoutingSource.L1,
            l.ChatPipelineRoutingSource.L4,
            l.ChatPipelineRoutingSource.L10,
          ],
          destination: l.ChatPipelineRoutingDestination.Attempt,
          transitionReason: "quality_response_selection = no",
          assignToOriginalWorker: !0,
          thresholds: [
            {
              stepType: l.StringRoutingTypeOverrideType.QualityMeasurement,
              value: "no",
              comparator: l.StringValueComparator.Equals,
              fieldId: p,
            },
          ],
        },
        {
          type: l.ChatPipelineRoutingOverrideType.NumericBasedRoutingOverride,
          enabledSources: [
            l.ChatPipelineRoutingSource.L0,
            l.ChatPipelineRoutingSource.L1,
            l.ChatPipelineRoutingSource.L4,
            l.ChatPipelineRoutingSource.L10,
          ],
          destination: l.ChatPipelineRoutingDestination.Attempt,
          transitionReason: "quality_response <= 2",
          assignToOriginalWorker: !0,
          thresholds: [
            {
              stepType: l.NumericRoutingTypeOverrideType.QualityMeasurement,
              value: 2,
              comparator: l.NumericValueComparator.LessThanOrEqual,
              fieldId: d,
            },
          ],
        },
        {
          type: l.ChatPipelineRoutingOverrideType.NumericBasedRoutingOverride,
          enabledSources: [
            l.ChatPipelineRoutingSource.L0,
            l.ChatPipelineRoutingSource.L1,
            l.ChatPipelineRoutingSource.L4,
            l.ChatPipelineRoutingSource.L10,
          ],
          destination: l.ChatPipelineRoutingDestination.Attempt,
          transitionReason: "quality_task_overall <= 2",
          assignToOriginalWorker: !0,
          thresholds: [
            {
              stepType: l.NumericRoutingTypeOverrideType.QualityMeasurement,
              value: 2,
              comparator: l.NumericValueComparator.LessThanOrEqual,
              fieldId: T,
            },
          ],
        },
        {
          type: l.ChatPipelineRoutingOverrideType.StringBasedRoutingOverride,
          enabledSources: [
            l.ChatPipelineRoutingSource.L0,
            l.ChatPipelineRoutingSource.L1,
            l.ChatPipelineRoutingSource.L4,
            l.ChatPipelineRoutingSource.L10,
          ],
          destination: l.ChatPipelineRoutingDestination.Attempt,
          transitionReason: "quality_instruction_following = no",
          assignToOriginalWorker: !0,
          thresholds: [
            {
              stepType: l.StringRoutingTypeOverrideType.QualityMeasurement,
              value: "no",
              comparator: l.StringValueComparator.Equals,
              fieldId: _,
            },
          ],
        },
      ];
      t.QUALITY_MEASUREMENT_ROUTING_OVERRIDES = x;
    },
    445216: function (e, t) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
    },
    893383: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.convertMultimodalAssetToAttachment =
          t.TransformedResponseKey =
          t.SearchResponseJsonSchema =
          t.SearchResultActionType =
          t.AttachmentSource =
          t.ModelInputFileAttachmentType =
          t.ContextType =
            void 0);
      var i,
        r,
        o,
        a = n(561630),
        s = (i = n(689510)) && i.__esModule ? i : { default: i };
      (t.ContextType = r),
        (function (e) {
          (e.User = "User"),
            (e.Prefilled = "Prefilled"),
            (e.Skipped = "Skipped");
        })(r || (t.ContextType = r = {})),
        (t.ModelInputFileAttachmentType = o),
        (function (e) {
          (e.Image = "FILE_TYPE_IMAGE"),
            (e.Text = "FILE_TYPE_TEXT"),
            (e.Json = "FILE_TYPE_JSON"),
            (e.Audio = "FILE_TYPE_AUDIO");
        })(o || (t.ModelInputFileAttachmentType = o = {}));
      const l = s.default.nativeEnum(o);
      var c;
      (t.AttachmentSource = c),
        (function (e) {
          (e.FILE_UPLOAD = "File Upload"),
            (e.URL = "URL"),
            (e.MM_IMAGE_SERVICE = "Image Search"),
            (e.AUDIO_RECORDER = "Record Audio");
        })(c || (t.AttachmentSource = c = {}));
      const p = s.default.nativeEnum(c);
      s.default.object({
        name: s.default.string(),
        mimeType: s.default.string(),
        fileType: l,
        fileSizeInBytes: s.default.number(),
        url: s.default.string().optional(),
        originalUrl: s.default.string().optional(),
        imageHashes: s.default.record(s.default.string()).optional(),
        imageSubmissionMethod: p.optional(),
        duration: s.default.number().optional(),
        transcriptUrl: s.default.string().optional(),
        transcriptText: s.default.string().optional(),
        transcriptStart: s.default.number().optional(),
        transcriptEnd: s.default.number().optional(),
        minSpeechVolume: s.default.number().optional(),
        maxSpeechVolume: s.default.number().optional(),
        averageSpeechVolume: s.default.number().optional(),
        minAmbientVolume: s.default.number().optional(),
        maxAmbientVolume: s.default.number().optional(),
        averageAmbientVolume: s.default.number().optional(),
        bgNoiseScore: s.default.number().optional(),
        overallSpeechScore: s.default.number().optional(),
        base64EncodedFileBytes: s.default.string().optional(),
      });
      var u;
      (t.SearchResultActionType = u),
        (function (e) {
          (e.Placeholder = "Select an action type"),
            (e.Read = "Read"),
            (e.Click = "Click"),
            (e.ControlF = "Control-F");
        })(u || (t.SearchResultActionType = u = {}));
      var d;
      (t.SearchResponseJsonSchema = {
        searchTerm: "string",
        searchResults: [
          {
            query: "string",
            snippet: "string",
            url: "string?",
            link: "string?",
            title: "string?",
            sourceTitle: "string?",
            isChecked: "boolean?",
          },
        ],
        hasRunAutocomplete: "boolean?",
      }),
        (t.TransformedResponseKey = d),
        (function (e) {
          (e.Prompt = "prompt"),
            (e.Rewrite = "rewrite"),
            (e.Rating = "rating"),
            (e.Feedback = "feedback"),
            (e.Select = "select");
        })(d || (t.TransformedResponseKey = d = {}));
      t.convertMultimodalAssetToAttachment = (e) => ({
        fileSizeInBytes: e.image_size,
        fileType: o.Image,
        mimeType: a.convertImageExtensionToMimeType(e.image_extension),
        name:
          e.image_url
            ?.split("/")
            ?.pop()
            ?.split(/(.jpg|.png)/)[0] ?? "",
        url: e.image_url,
        imageHashes: e.image_hashes,
        imageSubmissionMethod: c.MM_IMAGE_SERVICE,
      });
    },
    807834: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.isMultiReplicaResponse = function (e) {
          return void 0 !== e?.replicas;
        }),
        (t.isChatResponseV2 = function (e) {
          return i.default.isObject(e) && s.every((t) => t in e);
        }),
        Object.defineProperty(t, "ChainOfThoughtStepResponseOutput", {
          enumerable: !0,
          get: function () {
            return o.ChainOfThoughtStepResponseOutput;
          },
        }),
        Object.defineProperty(t, "ModelResponseInputOutput", {
          enumerable: !0,
          get: function () {
            return o.ModelResponseInputOutput;
          },
        }),
        (t.StepResponseV2InternalFields =
          t.ChatResponseV2Schema =
          t.TurnResponseV2Schema =
            void 0);
      var i = a(n(298784)),
        r = a(n(689510)),
        o = n(451215);
      function a(e) {
        return e && e.__esModule ? e : { default: e };
      }
      const s = ["before", "turns", "after"];
      const l = r.default.record(r.default.unknown()),
        c = r.default.record(l);
      t.TurnResponseV2Schema = c;
      const p = r.default.object({
          prompt: r.default.string(),
          timestamp: r.default.number(),
          candidates: r.default.array(r.default.string()),
          chatModels: r.default.array(r.default.any()),
          context: r.default.object({
            turn: r.default.number(),
            stepId: r.default.string(),
            stage: r.default.string(),
          }),
        }),
        u = r.default.record(p),
        d =
          (r.default.record(
            r.default.object({
              context: r.default.object({
                turn: r.default.number(),
                stepId: r.default.string(),
                stage: r.default.string(),
              }),
              prompts: r.default.array(r.default.string()),
              timestamp: r.default.number(),
              chatModel: r.default.any(),
              chosenPrompt: r.default.string().optional(),
            })
          ),
          r.default.object({
            before: c,
            turns: r.default.array(c),
            after: c,
            completions: u.optional(),
          }));
      t.ChatResponseV2Schema = d;
      t.StepResponseV2InternalFields = [
        "internalOutput",
        "isHiddenFromCustomer",
      ];
    },
    441936: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.isChatTaskType = function (e) {
          return e && i.GENAI_TASK_TYPES.includes(e);
        });
      var i = n(599789);
    },
    962751: function (e, t) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.displayToolParams =
          t.TOOL_USE_PROCESS_SUPERVISION_CONFIG_OPTIONS =
          t.DEFAULT_TOOL_USE_PROCESS_SUPERVISION_RATING_OPTIONS =
            void 0);
      t.DEFAULT_TOOL_USE_PROCESS_SUPERVISION_RATING_OPTIONS = [
        { id: "correct", name: "Correct", fields: [], isRewriteEnabled: !1 },
        {
          id: "incorrect",
          name: "Incorrect",
          fields: [],
          isRewriteEnabled: !0,
        },
      ];
      const n = (e, t) => {
          try {
            const t = JSON.parse(e);
            if (
              void 0 === t.action ||
              (void 0 === t.action_input && void 0 === t["action input"])
            )
              throw new Error("JSON is not well formed");
            return t;
          } catch (n) {
            return t;
          }
        },
        i = [
          {
            id: "goldfish",
            name: "Goldfish",
            toolIds: [
              "finish",
              "current_date",
              "python_interpreter",
              "google_search",
              "post_social_media",
              "check_calendar_availability",
              "current_weather",
              "historical_weather",
              "auto_responder",
              "create_calendar_event",
              "create_timer",
            ],
            actionPlan: {
              parse: (e) => {
                const t = e.match(/<function_call>([\s\S]*?)<\/function_call>/);
                if (!t)
                  throw new Error(
                    "ToolUseProcessSupervision: Failed to parse action plan: " +
                      e
                  );
                const n = JSON.parse(t[1]);
                if ("action_plan" !== n.action)
                  throw new Error(
                    "ToolUseProcessSupervision: Expected action_plan function call: " +
                      e
                  );
                return {
                  name: "Action Plan",
                  type: "markdown",
                  originalValue: JSON.stringify(n.action_input?.steps),
                  rewriteValue: null,
                  readOnly: !1,
                  rating: null,
                };
              },
              unparse: (e) => {
                const t = {
                  action: "action_plan",
                  action_input: {
                    steps: JSON.parse(e.rewriteValue ?? e.originalValue),
                  },
                };
                return `<function_call>${JSON.stringify(t)}</function_call>`;
              },
            },
            action: {
              parse: (e) => {
                const t = e.match(/<thought>([\s\S]*?)<\/thought>/),
                  i = e.match(/<function_call>([\s\S]*?)<\/function_call>/);
                if (!i)
                  throw new Error(
                    "ToolUseProcessSupervision: Failed to parse action: " + e
                  );
                const r = n(i[1], {
                    action:
                      "Failed to parse action. Please regenerate model response before proceeding.",
                    action_input: {},
                    "action input": {},
                  }),
                  o = {
                    name: "Thought",
                    type: "markdown",
                    originalValue: t ? t[1] : " ",
                    rewriteValue: null,
                    readOnly: !1,
                    rating: null,
                  },
                  a = {
                    name: "Action",
                    type: "tool_select",
                    originalValue: r.action,
                    rewriteValue: null,
                    readOnly: !1,
                    rating: null,
                  },
                  s = {
                    name: "Action Input",
                    type: "tool_params_json",
                    originalValue: JSON.stringify(
                      r.action_input || r["action input"]
                    ),
                    rewriteValue: null,
                    readOnly: !1,
                    rating: null,
                  };
                return [{ chunks: null !== o ? [o, a, s] : [a, s] }];
              },
              unparse: (e) =>
                e
                  .map(({ chunks: e }) => {
                    const t = e.find((e) => "Thought" === e.name),
                      n = e.find((e) => "Action" === e.name),
                      i = e.find((e) => "Action Input" === e.name),
                      r = e.find((e) => "Observation" === e.name);
                    if (!n || !i)
                      throw new Error(
                        "ToolUseProcessSupervision: Missing action or action input"
                      );
                    const o = {
                      action: n.rewriteValue ?? n.originalValue,
                      "action input": JSON.parse(
                        i.rewriteValue ?? i.originalValue
                      ),
                    };
                    return [
                      t &&
                        `<thought>${
                          t.rewriteValue || t.originalValue
                        }</thought>`,
                      o &&
                        `<function_call>${JSON.stringify(o)}</function_call>`,
                      r &&
                        `<observation>${
                          r.rewriteValue ?? r.originalValue
                        }</observation>`,
                    ]
                      .filter(Boolean)
                      .join("\n");
                  })
                  .join("\n\n"),
            },
          },
          {
            id: "parallel_actions",
            name: "Parallel Actions",
            toolIds: [
              "finish",
              "current_date",
              "python_interpreter",
              "google_search",
              "post_social_media",
              "check_calendar_availability",
              "current_weather",
              "historical_weather",
            ],
            actionPlan: {
              parse: (e) => {
                const t = e.match(/<function_call>([\s\S]*?)<\/function_call>/);
                if (!t)
                  throw new Error(
                    "ToolUseProcessSupervision: Failed to parse action plan: " +
                      e
                  );
                const n = JSON.parse(t[1]);
                if ("action_plan" !== n.action)
                  throw new Error(
                    "ToolUseProcessSupervision: Expected action_plan function call: " +
                      e
                  );
                return {
                  name: "Action Plan",
                  type: "plaintext",
                  originalValue: n.action_input?.steps,
                  rewriteValue: null,
                  readOnly: !1,
                  rating: null,
                };
              },
              unparse: (e) => {
                const t = {
                  action: "action_plan",
                  action_input: { steps: e.rewriteValue ?? e.originalValue },
                };
                return `<function_call>${JSON.stringify(t)}</function_call>`;
              },
            },
            action: {
              parse: (e) => {
                const t = [
                    ...e.matchAll(/<thought>([\s\S]*?)<\/thought>/g),
                  ].map((e) => e[1]),
                  i = [
                    ...e.matchAll(
                      /<function_call>([\s\S]*?)<\/function_call>/g
                    ),
                  ].map((e) => e[1]);
                if (!i)
                  throw new Error(
                    "ToolUseProcessSupervision: Failed to parse action: " + e
                  );
                const r = [];
                for (let o = 0; o < i.length; o++) {
                  const e = i[o],
                    a = n(e, {
                      action:
                        "Failed to parse action. Please regenerate model response before proceeding.",
                      action_input: {},
                      "action input": {},
                    }),
                    s = {
                      name: "Thought",
                      type: "markdown",
                      originalValue: t && o < t.length ? t[o] : " ",
                      rewriteValue: null,
                      readOnly: !1,
                      rating: null,
                    },
                    l = {
                      name: "Action",
                      type: "tool_select",
                      originalValue: a.action,
                      rewriteValue: null,
                      readOnly: !1,
                      rating: null,
                    },
                    c = {
                      name: "Action Input",
                      type: "tool_params_json",
                      originalValue: JSON.stringify(
                        a.action_input || a["action input"]
                      ),
                      rewriteValue: null,
                      readOnly: !1,
                      rating: null,
                    },
                    p = { chunks: null !== s ? [s, l, c] : [l, c] };
                  r.push(p);
                }
                return (
                  0 === r.length &&
                    r.push({
                      chunks: [
                        {
                          name: "Thought",
                          type: "markdown",
                          originalValue:
                            "Failed to parse model response. Please re-generate the model response to obtain a valid response.",
                          rewriteValue: null,
                          readOnly: !1,
                          rating: null,
                        },
                        {
                          name: "Action",
                          type: "tool_select",
                          originalValue: "none",
                          rewriteValue: null,
                          readOnly: !1,
                          rating: null,
                        },
                        {
                          name: "Action Input",
                          type: "tool_params_json",
                          originalValue: "{}",
                          rewriteValue: null,
                          readOnly: !1,
                          rating: null,
                        },
                      ],
                    }),
                  r
                );
              },
              unparse: (e) =>
                e
                  .map(({ chunks: e }) => {
                    const t = e.find((e) => "Thought" === e.name),
                      n = e.find((e) => "Action" === e.name),
                      i = e.find((e) => "Action Input" === e.name),
                      r = e.find((e) => "Observation" === e.name),
                      o = [];
                    if (
                      (t &&
                        o.push(
                          `<thought>${
                            t.rewriteValue || t.originalValue
                          }</thought>`
                        ),
                      n || i)
                    ) {
                      if (!n || !i)
                        throw new Error(
                          "ToolUseProcessSupervision: Missing action or action input"
                        );
                      const e = {
                        action: n.rewriteValue ?? n.originalValue,
                        action_input: JSON.parse(
                          i.rewriteValue ?? i.originalValue
                        ),
                      };
                      o.push(
                        `<function_call>${JSON.stringify(e)}</function_call>`
                      );
                    }
                    return (
                      r &&
                        o.push(
                          `<observation>${
                            r.rewriteValue ?? r.originalValue
                          }</observation>`
                        ),
                      o.join("\n")
                    );
                  })
                  .join("\n\n"),
            },
          },
          {
            id: "bulba_extensions",
            name: "Bulba Extensions",
            toolIds: ["bulba-code-execution"],
            actionPlan: {
              parse: (e) => ({
                name: "Action Plan",
                type: "markdown",
                originalValue: e,
                rewriteValue: null,
                readOnly: !1,
                rating: null,
              }),
              unparse: (e) => e.rewriteValue ?? e.originalValue,
            },
            action: {
              parse: (e) => {
                const t = e.match(/Thought: ([\s\S]*?)\n/),
                  n = e.match(/Action: ([\s\S]*?)\n/),
                  i = n ? n[1] : " ",
                  r = e.match(
                    /Action Input:\s+```[a-zA-Z_]+\s+([\s\S]*?)\s+```/
                  ),
                  o = (() => {
                    if ("bulba-code-execution" === i) {
                      const e = r ? r[1] : " ";
                      return `{"code": ${JSON.stringify(e)}}`;
                    }
                    {
                      const e = r ? r[1] : " ";
                      try {
                        return JSON.stringify(JSON.parse(e));
                      } catch {
                        return "{}";
                      }
                    }
                  })();
                return [
                  {
                    chunks: [
                      {
                        name: "Thought",
                        type: "markdown",
                        originalValue: t ? t[1] : " ",
                        rewriteValue: null,
                        readOnly: !1,
                        rating: null,
                      },
                      {
                        name: "Action",
                        type: "tool_select",
                        originalValue: i,
                        rewriteValue: null,
                        readOnly: !1,
                        rating: null,
                      },
                      {
                        name: "Action Input",
                        type: "tool_params_json",
                        originalValue: o,
                        rewriteValue: null,
                        readOnly: !1,
                        rating: null,
                        display: (e) => {
                          if (e.startsWith('{"answer"'))
                            return `\`\`\`json\n${e}\n\`\`\``;
                          return `\`\`\`python\n${JSON.parse(e).code}\n\`\`\``;
                        },
                      },
                    ],
                  },
                ];
              },
              unparse: (e) =>
                e
                  .map(({ chunks: e }) => {
                    const t = e.find((e) => "Thought" === e.name),
                      n = e.find((e) => "Action Input" === e.name),
                      i = e.find((e) => "Action" === e.name),
                      r = e.find((e) => "Observation" === e.name);
                    if (!t || !i || !n || !r)
                      throw new Error(
                        "ToolUseProcessSupervision: Missing thought, action, action input, or observation"
                      );
                    const o = i.rewriteValue ?? i.originalValue;
                    return `Thought: ${
                      t.rewriteValue ?? t.originalValue
                    }\nAction: ${o}\nAction Input: \n${(() => {
                      if ("python_interpreter" === o) {
                        return `\`\`\`python\n${
                          JSON.parse(n.rewriteValue ?? n.originalValue).code
                        }\n\`\`\``;
                      }
                      return `\`\`\`json\n${
                        n.rewriteValue ?? n.originalValue
                      }\n\`\`\``;
                    })()}\nObservation: \n\`\`\`json\n${
                      r?.rewriteValue ?? r.originalValue
                    }\n\`\`\``;
                  })
                  .join("\n\n"),
            },
          },
          {
            id: "lazarus_general_code_execution",
            name: "Lazarus General Code Execution",
            toolIds: [
              "finish",
              "current_date",
              "python_interpreter",
              "google_search",
              "post_social_media",
              "check_calendar_availability",
              "current_weather",
              "historical_weather",
            ],
            actionPlan: {
              parse: (e) => ({
                name: "Action Plan",
                type: "markdown",
                originalValue: e,
                rewriteValue: null,
                readOnly: !1,
                rating: null,
              }),
              unparse: (e) => e.rewriteValue ?? e.originalValue,
            },
            action: {
              parse: (e) => {
                const t = e.match(/Thought: ([\s\S]*?)\n/),
                  n = e.match(/Action: ([\s\S]*?)\n/),
                  i = (() => {
                    const t = e.match(
                        /Action Input:\s+```json\s+(\{[\s\S]*?\})\s+```/
                      ),
                      n = t ? t[1] : " ";
                    try {
                      return JSON.parse(n);
                    } catch {
                      return {};
                    }
                  })();
                return [
                  {
                    chunks: [
                      {
                        name: "Thought",
                        type: "markdown",
                        originalValue: t ? t[1] : " ",
                        rewriteValue: null,
                        readOnly: !1,
                        rating: null,
                      },
                      {
                        name: "Action",
                        type: "tool_select",
                        originalValue: n ? n[1] : " ",
                        rewriteValue: null,
                        readOnly: !1,
                        rating: null,
                      },
                      {
                        name: "Action Input",
                        type: "tool_params_json",
                        originalValue: JSON.stringify(i),
                        rewriteValue: null,
                        readOnly: !1,
                        rating: null,
                        display: (e) =>
                          `\`\`\`python\n${JSON.parse(e).code}\n\`\`\``,
                      },
                    ],
                  },
                ];
              },
              unparse: (e) =>
                e
                  .map(({ chunks: e }) => {
                    const t = e.find((e) => "Thought" === e.name),
                      n = e.find((e) => "Action Input" === e.name),
                      i = e.find((e) => "Action" === e.name),
                      r = e.find((e) => "Observation" === e.name);
                    if (!t || !i || !n || !r)
                      throw new Error(
                        "ToolUseProcessSupervision: Missing thought, action, action input, or observation"
                      );
                    return `Thought: ${
                      t.rewriteValue ?? t.originalValue
                    }\n  Action: ${
                      i.rewriteValue ?? i.originalValue
                    }\n  Action Input: \n  \`\`\`json\n  ${
                      n.rewriteValue ?? n.originalValue
                    }\n  \`\`\`\n  Observation: \n  \`\`\`\n  ${
                      r?.rewriteValue ?? r.originalValue
                    }\n  \`\`\``;
                  })
                  .join("\n\n"),
            },
          },
          {
            id: "bee",
            name: "Bee Tool Use",
            toolIds: [],
            actionPlan: {
              parse: (e) => ({
                name: "Action Plan",
                type: "markdown",
                originalValue: e,
                rewriteValue: null,
                readOnly: !1,
                rating: null,
              }),
              unparse: (e) => e.rewriteValue ?? e.originalValue,
            },
            action: {
              parse: (e) => {
                const t = [];
                let n = null;
                const i = e.split(/(?=Action:)|(?=Thought:)/);
                for (const r of i) {
                  const e = r.match(/Action: ([\s\S]*?)\n/),
                    i = r.match(/Thought: ([\s\S]*?)(?=\n(?:Action:|$))/);
                  if (
                    (e || i) &&
                    ((n = { chunks: [] }),
                    i &&
                      n.chunks.push({
                        name: "Thought",
                        type: "markdown",
                        originalValue: i[1].trim(),
                        rewriteValue: null,
                        readOnly: !1,
                        rating: null,
                      }),
                    e)
                  ) {
                    const i = (() => {
                      const e = r.match(
                          /Action Input:\s+```json\s+(\{[\s\S]*?\})\s+```/
                        ),
                        t = e ? e[1] : " ";
                      try {
                        return JSON.parse(t);
                      } catch {
                        return {};
                      }
                    })();
                    n.chunks.push({
                      name: "Action",
                      type: "tool_select",
                      originalValue: e[1].trim(),
                      rewriteValue: null,
                      readOnly: !1,
                      rating: null,
                    }),
                      n.chunks.push({
                        name: "Action Input",
                        type: "tool_params_json",
                        originalValue: JSON.stringify(i),
                        rewriteValue: null,
                        readOnly: !1,
                        rating: null,
                      }),
                      t.push(n);
                  }
                }
                return t.length > 0
                  ? t
                  : [
                      {
                        chunks: [
                          {
                            name: "Thought",
                            type: "markdown",
                            originalValue: e.trim(),
                            rewriteValue: null,
                            readOnly: !1,
                            rating: null,
                          },
                          {
                            name: "Action",
                            type: "tool_select",
                            originalValue: "no_tool_selected",
                            rewriteValue: null,
                            readOnly: !1,
                            rating: null,
                          },
                          {
                            name: "Action Input",
                            type: "tool_params_json",
                            originalValue: "{}",
                            rewriteValue: null,
                            readOnly: !1,
                            rating: null,
                          },
                        ],
                      },
                    ];
              },
              unparse: (e) =>
                e
                  .map(({ chunks: e }) => {
                    const t = e.find((e) => "Thought" === e.name),
                      n = e.find((e) => "Action" === e.name),
                      i = e.find((e) => "Action Input" === e.name);
                    let r = "";
                    if (
                      (t &&
                        (r +=
                          n && i
                            ? `Thought: ${t.rewriteValue ?? t.originalValue}`
                            : `${t.rewriteValue ?? t.originalValue}`),
                      n && i)
                    ) {
                      const e = n.rewriteValue ?? n.originalValue;
                      if ("ask_clarifying_question" === e) {
                        return JSON.parse(i.rewriteValue ?? i.originalValue)
                          .question;
                      }
                      if ("print_and_return" === e) {
                        return JSON.parse(i.rewriteValue ?? i.originalValue)
                          .text;
                      }
                      if ("no_tool_selected" === e)
                        return t?.rewriteValue ?? t?.originalValue;
                      "no_tool_selected" !== e &&
                        (r += `\nAction: ${e}\nAction Input: \n\`\`\`json\n${
                          i.rewriteValue ?? i.originalValue
                        }\n\`\`\``);
                    }
                    return r;
                  })
                  .filter((e) => e)
                  .join("\n\n"),
            },
            doesActionTriggerCompletion: (e) => {
              if (0 === e.length) return !0;
              const t = e[0].chunks.find((e) => "Action" === e.name);
              if (!t) return !0;
              const n = t.rewriteValue ?? t.originalValue;
              return (
                "ask_clarifying_question" === n ||
                "print_and_return" === n ||
                "no_tool_selected" === n
              );
            },
          },
          {
            id: "extensions_C_3_code_corrections",
            name: "Extensions C3 Code Corrections",
            toolIds: ["bulba-code-execution"],
            actionPlan: {
              parse: (e) => ({
                name: "Action Plan",
                type: "markdown",
                originalValue: e,
                rewriteValue: null,
                readOnly: !1,
                rating: null,
              }),
              unparse: (e) => e.rewriteValue ?? e.originalValue,
            },
            action: {
              parse: (e) => {
                const t = e.match(/```(?:python)?([\s\S]*?)```/),
                  n = t ? t[1].trim() : "";
                return [
                  {
                    chunks: [
                      {
                        name: "Action",
                        type: "tool_select",
                        originalValue: "bulba-code-execution",
                        rewriteValue: null,
                        readOnly: !0,
                        rating: null,
                        hidden: !0,
                        displayName: "Tool Call Input",
                      },
                      {
                        name: "Action Input",
                        type: "tool_params_json",
                        originalValue: JSON.stringify({ code: n }),
                        rewriteValue: null,
                        readOnly: !1,
                        rating: null,
                        display: (e) => `\`\`\`\n${JSON.parse(e).code}\n\`\`\``,
                        displayName: "Tool Call Input",
                      },
                    ],
                  },
                ];
              },
              unparse: (e) =>
                e
                  .map(({ chunks: e }) => {
                    const t = e.find((e) => "Action Input" === e.name),
                      n = e.find((e) => "Observation" === e.name);
                    if (!t)
                      throw new Error(
                        "ToolUseProcessSupervision: Missing action input"
                      );
                    const { code: i } = JSON.parse(
                      t.rewriteValue ?? t.originalValue
                    );
                    let r = `Tool Call:\n\`\`\`\n${i}\n\`\`\``;
                    return (
                      n &&
                        (r += `\n\nObservation: ${
                          n.rewriteValue ?? n.originalValue
                        }`),
                      r
                    );
                  })
                  .join("\n\n"),
            },
          },
          {
            id: "abra_frontend_tool_use",
            name: "Abra Frontend Tool Use",
            toolIds: ["html", "html_rendered"],
            actionPlan: {
              parse: (e) => ({
                name: "Action Plan",
                type: "markdown",
                originalValue: e,
                rewriteValue: null,
                readOnly: !1,
                rating: null,
              }),
              unparse: (e) => e.rewriteValue ?? e.originalValue,
            },
            action: {
              parse: (e) => {
                const t = e.match(/```(?:html)?([\s\S]*?)```/);
                return [
                  {
                    chunks: [
                      {
                        name: "Action",
                        type: "tool_select",
                        originalValue: "html",
                        rewriteValue: null,
                        readOnly: !0,
                        rating: null,
                        hidden: !0,
                        displayName: "Tool Call Input",
                      },
                      {
                        name: "Action Input",
                        type: "html",
                        originalValue: t ? t[1].trim() : e,
                        rewriteValue: null,
                        readOnly: !1,
                        rating: null,
                        displayName: "Frontend Code",
                      },
                    ],
                  },
                ];
              },
              unparse: (e) =>
                e
                  .map(({ chunks: e }) => {
                    const t = e.find((e) => "Action Input" === e.name);
                    if (!t)
                      throw new Error(
                        "ToolUseProcessSupervision: Missing action input"
                      );
                    return (
                      "```html\n" +
                      (t.rewriteValue ?? t.originalValue) +
                      "\n```"
                    );
                  })
                  .join("\n\n"),
            },
          },
          {
            id: "data_analytics_demo",
            name: "Data Analytics Demo",
            toolIds: [],
            actionPlan: {
              parse: (e) => ({
                name: "Action Plan",
                type: "markdown",
                originalValue: e,
                rewriteValue: null,
                readOnly: !1,
                rating: null,
              }),
              unparse: (e) => e.rewriteValue ?? e.originalValue,
            },
            action: {
              parse: (e) => {
                const t = e.match(/Thought: ([\s\S]*?)\n/),
                  n = e.match(/Action: ([\s\S]*?)\n/),
                  i = n ? n[1] : " ",
                  r = (() => {
                    if ("python_interpreter" === i) {
                      const t = e.match(
                          /Action Input:\s+```python\s+([\s\S]*?)\s+```/
                        ),
                        n = t ? t[1] : " ";
                      return `{"code": ${JSON.stringify(n)}}`;
                    }
                    {
                      const t = e.match(
                          /Action Input:\s+```json\s+(\{[\s\S]*?\})\s+```/
                        ),
                        n = t ? t[1] : " ";
                      try {
                        return JSON.stringify(JSON.parse(n));
                      } catch {
                        return "{}";
                      }
                    }
                  })();
                return [
                  {
                    chunks: [
                      {
                        name: "Thought",
                        type: "markdown",
                        originalValue: t ? t[1] : " ",
                        rewriteValue: null,
                        readOnly: !1,
                        rating: null,
                      },
                      {
                        name: "Action",
                        type: "tool_select",
                        originalValue: i,
                        rewriteValue: null,
                        readOnly: !1,
                        rating: null,
                      },
                      {
                        name: "Action Input",
                        type: "tool_params_json",
                        originalValue: r,
                        rewriteValue: null,
                        readOnly: !1,
                        rating: null,
                        display: (e) => {
                          if (e.startsWith('{"answer"'))
                            return `\`\`\`json\n${e}\n\`\`\``;
                          return `\`\`\`python\n${JSON.parse(e).code}\n\`\`\``;
                        },
                      },
                    ],
                  },
                ];
              },
              unparse: (e) =>
                e
                  .map(({ chunks: e }) => {
                    const t = e.find((e) => "Thought" === e.name),
                      n = e.find((e) => "Action Input" === e.name),
                      i = e.find((e) => "Action" === e.name),
                      r = e.find((e) => "Observation" === e.name);
                    if (!t || !i || !n || !r)
                      throw new Error(
                        "ToolUseProcessSupervision: Missing thought, action, action input, or observation"
                      );
                    const o = i.rewriteValue ?? i.originalValue;
                    return `Thought: ${
                      t.rewriteValue ?? t.originalValue
                    }\nAction: ${o}\nAction Input: \n${(() => {
                      if ("python_interpreter" === o) {
                        return `\`\`\`python\n${
                          JSON.parse(n.rewriteValue ?? n.originalValue).code
                        }\n\`\`\``;
                      }
                      return `\`\`\`json\n${
                        n.rewriteValue ?? n.originalValue
                      }\n\`\`\``;
                    })()}\nObservation: \n${
                      "base64_image" === r.type
                        ? "<base64_image>"
                        : `\`\`\`json\n${
                            r?.rewriteValue ?? r.originalValue
                          }\n\`\`\``
                    }\n`;
                  })
                  .join("\n\n"),
            },
          },
          {
            id: "bulba_planning_and_action",
            name: "Bulba Planning and Action",
            toolIds: ["bulba-code-execution"],
            actionPlan: {
              parse: (e) => {
                const t = e.match(
                  /\/\*PLANNING\*\/([\s\S]*?)(\/\*ACTION\*\/|$)/
                );
                return {
                  name: "Action Plan",
                  type: "markdown",
                  originalValue: t ? t[1].trim() : "",
                  rewriteValue: null,
                  readOnly: !1,
                  rating: null,
                };
              },
              unparse: (e) =>
                `/*PLANNING*/\n\n${e.rewriteValue ?? e.originalValue}`,
            },
            action: {
              parse: (e) => {
                const t = [],
                  n = e.split(/\/\*(REASONING|ACTION|FINAL_ANSWER)\*\//);
                let i = null;
                for (let r = 1; r < n.length; r += 2) {
                  const e = n[r],
                    o = n[r + 1].trim();
                  if ("REASONING" === e)
                    i && t.push(i),
                      (i = {
                        chunks: [
                          {
                            name: "Thought",
                            type: "markdown",
                            originalValue: o,
                            rewriteValue: null,
                            readOnly: !1,
                            rating: null,
                          },
                        ],
                      });
                  else if ("ACTION" === e) {
                    const e = o.match(/```tool_code\n([\s\S]*?)```/);
                    if (e) {
                      const n = e[1].trim();
                      i || (i = { chunks: [] }),
                        i.chunks.push(
                          {
                            name: "Action",
                            type: "tool_select",
                            originalValue: "bulba-code-execution",
                            rewriteValue: null,
                            readOnly: !1,
                            rating: null,
                          },
                          {
                            name: "Action Input",
                            type: "tool_params_json",
                            originalValue: JSON.stringify({
                              code: `${[
                                "io",
                                "math",
                                "re",
                                "matplotlib.pyplot as plt",
                                "numpy as np",
                                "pandas as pd",
                                "scipy",
                              ]
                                .filter((e) => !n.includes(`import ${e}`))
                                .map((e) => `import ${e}\n`)
                                .join("")}${n}`,
                            }),
                            rewriteValue: null,
                            readOnly: !1,
                            rating: null,
                          }
                        ),
                        t.push(i),
                        (i = null);
                    }
                  } else
                    "FINAL_ANSWER" === e &&
                      t.push({
                        chunks: [
                          {
                            name: "Action",
                            type: "tool_select",
                            originalValue: "finish",
                            rewriteValue: null,
                            readOnly: !1,
                            rating: null,
                          },
                          {
                            name: "Action Input",
                            type: "tool_params_json",
                            originalValue: JSON.stringify({ answer: o }),
                            rewriteValue: null,
                            readOnly: !1,
                            rating: null,
                          },
                        ],
                      });
                }
                return (
                  i && i.chunks.some((e) => "Action" === e.name) && t.push(i), t
                );
              },
              unparse: (e) =>
                e
                  .map(({ chunks: e }) => {
                    const t = e.find((e) => "Thought" === e.name),
                      n = e.find((e) => "Action" === e.name),
                      i = e.find((e) => "Action Input" === e.name),
                      r = e.find((e) => "Observation" === e.name);
                    if ("finish" === n?.originalValue) {
                      return `/*FINAL_ANSWER*/\n\n${
                        JSON.parse(i?.rewriteValue ?? i?.originalValue ?? "{}")
                          .answer
                      }\n`;
                    }
                    let o = "";
                    if (
                      (t &&
                        (o += `/*REASONING*/\n\n${
                          t.rewriteValue ?? t.originalValue
                        }\n`),
                      n && i)
                    ) {
                      const e = JSON.parse(i?.rewriteValue ?? i.originalValue);
                      (o += `/*ACTION*/\n\n\`\`\`tool_code\n${
                        e.code ?? e.query ?? e.url ?? ""
                      }\n\`\`\`\n`),
                        r &&
                          (o += `\n/*OBSERVATION*/\n\n${
                            r.rewriteValue ?? r.originalValue
                          }\n`);
                    }
                    return o;
                  })
                  .join("\n"),
            },
          },
        ];
      t.TOOL_USE_PROCESS_SUPERVISION_CONFIG_OPTIONS = i;
      t.displayToolParams = (e) => {
        if (e.startsWith('{"code"')) {
          return `\`\`\`python\n${JSON.parse(e).code}\n\`\`\``;
        }
        return `\`\`\`json\n${e}\n\n\`\`\``;
      };
    },
    246311: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.AutoCorruptionDimensionToSchema =
          t.IncorrectVerifiableFactualInfoCorruptionOutputSchema =
          t.ConstraintIgnoredCorruptionOutputSchema =
          t.ModelResponseCorruptionMetadata =
          t.AutoCorruptionDimension =
            void 0);
      var i,
        r = n(689510);
      (t.AutoCorruptionDimension = i),
        (function (e) {
          (e.ConstraintIgnored = "constraint-ignored"),
            (e.IncorrectVerifiableFactualInfo =
              "incorrect-verifiable-factual-info");
        })(i || (t.AutoCorruptionDimension = i = {}));
      const o = r.z.object({
        dimension: r.z.enum([
          i.ConstraintIgnored,
          i.IncorrectVerifiableFactualInfo,
        ]),
        turnIndex: r.z.number(),
        candidateIndex: r.z.number(),
        trainingAttempt: r.z.string(),
      });
      t.ModelResponseCorruptionMetadata = o;
      const a = r.z.object({
        able_to_produce_violation: r.z.boolean(),
        response: r.z.string(),
        violated_clauses: r.z.array(r.z.string()),
        explain_violations: r.z.string(),
      });
      t.ConstraintIgnoredCorruptionOutputSchema = a;
      const s = r.z.object({
        able_to_produce_incorrect_response: r.z.boolean(),
        response: r.z.string(),
        incorrect_info: r.z.array(r.z.string()),
        explain_incorrect_info: r.z.string(),
      });
      t.IncorrectVerifiableFactualInfoCorruptionOutputSchema = s;
      const l = {
        [i.ConstraintIgnored]: a,
        [i.IncorrectVerifiableFactualInfo]: s,
      };
      t.AutoCorruptionDimensionToSchema = l;
    },
    451215: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
      var i = (function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e)
          for (var n in e)
            if (Object.prototype.hasOwnProperty.call(e, n)) {
              var i =
                Object.defineProperty && Object.getOwnPropertyDescriptor
                  ? Object.getOwnPropertyDescriptor(e, n)
                  : {};
              i.get || i.set ? Object.defineProperty(t, n, i) : (t[n] = e[n]);
            }
        return (t.default = e), t;
      })(n(108417));
      Object.keys(i).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          ((e in t && t[e] === i[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return i[e];
              },
            }));
      });
    },
    753336: function (e, t) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
    },
    716156: function (e, t) {
      "use strict";
      var n;
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.ThoughtStepType = void 0),
        (t.ThoughtStepType = n),
        (function (e) {
          (e.ThoughtCorrection = "ThoughtCorrection"),
            (e.ThoughtTextCollection = "ThoughtTextCollection");
        })(n || (t.ThoughtStepType = n = {}));
    },
    848587: function (e, t) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
    },
    975945: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
      var i = (function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e)
          for (var n in e)
            if (Object.prototype.hasOwnProperty.call(e, n)) {
              var i =
                Object.defineProperty && Object.getOwnPropertyDescriptor
                  ? Object.getOwnPropertyDescriptor(e, n)
                  : {};
              i.get || i.set ? Object.defineProperty(t, n, i) : (t[n] = e[n]);
            }
        return (t.default = e), t;
      })(n(848587));
      Object.keys(i).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          ((e in t && t[e] === i[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return i[e];
              },
            }));
      });
    },
    805174: function (e, t) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
    },
    359756: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
      var i = (function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e)
          for (var n in e)
            if (Object.prototype.hasOwnProperty.call(e, n)) {
              var i =
                Object.defineProperty && Object.getOwnPropertyDescriptor
                  ? Object.getOwnPropertyDescriptor(e, n)
                  : {};
              i.get || i.set ? Object.defineProperty(t, n, i) : (t[n] = e[n]);
            }
        return (t.default = e), t;
      })(n(805174));
      Object.keys(i).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          ((e in t && t[e] === i[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return i[e];
              },
            }));
      });
    },
    582688: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        Object.defineProperty(t, "ThoughtCorrectionOutput", {
          enumerable: !0,
          get: function () {
            return i.ThoughtCorrectionOutput;
          },
        }),
        Object.defineProperty(t, "ThoughtCorrectionStepResponse", {
          enumerable: !0,
          get: function () {
            return i.ThoughtCorrectionStepResponse;
          },
        }),
        Object.defineProperty(t, "ThoughtCorrectionStep", {
          enumerable: !0,
          get: function () {
            return i.ThoughtCorrectionStep;
          },
        }),
        Object.defineProperty(t, "ThoughtTextCollectionStepResponse", {
          enumerable: !0,
          get: function () {
            return r.ThoughtTextCollectionStepResponse;
          },
        }),
        Object.defineProperty(t, "ThoughtTextCollectionStep", {
          enumerable: !0,
          get: function () {
            return r.ThoughtTextCollectionStep;
          },
        });
      var i = n(975945),
        r = n(359756);
    },
    725220: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
      var i = { ThoughtStepType: !0 };
      Object.defineProperty(t, "ThoughtStepType", {
        enumerable: !0,
        get: function () {
          return o.ThoughtStepType;
        },
      });
      var r = s(n(753336));
      Object.keys(r).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === r[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return r[e];
              },
            }));
      });
      var o = n(716156),
        a = s(n(582688));
      function s(e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e)
          for (var n in e)
            if (Object.prototype.hasOwnProperty.call(e, n)) {
              var i =
                Object.defineProperty && Object.getOwnPropertyDescriptor
                  ? Object.getOwnPropertyDescriptor(e, n)
                  : {};
              i.get || i.set ? Object.defineProperty(t, n, i) : (t[n] = e[n]);
            }
        return (t.default = e), t;
      }
      Object.keys(a).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === a[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return a[e];
              },
            }));
      });
    },
    816955: function (e, t) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
    },
    187105: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
      var i = (function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e)
          for (var n in e)
            if (Object.prototype.hasOwnProperty.call(e, n)) {
              var i =
                Object.defineProperty && Object.getOwnPropertyDescriptor
                  ? Object.getOwnPropertyDescriptor(e, n)
                  : {};
              i.get || i.set ? Object.defineProperty(t, n, i) : (t[n] = e[n]);
            }
        return (t.default = e), t;
      })(n(816955));
      Object.keys(i).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          ((e in t && t[e] === i[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return i[e];
              },
            }));
      });
    },
    108417: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
      var i = {},
        r = a(n(725220));
      Object.keys(r).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === r[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return r[e];
              },
            }));
      });
      var o = a(n(187105));
      function a(e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e)
          for (var n in e)
            if (Object.prototype.hasOwnProperty.call(e, n)) {
              var i =
                Object.defineProperty && Object.getOwnPropertyDescriptor
                  ? Object.getOwnPropertyDescriptor(e, n)
                  : {};
              i.get || i.set ? Object.defineProperty(t, n, i) : (t[n] = e[n]);
            }
        return (t.default = e), t;
      }
      Object.keys(o).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === o[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return o[e];
              },
            }));
      });
    },
    101241: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        Object.defineProperty(t, "LintLevel", {
          enumerable: !0,
          get: function () {
            return r.LintLevel;
          },
        }),
        Object.defineProperty(t, "LintVerdict", {
          enumerable: !0,
          get: function () {
            return r.LintVerdict;
          },
        }),
        (t.isMultiReplicaLintRule = function (e) {
          return e.condition?.validatorCategory === y.MultiReplica;
        }),
        (t.isValidLintResult = b),
        (t.getValidLintResults = function (e) {
          return e.filter(b);
        }),
        (t.isResponseLintingRuleForReviewLevel = function (e, t, n) {
          if (n) {
            if (!1 === e.enableBenchmarks) return !1;
            if (e.enableAttempt) return !0;
            for (const t of n)
              switch (t) {
                case i.WorkerReviewLevel.Normal:
                  return !!e.enableL0;
                case i.WorkerReviewLevel.Level1:
                  return !!e.enableL1;
                case i.WorkerReviewLevel.ReviewConsensus:
                  return !!e.enableL4;
                case i.WorkerReviewLevel.Corp:
                  return !!e.enableL10;
                case i.WorkerReviewLevel.QIRAuditor:
                  return !!e.enableQIRAuditor;
                case i.WorkerReviewLevel.QIRLeadAuditor:
                  return !!e.enableQIRLeadAuditor;
              }
            return !1;
          }
          switch (t) {
            case i.ReviewLevel.Attempt:
              return !!e.enableAttempt;
            case i.ReviewLevel.Normal:
              return !!e.enableL0;
            case i.ReviewLevel.Level1:
              return !!e.enableL1;
            case i.ReviewLevel.ReviewConsensus:
              return !!e.enableL4;
            case i.ReviewLevel.Expedite:
              return !!e.enableL8;
            case i.ReviewLevel.Corp:
              return !!e.enableL10;
            case i.ReviewLevel.CorpFlagged:
              return !!e.enableL11;
            case i.ReviewLevel.Deliverable:
              return !!e.enableL12;
            case i.ReviewLevel.QIRAuditor:
              return !!e.enableQIRAuditor;
            case i.ReviewLevel.QIRLeadAuditor:
              return !!e.enableQIRLeadAuditor;
          }
          return !1;
        }),
        (t.GoogleTranslationLanguages =
          t.isLidarCuboidShiftMetadata =
          t.LidarCuboidShiftMode =
          t.AcceptedSphereLanguage =
          t.TextInAttachmentCustom =
          t.TextInAttachmentMode =
          t.emptyTaskLinterAllowedTaskTypes =
          t.timeSpentLinterAllowedTaskTypes =
          t.enterpriseDefaultScriptLinterNames =
          t.KeypointsDistanceOrientation =
          t.ZIndexLinterOperator =
          t.UserAgentsStrategy =
          t.RegexMatches =
          t.ValidJsonLintModes =
          t.ComparisonOperator =
          t.LogicalOperator =
          t.ContainmentDependentOn =
          t.MetadataUnitConversionType =
          t.NerRelationshipsOverlapType =
          t.HypothesisChangedLintMode =
          t.DEFAULT_VALIDATOR =
          t.AVAILABLE_VALIDATORS =
          t.ValidatorCategory =
          t.PromptValidatorType =
          t.ValidatorType =
          t.ScriptLinterName =
          t.DataQualityLinterEnum =
          t.LintDowngradeReason =
          t.LintOutcome =
          t.MlFastLinters =
          t.TAXONOMY_LINTER_PREFIX =
          t.UseCases =
          t.DisabledDefaultLinterReason =
          t.LintOrigin =
          t.LintStage =
          t.PASSING_VERDICTS =
            void 0);
      var i = n(599789),
        r = n(167469);
      const o = [r.LintVerdict.Pass, r.LintVerdict.NoLint];
      var a, s, l, c;
      (t.PASSING_VERDICTS = o),
        (t.LintStage = a),
        (function (e) {
          (e.Frontend = "frontend"), (e.Backend = "backend"), (e.Any = "any");
        })(a || (t.LintStage = a = {})),
        (t.LintOrigin = s),
        (function (e) {
          (e.Customer = "customer"),
            (e.Corp = "corp"),
            (e.Taxonomy = "taxonomy"),
            (e.Auto = "auto");
        })(s || (t.LintOrigin = s = {})),
        (t.DisabledDefaultLinterReason = l),
        (function (e) {
          (e.Testing = "testing"),
            (e.InProgress = "in_progress"),
            (e.NeedMoreInfo = "need_more_info"),
            (e.UnexpectedBehavior = "unexpected_behavior"),
            (e.Unnecessary = "unnecessary");
        })(l || (t.DisabledDefaultLinterReason = l = {})),
        (t.UseCases = c),
        (function (e) {
          (e.Informational = "informational"),
            (e.Critical = "critical"),
            (e.Other = "other");
        })(c || (t.UseCases = c = {}));
      var p, u, d, m, h, f, g, y;
      function b(e) {
        return e.lintOutcome !== u.Ignore;
      }
      (t.TAXONOMY_LINTER_PREFIX = "TAXONOMY_"),
        (t.MlFastLinters = p),
        (function (e) {
          e.Invoice = "invoice";
        })(p || (t.MlFastLinters = p = {})),
        (t.LintOutcome = u),
        (function (e) {
          (e.Pass = "pass"), (e.Fail = "fail"), (e.Ignore = "ignore");
        })(u || (t.LintOutcome = u = {})),
        (t.LintDowngradeReason = d),
        (function (e) {
          (e.Unhelpful = "unhelpful"), (e.Hallucinatory = "hallucinatory");
        })(d || (t.LintDowngradeReason = d = {})),
        (t.DataQualityLinterEnum = m),
        (function (e) {
          (e.GENERIC = "generic"),
            (e.NO_POLYGON_WITH_LESS_THAN_THREE_POINTS =
              "no_polygon_with_less_than_three_points"),
            (e.NO_DUPLICATE_POINTS = "no_duplicate_points");
        })(m || (t.DataQualityLinterEnum = m = {})),
        (t.ScriptLinterName = h),
        (function (e) {
          (e.Truncation = "SCRIPT_truncation-linter"),
            (e.Semseg = "SCRIPT_semseg-linter"),
            (e.PointContainment = "SCRIPT_point-containment-linter"),
            (e.FedMissingGmvImage = "SCRIPT_fed-missing-gmv-image-linter"),
            (e.GenericDataCollectionVideoQuality =
              "SCRIPT_generic-data-collection-video-quality"),
            (e.StaticGoldenTask = "SCRIPT_static-golden-task-linter"),
            (e.PolygonContainment = "SCRIPT_polygon-containment-linter"),
            (e.MinMaxSize = "SCRIPT_size-linter"),
            (e.Ratio = "SCRIPT_ratio-linter"),
            (e.StrayPixel = "SCRIPT_stray-pixel-linter"),
            (e.BoxContainment = "SCRIPT_box-containment-linter"),
            (e.OverlappingObjectFrame = "SCRIPT_overlapping-object-frame"),
            (e.TrackAttributeConsistency =
              "SCRIPT_track-attribute-consistency"),
            (e.ContiguousFrameTrack = "SCRIPT_contiguous-frame-track"),
            (e.PolygonEdges = "SCRIPT_edge-polygon-linter"),
            (e.Attribute = "SCRIPT_attribute-linter"),
            (e.GISDuplicates = "SCRIPT_gis-duplicates-linter"),
            (e.GisLaneLine = "SCRIPT_gis-lane-line-linter"),
            (e.GisGoat = "SCRIPT_gis-goat-linter"),
            (e.GisGoatPhaseTwo = "SCRIPT_gis-goat-phase-two-linter"),
            (e.GisMongoose = "SCRIPT_gis-mongoose-linter"),
            (e.GisMammoth = "SCRIPT_gis-mammoth-linter"),
            (e.GisMammothHosted = "SCRIPT_gis-mammoth-hosted-linter"),
            (e.GisPolygonOverlap = "SCRIPT_gis-polygon-overlap-linter"),
            (e.GisMustBeLinked = "SCRIPT_gis-must-be-linked"),
            (e.GisCheckSegmenter = "SCRIPT_gis-check-segmenter-linter"),
            (e.GisCheckDRZEdgesNum = "SCRIPT_gis-check-drz-edges-num-linter"),
            (e.GisCheckDeriveRules = "SCRIPT_gis-check-derive-rules-linter"),
            (e.GisWoven = "SCRIPT_gis-woven-linter"),
            (e.GisUpdateApiCheckFocuses =
              "SCRIPT_gis-update-api-check-focuses-linter"),
            (e.GisUpdateApiCheckUpdateReasons =
              "SCRIPT_gis-update-api-check-update-reasons-linter"),
            (e.GisUpdateApiTouchFocusAnnotation =
              "SCRIPT_gis-update-api-touch-focus-annotation-linter"),
            (e.Comparison = "SCRIPT_comparison-linter"),
            (e.LinkingQuality = "SCRIPT_linking-quality-linter"),
            (e.DocumentMissingText = "SCRIPT_document-missing-text"),
            (e.TextAttribute = "SCRIPT_text-attribute"),
            (e.LSSFlood = "SCRIPT_LSS_flood-linter"),
            (e.LSSContainsLabels = "SCRIPT_LSS_contains-labels"),
            (e.LSSFloatingGround = "SCRIPT_LSS_floating-ground"),
            (e.PrelabelDiff = "SCRIPT_prelabel-diff-linter"),
            (e.SemsegLabelProximity = "SCRIPT_semseg-label-proximity"),
            (e.LinkedPolygonContainmentLinter =
              "SCRIPT_linked-polygon-containment-linter"),
            (e.VertexCount = "Script_vertex-count-linter"),
            (e.MissingResponse = "SCRIPT_missing-response-linter"),
            (e.OverlappingVertices = "SCRIPT-overlapping-vertices-linter"),
            (e.PolygonStraightLine = "SCRIPT-polygon-straight-line"),
            (e.SelfIntersectingPolygon =
              "SCRIPT-self-intersecting-polygons-linter"),
            (e.SelfIntersectingPolygonLambda =
              "SCRIPT_self-intersecting-polygons-linter-v2"),
            (e.DuplicateLambda = "SCRIPT_polygon-duplicate-linter-v2"),
            (e.SharedSegmentLambda = "SCRIPT_polygon-shared-segment-linter"),
            (e.PolygonOverlap = "SCRIPT-polygon-overlap-linter"),
            (e.TimesUsed = "SCRIPT_times-used-linter"),
            (e.S2Geometry = "SCRIPT-s2-geometry-linter"),
            (e.IouOverlap = "SCRIPT_box-overlap-linter"),
            (e.CuboidPolygonProximity =
              "SCRIPT_cuboid-polygon-proximity-linter"),
            (e.AsyncCustomerEndpoint = "SCRIPT_async-customer-endpoint-linter"),
            (e.CustomerEndpoint = "SCRIPT_customer-endpoint-linter"),
            (e.BeeGISCustomerEndpoint =
              "SCRIPT_bee-gis-customer-endpoint-linter"),
            (e.PolygonExtremalPoints = "SCRIPT_polygon-extremal-points"),
            (e.PolygonPolygonContainment =
              "SCRIPT_polygon-polygon-containment"),
            (e.ZenuityResponse = "SCRIPT_zenuity-response"),
            (e.DeletedBaseAnnotation = "SCRIPT_deleted-base-annotation"),
            (e.CatalogLinter = "SCRIPT_catalog-linter"),
            (e.FbAudioTranscription = "SCRIPT_fb-audio-transcription-linter"),
            (e.ForbiddenCategorization = "SCRIPT_forbidden-categorization"),
            (e.SemsegDisjointedInstance =
              "SCRIPT_semseg-disjointed-instance-linter"),
            (e.LinePolygonContainment =
              "SCRIPT_line-polygon-containment-linter"),
            (e.SemsegLabelMinMax = "SCRIPT_semseg-label-min-max"),
            (e.CameraConsistency = "SCRIPT_camera-consistency"),
            (e.LinkedInstersection = "SCRIPT_linked-intersection-linter"),
            (e.LinkedAttribute = "SCRIPT_linked-attribute-linter"),
            (e.LineEndpoint = "SCRIPT_line-endpoint-linter"),
            (e.LineMergePoint = "SCRIPT_line-endpoint-merge-linter"),
            (e.LineBetweenLines = "SCRIPT_line-between-lines-linter"),
            (e.LineBetweenLinked = "SCRIPT_line-between-linked-linter"),
            (e.SameLabelLinking = "SCRIPT_same-label-linking-linter"),
            (e.OverlappingLinesSameLabel =
              "SCRIPT_overlapping-lines-same-label-linter"),
            (e.AdobeImageEditingRequest =
              "SCRIPT_adobe-image-editing-request-linter"),
            (e.ShadowPredictions = "SCRIPT_shadow-predictions"),
            (e.MLCarCamera = "SCRIPT_ML_car-camera"),
            (e.MLBrakeCamera = "SCRIPT_ML_brake-camera"),
            (e.MLCelery = "SCRIPT_ML_celery"),
            (e.MLDocumentNats = "SCRIPT_ML_document-nats"),
            (e.MLCuboidMismatch = "SCRIPT_ML_cuboid-mismatch"),
            (e.MLQualitySingletonMetric = "SCRIPT_ml-quality-singleton-metric"),
            (e.DocumentLinking = "SCRIPT_document-linking-linter"),
            (e.DocumentMinMaxLinking =
              "SCRIPT_document-min-max-linking-linter"),
            (e.DocumentTextCharacters = "SCRIPT_text-characters"),
            (e.TextMultiSelect = "SCRIPT_text-multi-select-linter"),
            (e.TextFieldContains = "SCRIPT_text-field-contains-linter"),
            (e.FalconCatSubmissionCode =
              "SCRIPT_falcon-cat-submission-code-linter"),
            (e.MetadataContainsChoice =
              "SCRIPT_metadata-contains-choice-linter"),
            (e.MetadataUnitConversion =
              "SCRIPT_metadata-unit-conversion-linter"),
            (e.FieldContainsField = "SCRIPT_field-contains-field-linter"),
            (e.URLExists = "SCRIPT_url-exists-linter"),
            (e.HypothesisMatchesChoice =
              "SCRIPT_hypothesis-matches-choice-linter"),
            (e.NerValidSegments = "SCRIPT_ner-valid-segments-linter"),
            (e.NerRelationships = "SCRIPT_ner-relationships-linter"),
            (e.NerEntities = "SCRIPT_ner-entities-linter"),
            (e.HypothesisChanged = "SCRIPT_hypothesis-changed-linter"),
            (e.SmartAssistantResponse =
              "SCRIPT_smart-assistant-response-linter"),
            (e.TimeSpent = "SCRIPT_time-spent-linter"),
            (e.LycheeItemValuesInGroup =
              "SCRIPT_lychee-item-values-in-group-linter"),
            (e.LycheeItemTableRow = "SCRIPT_lychee-item-table-row-linter"),
            (e.LaneLineOrder = "SCRIPT_lane-line-order-linter"),
            (e.LicensePlate = "SCRIPT_license-plate-linter"),
            (e.SwappedBaseAnnotations =
              "SCRIPT_swapped-base-annotations-linter"),
            (e.GISLinkingLambda = "SCRIPT_gis-linking-lambda"),
            (e.GISStitchingLambda = "SCRIPT_gis-stitching-lambda"),
            (e.GISLinkingML = "SCRIPT_gis-ml-linter"),
            (e.SaguaroML = "SCRIPT_saguaro-ml-linter"),
            (e.URLDomain = "SCRIPT_url-domains-linter"),
            (e.VideoPlaybackFrameCount =
              "SCRIPT_video-playback-frame-count-linter"),
            (e.VideoSameAttribute = "SCRIPT_video-same-attribute-linter"),
            (e.EveryXFrame = "SCRIPT_every-x-frame-linter"),
            (e.FlamingoCategory = "SCRIPT_flamingo-category-linter"),
            (e.LabelCorrectSide = "SCRIPT_label-correct-side-linter"),
            (e.VideoTranscriptionMatch =
              "SCRIPT_video-transcription-match-linter"),
            (e.VideoTranscriptionFlowTracking =
              "SCRIPT_video-transcription-flow-tracking-linter"),
            (e.NERRelationshipRequired =
              "SCRIPT_ner-relationship-required-linter"),
            (e.NERDirectionalRelationship =
              "SCRIPT_ner-directional-relationship-linter"),
            (e.NERSameLabelRelationship =
              "SCRIPT_ner-same-label-relationship-linter"),
            (e.ValidJSONLinter = "SCRIPT_valid-json-linter"),
            (e.ParentChildRotation = "SCRIPT_parent-child-rotation-linter"),
            (e.TextDuplicateStringInArray =
              "SCRIPT_text-duplicate-string-in-array-linter"),
            (e.FieldSetDuplicateCheck =
              "SCRIPT_fieldset-duplicate-check-linter"),
            (e.GooseEnrichmentLinter = "SCRIPT_goose-enrichment-linter"),
            (e.GooseDeduplicationLinter = "SCRIPT_goose-deduplication-linter"),
            (e.GooseTaggingLinter = "SCRIPT_goose-tagging-linter"),
            (e.InstacartAlcoholLinter = "SCRIPT_instacart-alcohol-linter"),
            (e.InstacartNPCLinter = "SCRIPT_instacart-npc-linter"),
            (e.FlamingoPriorityVariantLinter =
              "SCRIPT_flamingo-priority-variant-linter"),
            (e.NEROverlap = "SCRIPT_ner-overlap-linter"),
            (e.TextFieldLength = "SCRIPT_text-field-length"),
            (e.TextFieldWordCount = "SCRIPT_text-field-word-count"),
            (e.TextCollectionNumericLinter =
              "SCRIPT_text-collection-numeric-linter"),
            (e.NeevaSxSDuplicateURl = "SCRIPT_neeva-sxs-duplicate-url-linter"),
            (e.NeevaSxSScoreLinter = "SCRIPT_neeva-sxs-score-linter"),
            (e.FlamingoBulletsBlockingLinter =
              "SCRIPT_flamingo-bullets-blocking-linter"),
            (e.FlamingoBulletsDismissibleLinter =
              "SCRIPT_flamingo-bullets-dismissable-linter"),
            (e.FlamingoBulletsRefinementDismissibleLinter =
              "SCRIPT_flamingo-bullets-refinement-dismissible-linter"),
            (e.FlamingoBulletsModelLinter =
              "SCRIPT_flamingo-bullets-model-linter"),
            (e.FlamingoBulletsAttributeLinter =
              "SCRIPT_flamingo-bullets-attribute-linter"),
            (e.Overlapping = "SCRIPT_overlapping-linter"),
            (e.TCMetadataFieldMatch = "SCRIPT_tc-metadata-field-match-linter"),
            (e.TCCombination = "SCRIPT_tc-combination-linter"),
            (e.TCFieldCombination = "SCRIPT_tc-field-combination-linter"),
            (e.TCRegex = "SCRIPT_tc-regex-linter"),
            (e.LinkedPointBox = "SCRIPT_linked-point-box-linter"),
            (e.InstacartSSMissedCrawlAttachment =
              "SCRIPT_instacart-ssmissed-crawl-attachment-linter"),
            (e.InstacartTaxonomyKeywordLinter =
              "SCRIPT_instacart-taxonomy-keyword-linter"),
            (e.TCConditionalBlocker = "SCRIPT_tc-conditional-blocker-linter"),
            (e.FlamingoBulletsFullStringLinter =
              "SCRIPT_flamingo-bullets-full-string-linter"),
            (e.FlamingoBulletsMaterialsLinter =
              "SCRIPT_flamingo-bullets-materials-linter"),
            (e.TCRepeatedWords = "SCRIPT_tc-repeated-words-linter"),
            (e.EventLinter = "SCRIPT_event-linter"),
            (e.ZIndexLinter = "SCRIPT_z-index-linter"),
            (e.CovariantObjectDetection =
              "SCRIPT_covariant-object-detection-linter"),
            (e.LinkedLines = "SCRIPT_linked-lines-linter"),
            (e.LineShape = "SCRIPT_line-shape-linter"),
            (e.TCBadWords = "SCRIPT_tc-bad-words-linter"),
            (e.PointDistanceFromBox = "SCRIPT_point-distance-from-box-linter"),
            (e.UnexpectedNonBaseAnnotation =
              "SCRIPT_unexpected-non-base-annotation-linter"),
            (e.VertexPlacement = "SCRIPT_vertex-placement-linter"),
            (e.Rapid2dMlLinter = "SCRIPT_rapid-2d-ml-linter"),
            (e.OneTeamRoadLineCustomLinter =
              "SCRIPT_one-team-road-line-custom-linter"),
            (e.LidarPoints = "SCRIPT_lidar-points-linter"),
            (e.OneTeamOrRadarCustomLinter =
              "SCRIPT_one-team-or-radar-custom-linter"),
            (e.AdeptGptLinter = "SCRIPT_adept-gpt-linter"),
            (e.AdeptPipelineALinter = "SCRIPT_adept-pipeline-a-linter"),
            (e.AdeptPipelineBLinter = "SCRIPT_adept-pipeline-b-linter"),
            (e.AcyclicLinkingLinter = "SCRIPT_acyclic-linking-linter"),
            (e.OneTeamRoadBoundaryCustomLinter =
              "SCRIPT_one-team-road-boundary-custom-linter"),
            (e.LidarCuboidOverlap = "SCRIPT_lidar-cuboid-overlap-linter"),
            (e.ParkingSlotCustomLinter = "SCRIPT_parking-slot-custom-linter"),
            (e.TextFieldCorrectLanguage =
              "SCRIPT_text-field-correct-language-linter"),
            (e.TextFieldPromptSpam = "SCRIPT_text-field-prompt-spam-linter"),
            (e.ChatTaskMinEditDistance =
              "SCRIPT_chat-task-min-edit-distance-linter"),
            (e.TextFieldUniqueResponse =
              "SCRIPT_text-field-unique-response-linter"),
            (e.TextFieldSaplingGrammarLinter =
              "SCRIPT_text-field-sapling-grammar-linter"),
            (e.TextFieldPromptResponsePairLinter =
              "SCRIPT_text-field-prompt-response-pair-linter"),
            (e.TextFieldPromptResponsePairPlagiarismLinter =
              "SCRIPT_text-field-prompt-response-pair-plagiarism-linter"),
            (e.TextFieldSemanticSimilarity =
              "SCRIPT_text-field-semantic-similarity-linter"),
            (e.TCSameAnswer = "SCRIPT_tc-same-answer-linter"),
            (e.IntersectingLinesLinter = "SCRIPT_intersecting-lines-linter"),
            (e.PedestrianCrossingAndEnvironmentCustomLinter =
              "SCRIPT_pedestrian-crossing-and-environment-custom-linter"),
            (e.LinkingPairsLinter = "SCRIPT_linking-pairs-linter"),
            (e.TextCollectionCategoryFieldMatchLinter =
              "SCRIPT-textcollection-category-field-match-linter"),
            (e.TextCollectionCategoryFieldChildrenLinter =
              "SCRIPT-textcollection-category-field-children-linter"),
            (e.LinksDirectionLinter = "SCRIPT_links-direction-linter"),
            (e.ToucanClassificationGBRCustomLinter =
              "SCRIPT_toucan-classification-gbr-custom-linter"),
            (e.RankingFieldMissingResponse =
              "SCRIPT_ranking-field-missing-response"),
            (e.BoxOverlapping = "SCRIPT_box-overlapping-linter"),
            (e.BidirectionalLinks = "SCRIPT_bidirectional-links-linter"),
            (e.EmptyTask = "SCRIPT_empty-task-linter"),
            (e.TextFieldDiversity = "SCRIPT_text-field-diversity-linter"),
            (e.ZebraLidarSubCustomLinter =
              "SCRIPT_zebra-lidar-sub-custom-linter"),
            (e.MultipleLinkedLines = "SCRIPT_multiple-linked-lines-linter"),
            (e.VisibleMask = "SCRIPT_visible-mask-linter"),
            (e.AnnotationOnPadding = "SCRIPT_annotation-on-padding-linter"),
            (e.AttributeTextFieldGrammarLinter =
              "SCRIPT_attribute-text-field-grammar-linter"),
            (e.AttributeTextContainmentLinter =
              "SCRIPT_attribute-text-containment-linter"),
            (e.HKPSizeBoxBasedImageCustomLinter =
              "SCRIPT_size-box-based-image-custom-linter"),
            (e.RequireLinkingFramesLinter =
              "SCRIPT_require-linking-frames-linter"),
            (e.LinksLabels = "SCRIPT_links-labels-linter"),
            (e.RestrictFrames = "SCRIPT_restrict-frames-linter"),
            (e.TextGibberishDetection =
              "SCRIPT_text-gibberish-detection-linter"),
            (e.TextFieldOverlap = "SCRIPT_text-field-overlap-linter"),
            (e.UShapeLinter = "SCRIPT_u-shape-linter"),
            (e.EventLengthMinMaxLinter = "SCRIPT_event-length-min-max-linter"),
            (e.EventOverlapLinter = "SCRIPT_event-overlap-linter"),
            (e.TaskMetadata = "SCRIPT_task-metadata-linter"),
            (e.PolygonTooClose = "SCRIPT_polygon-too-close-linter"),
            (e.ParkingBarrierCustomLinter =
              "SCRIPT_parking-barrier-custom-linter"),
            (e.TextFieldLLM = "SCRIPT_text-field-llm"),
            (e.GoatAttributeLinter = "SCRIPT_goat-attribute-linter"),
            (e.RankingAndRatingLinter = "SCRIPT_ranking-and-rating-linter"),
            (e.NGramDiversityLinter = "SCRIPT_ngram-diversity-linter"),
            (e.WoodpeckerEnrichmentLinter =
              "SCRIPT_woodpecker-enrichment-linter"),
            (e.EveryXFramesAnteaterCustomLinter =
              "SCRIPT_every-x-frames-anteater-custom-linter"),
            (e.LidarTopDownZIndex = "SCRIPT_lidar-top-down-z-index-linter"),
            (e.GoatLTDCuboidLinter = "SCRIPT_ltd-cuboid-linter"),
            (e.LidarKeyPoints = "SCRIPT_lidar-key-points-linter"),
            (e.AdeptBrowserLinter = "SCRIPT_adept-browser-linter"),
            (e.OnceOnVideoAnteaterCustomLinter =
              "SCRIPT_once-on-video-anteater-custom-linter"),
            (e.TCBlockTextRegexLinter = "SCRIPT_tc_block_text_regex_linter"),
            (e.RestrictMultiselectCustomLinter =
              "SCRIPT_restrict-multiselect-custom-linter"),
            (e.AnteaterTLRCustomLinter = "SCRIPT_anteater-tlr-custom-linter"),
            (e.TextCollectionNumericValidationLinter =
              "SCRIPT_text-collection-numeric-validation-linter"),
            (e.ZOrderResponseLinter = "SCRIPT_z-order-response-linter"),
            (e.EmptyArea = "SCRIPT_empty-area-linter"),
            (e.EditCompletionLevenshteinLinter =
              "SCRIPT_edit-completion-levenshtein-linter"),
            (e.LinesInWrongSideLinter = "SCRIPT_lines-in-wrong-side-linter"),
            (e.MiniGoatCenterLinesLinter =
              "SCRIPT_mini-goat-center-lines-linter"),
            (e.TextFieldCheatingLinter = "SCRIPT_text-field-cheating-linter"),
            (e.FieldsInAttachmentsLinter =
              "SCRIPT_fields-in-attachments-linter"),
            (e.GoatLTDLaneLinesLinter = "SCRIPT_goat-ltd-lane-lines-linter"),
            (e.GPTZeroLinter = "SCRIPT_gpt-zero-linter"),
            (e.GPTScaleLinter = "SCRIPT_gpt-scale-linter"),
            (e.BulbaGeneralistLinter = "SCRIPT_bulba-generalist-linter"),
            (e.AutoCritique = "SCRIPT_auto-critique-linter"),
            (e.ArmadilloDuplicateFileNamesLinter =
              "SCRIPT_armadillo-duplicate-file-names-linter"),
            (e.BulbasaurCustomLinter = "SCRIPT_bulbasaur-custom-linter"),
            (e.AttemptReviewLinter = "SCRIPT_attempt-review-linter"),
            (e.ValeoCustomLinter = "SCRIPT_valeo-custom-linter"),
            (e.AnteaterAttachedToLinter = "SCRIPT_anteater-attached-to-linter"),
            (e.LinkLinter = "SCRIPT_link-linter"),
            (e.AnnotationPath = "SCRIPT_annotation-path-linter"),
            (e.KeypointsDistance = "SCRIPT_keypoints-distance-linter"),
            (e.AnteaterEventLinter = "SCRIPT_anteater-event-linter"),
            (e.AnteaterLTDLinter = "SCRIPT_anteater-ltd-linter"),
            (e.TextFieldSphereExecutionOutputLinter =
              "SCRIPT_text-field-sphere-execution-output-linter"),
            (e.ChatSphereExecutionOutputLinter =
              "SCRIPT_chat-sphere-execution-output-linter"),
            (e.LidarCuboidShift = "SCRIPT_lidar-cuboid-shift-linter"),
            (e.BeeCustomLinter = "SCRIPT_bee-custom-linter"),
            (e.DependentConditionsLinter =
              "SCRIPT_dependent-conditions-linter"),
            (e.EventDurationLinter = "SCRIPT_event-duration-linter"),
            (e.EventSequenceStartingValueLinter =
              "SCRIPT_event-sequence-starting-value-linter"),
            (e.DelimiterAnnotationLinter =
              "SCRIPT_delimiter-annotation-linter"),
            (e.OverlappingLines = "SCRIPT_overlapping-lines-linter"),
            (e.AnteaterGridLinter = "SCRIPT_anteater-grid-linter"),
            (e.GoatEgoIgnoreCustomLinter =
              "SCRIPT_goat-ego-ignore-custom-linter"),
            (e.AnteaterOccludedPathLinter =
              "SCRIPT_anteater-occluded-path-linter"),
            (e.AnteaterHorizontalStructuresLinter =
              "SCRIPT_horizontal-structures-linter"),
            (e.AnteaterWeatherCatLinter = "SCRIPT_anteater-weather-cat-linter"),
            (e.VenusLTDLinter = "SCRIPT_venus-ltd-linter"),
            (e.AnteaterLSODLinter = "SCRIPT_anteater-lsod-linter"),
            (e.GoatTLShapeLinter = "SCRIPT_goat-tl-shape-linter"),
            (e.RabbitCustomLinter = "SCRIPT_rabbit-custom-linter"),
            (e.AnteaterProjectionLinter = "SCRIPT_anteater-projection-linter"),
            (e.LemurCustomLinter = "SCRIPT_lemur-custom-linter"),
            (e.AnteaterLidarliteLintersBackend =
              "SCRIPT_anteater-lidarlite-linter-backend"),
            (e.GazelleCustomLinter = "SCRIPT_gazelle-custom-linter"),
            (e.GoatCustomLinter = "SCRIPT_goat-custom-linter"),
            (e.SelectedLinesEditedByZeditor =
              "SCRIPT_selected-lines-edited-by-zeditor"),
            (e.GrammarLinter = "SCRIPT_grammar-linter"),
            (e.ContradictionsLinter = "SCRIPT_contradictions-linter"),
            (e.SpamLinter = "SCRIPT_spam-linter"),
            (e.ToxicityLinter = "SCRIPT_toxicity-linter"),
            (e.MultilingualToxicityLinter =
              "SCRIPT_multilingual-toxicity-linter"),
            (e.ChatJsonataCustomLinter = "SCRIPT_chat-jsonata-custom-linter"),
            (e.ChatRobotsValidationCustomLinter =
              "SCRIPT_chat-robots-validation-custom-linter"),
            (e.ChatMultiReplicaJsonataCustomLinter =
              "SCRIPT_chat-multi-replica-jsonata-custom-linter"),
            (e.ChatLazarusMathTopicsLinter =
              "SCRIPT_chat-lazarus-math-topics-linter"),
            (e.ChatZipFileContentsLinter =
              "SCRIPT_chat-zip-file-contents-linter"),
            (e.ChatCustomEndpointLinter = "SCRIPT_chat-custom-endpoint-linter"),
            (e.ChatPreventAnswerBasedOnContributorWt =
              "SCRIPT_chat-prevent-answer-based-on-contributor-wt"),
            (e.ChatDolphinPromptImage = "SCRIPT_chat-dolphin-prompt-image"),
            (e.NightingaleCheckCorrectnessClassification =
              "SCRIPT_nightingale-check-correctness-classification"),
            (e.ChatJustificationMinWords =
              "SCRIPT_chat-justification-min-words"),
            (e.NightingaleResponseCoherence =
              "SCRIPT_nightingale-response-coherence"),
            (e.ChatPromptModelAgreementLinter =
              "SCRIPT_chat-prompt-model-agreement-linter"),
            (e.BaseChatTaskPerStepLinter =
              "SCRIPT_base-chat-task-per-step-linter"),
            (e.ChatMissingResponseLinter =
              "SCRIPT_chat-task-missing-response-linter"),
            (e.ChatMLSingletonQualityMetricLinter =
              "SCRIPT_chat-ml-singleton-quality-metric-linter"),
            (e.ChatMLPromptResponsePairQualityMetricLinter =
              "SCRIPT_chat-ml-prompt-response-pair-quality-metric-linter"),
            (e.ChatRegexLinter = "SCRIPT_chat-regex-linter"),
            (e.ChatGPTZeroLinter = "SCRIPT_chat-gpt-zero-linter"),
            (e.ChatMinEditDistanceLinter =
              "SCRIPT_chat-min-edit-distance-linter"),
            (e.ChatUniqueResponseLinter = "SCRIPT_chat-unique-response-linter"),
            (e.ChatCompletedTasksUniqueResponseLinter =
              "SCRIPT_chat-completed-tasks-unique-response-linter"),
            (e.ChatPromptResponsePairLinter =
              "SCRIPT_chat-prompt-response-pair-linter"),
            (e.ChatTextLengthLinter = "SCRIPT_chat-text-length-linter"),
            (e.ChatSemanticSimilarityLinter =
              "SCRIPT_chat-semantic-similarity-linter"),
            (e.ChatCorrectLanguageLinter =
              "SCRIPT_chat-correct-language-linter"),
            (e.ChatNGramDiversityLinter = "SCRIPT_chat-ngram-diversity-linter"),
            (e.ChatBadWordsLinter = "SCRIPT_chat-bad-words-linter"),
            (e.ChatGoogleTranslateDetectionLinter =
              "SCRIPT_chat-google-translate-detection-linter"),
            (e.ChatMultiTurnResponseSimilarityLinter =
              "SCRIPT_chat-multi-turn-response-similarity-linter"),
            (e.ChatURLExistsLinter = "SCRIPT_chat-url-exists-linter"),
            (e.ChatPromptResponseWordCountDiffLinter =
              "SCRIPT_chat-prompt-response-word-count-diff-linter"),
            (e.ChatValidLikertScoreLinter =
              "SCRIPT_chat-valid-likert-score-linter"),
            (e.ChatJustificationLikertMatchMLLinter =
              "SCRIPT_chat-likert-justification-match-ml-linter"),
            (e.ChatNightingaleCustomizedLinter =
              "SCRIPT_chat-nightingale-customized-linter"),
            (e.ChatNightingaleArchetypeDiversityLinter =
              "SCRIPT_chat-nightingale-archetype-diversity-linter"),
            (e.ChatNightingaleGoalAlignmentLinter =
              "SCRIPT_chat-nightingale-goal-alignment-linter"),
            (e.ChatNightingalePlagiarismLinter =
              "SCRIPT_chat-nightingale-plagiarism-linter"),
            (e.ChatNightingaleReferenceLinter =
              "SCRIPT_chat-nightingale-reference-linter"),
            (e.ChatNightingaleValidateArchetypeLinter =
              "SCRIPT_chat-nightingale-validate-archetype-linter"),
            (e.ChatNightingaleWordCountLinter =
              "SCRIPT_chat-nightingale-word-count-linter"),
            (e.ChatNightingaleRankingConsistencyLinter =
              "SCRIPT_chat-nightingale-ranking-consistency-linter"),
            (e.ChatNightingaleRatingConsistencyLinter =
              "SCRIPT_chat-nightingale-rating-consistency-linter"),
            (e.ChatPromptComparisonToSearchResult =
              "SCRIPT_chat-prompt-comparison-to-search-result"),
            (e.ChatBulbaFactualityLinter =
              "SCRIPT_chat-bulba-factuality-linter"),
            (e.ChatNERSentenceLinter = "SCRIPT_chat-ner-sentence-linter"),
            (e.ChatBulbaLikertResponseValidator =
              "SCRIPT_chat-bulba-likert-response-validator"),
            (e.ChatBulbaLockFieldLinter =
              "SCRIPT_chat-bulba-lock-field-linter"),
            (e.ChatBulbaCodeEvalCodePresentLinter =
              "SCRIPT_chat-bulba-code-eval-code-present-linter"),
            (e.ChatImageNSFWLinter = "SCRIPT_chat-image-nsfw-linter"),
            (e.ChatMRSSphereExecutionRelevanceLinter =
              "SCRIPT_chat-mrs-sphere-execution-relevance-linter"),
            (e.ChatGoogleSearchPlagiarismLinter =
              "SCRIPT_chat-google-search-plagiarism-linter"),
            (e.ChatMultiModalRelevanceLinter =
              "SCRIPT_chat-multi-modal-relevance-linter"),
            (e.ChatLatexParsingLinter = "SCRIPT_chat-latex-parsing-linter"),
            (e.ChatBlockMMMULinter = "SCRIPT_chat-block-mmmu-linter"),
            (e.ChatAutoraterPlagiarismLinter =
              "SCRIPT_chat-autorater-plagiarism-linter"),
            (e.ChatLambdaUnitTestExecutionLinter =
              "SCRIPT_chat-lambda-unit-test-execution-linter");
        })(h || (t.ScriptLinterName = h = {})),
        (t.ValidatorType = f),
        (function (e) {
          (e.WordCount = "VALIDATOR_word-count"),
            (e.Language = "VALIDATOR_language"),
            (e.URL = "VALIDATOR_correct-url"),
            (e.Regex = "VALIDATOR_regex"),
            (e.BadWords = "VALIDATOR_bad-words"),
            (e.Overlap = "VALIDATOR_response-overlap"),
            (e.InstructionsSimilarity = "VALIDATOR_instruction-similarity"),
            (e.Grammar = "VALIDATOR_grammar"),
            (e.DisablePasting = "VALIDATOR_disable-pasting"),
            (e.MissingResponse = "VALIDATOR_missing-response"),
            (e.TextFormatting = "VALIDATOR_text-formatting"),
            (e.Size = "VALIDATOR_size"),
            (e.TimesUsed = "VALIDATOR_times-used"),
            (e.ContiguousFrameTrack = "VALIDATOR_contiguous-frame-track"),
            (e.StraightLine = "VALIDATOR_straight-line"),
            (e.OverlappingVertices = "VALIDATOR_overlapping-vertices"),
            (e.AnnotationOverlap = "VALIDATOR_annotation-overlap"),
            (e.AnnotationContainment = "VALIDATOR_annotation-containment"),
            (e.PixelPercentage = "VALIDATOR_pixel-percentage"),
            (e.Diversity = "VALIDATOR_diversity"),
            (e.UniqueResponse = "VALIDATOR_unique-response"),
            (e.GPTZero = "VALIDATOR_gptzero"),
            (e.GPTScale = "VALIDATOR_gptscale"),
            (e.Cheating = "VALIDATOR_cheating"),
            (e.NGramDiversity = "VALIDATOR_ngram-diversity"),
            (e.MLQualitySingletonMetric =
              "VALIDATOR_ml-quality-singleton-metric"),
            (e.SemanticSimilarity = "VALIDATOR_semantic-similarity"),
            (e.PRPLinter = "VALIDATOR_prp-linter"),
            (e.TextFieldSphereExecutionOutputLinter =
              "VALIDATOR_text-field-sphere-execution-output-linter");
        })(f || (t.ValidatorType = f = {})),
        (t.PromptValidatorType = g),
        (function (e) {
          (e.Profanity = "profanity"),
            (e.LanguageAndGibberish = "languageAndGibberish"),
            (e.WordCount = "wordCount"),
            (e.ReferenceTextWordCount = "referenceTextWordCount"),
            (e.StringBlocklist = "stringBlocklist"),
            (e.RegexBlocklist = "regexBlocklist"),
            (e.RepeatedWords = "repeatedWords"),
            (e.TextFormatting = "textFormatting"),
            (e.SpellingAndGrammar = "spellingAndGrammar"),
            (e.DisablePasting = "disablePasting"),
            (e.SemanticSimilarity = "semanticSimilarity"),
            (e.NGramDiversity = "nGramDiversity"),
            (e.MLQualitySingletonMetric = "mLQualitySingletonMetric"),
            (e.PRPLinters = "prpLinters"),
            (e.TextFieldSphereExecutionOutputLinter =
              "textFieldSphereExecutionOutputLinter");
        })(g || (t.PromptValidatorType = g = {})),
        (t.ValidatorCategory = y),
        (function (e) {
          (e.Diversity = "Diversity"),
            (e.GeneralQuality = "General Quality"),
            (e.Other = "Other"),
            (e.Multimodal = "Multimodal"),
            (e.JustificationRanking = "Justifications Ranking/Likert"),
            (e.CheatingSpam = "Cheating/Spam"),
            (e.ProjectConstraints = "Project Constraints"),
            (e.Coding = "Coding"),
            (e.Languages = "Languages"),
            (e.ProjectSpecific = "Project Specific"),
            (e.MultiReplica = "Multi Replica");
        })(y || (t.ValidatorCategory = y = {}));
      const T = [
        {
          validatorType: f.WordCount,
          linterName: h.TextFieldWordCount,
          validatorName: "Word Count",
          shortName: "word-count",
          taskTypes: [r.TaskType.TextCollection],
          category: y.ProjectConstraints,
          shortDescription: "Enforce a minimum or maximum text length.",
        },
        {
          validatorType: f.Language,
          linterName: h.TextFieldCorrectLanguage,
          validatorName: "Language & Gibberish Detection",
          shortName: "language",
          taskTypes: [r.TaskType.TextCollection],
          category: y.CheatingSpam,
          shortDescription:
            'Requires the response to be in the specified language. Not very effective (overflags + misses some things) - we recommend instead using PRP with a custom prompt. Same as "Language-Correctness" linter in Chat Task.',
        },
        {
          validatorType: f.Regex,
          linterName: h.TCRegex,
          validatorName: "Regex Blocklist",
          shortName: "regex",
          taskTypes: [r.TaskType.TextCollection],
          category: y.ProjectConstraints,
          shortDescription:
            'Use regular expression rules to prevent the most common errors or enforce certain response formats. Same as "Regex" linter in Chat Task.',
        },
        {
          validatorType: f.BadWords,
          linterName: h.TCBadWords,
          validatorName: "String Blocklist",
          shortName: "string-blocklist",
          taskTypes: [r.TaskType.TextCollection],
          category: y.ProjectConstraints,
          shortDescription: "Prevents inappropriate words in response",
        },
        {
          validatorType: f.Overlap,
          linterName: h.TextFieldOverlap,
          validatorName: "Response Similarity",
          shortName: "response-similarity",
          taskTypes: [r.TaskType.TextCollection],
          category: y.CheatingSpam,
          shortDescription:
            "This validator prevents labelers from submitting prompts that overlap too much with reference text.",
        },
        {
          validatorType: f.InstructionsSimilarity,
          linterName: h.TextFieldPromptSpam,
          validatorName: "Require Edits",
          shortName: "require-edits",
          taskTypes: [r.TaskType.TextCollection],
          category: y.CheatingSpam,
          shortDescription: "Enforce levenshtein edits from hypothesis filter.",
        },
        {
          validatorType: f.URL,
          linterName: h.URLExists,
          validatorName: "URL Formatting",
          shortName: "correct-url",
          taskTypes: [r.TaskType.TextCollection],
          category: y.ProjectConstraints,
          shortDescription: "Checks if the URL provided is a working link",
        },
        {
          validatorType: f.TextFormatting,
          linterName: h.TCRegex,
          validatorName: "Text Formatting",
          shortName: "formatting",
          taskTypes: [r.TaskType.TextCollection],
          category: y.GeneralQuality,
          shortDescription:
            "Requires sentence case capitalization, punctuation, and no trailing whitespaces.",
        },
        {
          validatorType: f.DisablePasting,
          linterName: h.TCRegex,
          validatorName: "Disable Pasting",
          shortName: "TAXONOMY_disable-pasting",
          taskTypes: [r.TaskType.TextCollection],
          category: y.CheatingSpam,
          shortDescription: "Prevents pasting in the response field.",
        },
        {
          validatorType: f.Size,
          linterName: h.MinMaxSize,
          validatorName: "Size",
          shortName: "size",
          taskTypes: [
            r.TaskType.ImageAnnotation,
            r.TaskType.VideoPlaybackAnnotation,
            r.TaskType.SegmentAnnotation,
          ],
        },
        {
          validatorType: f.TimesUsed,
          linterName: h.TimesUsed,
          validatorName: "Label Usage",
          shortName: "label-usage",
          taskTypes: [
            r.TaskType.ImageAnnotation,
            r.TaskType.VideoPlaybackAnnotation,
          ],
        },
        {
          validatorType: f.ContiguousFrameTrack,
          linterName: h.ContiguousFrameTrack,
          validatorName: "Contiguous Objects",
          shortName: "contiguous-objects",
          taskTypes: [r.TaskType.VideoPlaybackAnnotation],
        },
        {
          validatorType: f.StraightLine,
          linterName: h.PolygonStraightLine,
          validatorName: "Collinear Points",
          shortName: "collinear-points",
          taskTypes: [r.TaskType.ImageAnnotation],
        },
        {
          validatorType: f.OverlappingVertices,
          linterName: h.OverlappingVertices,
          validatorName: "Duplicate Vertex",
          shortName: "duplicate-vertex",
          taskTypes: [r.TaskType.ImageAnnotation],
        },
        {
          validatorType: f.AnnotationOverlap,
          linterName: h.Overlapping,
          validatorName: "Overlap",
          shortName: "annotation-overlap",
          taskTypes: [
            r.TaskType.ImageAnnotation,
            r.TaskType.VideoPlaybackAnnotation,
          ],
        },
        {
          validatorType: f.AnnotationContainment,
          linterName: h.Overlapping,
          validatorName: "Containment",
          shortName: "annotation-containment",
          taskTypes: [
            r.TaskType.ImageAnnotation,
            r.TaskType.VideoPlaybackAnnotation,
          ],
        },
        {
          validatorType: f.PixelPercentage,
          linterName: h.SemsegLabelMinMax,
          validatorName: "Pixel Percentage",
          shortName: "pixel-percentage",
          taskTypes: [r.TaskType.SegmentAnnotation],
        },
        {
          validatorType: f.PixelPercentage,
          linterName: h.SemsegLabelMinMax,
          validatorName: "Pixel Percentage",
          shortName: "pixel-percentage",
          taskTypes: [r.TaskType.SegmentAnnotation],
        },
        {
          validatorType: f.Diversity,
          linterName: h.TextFieldDiversity,
          validatorName: "Regex Diversity",
          shortName: "diversity",
          taskTypes: [r.TaskType.TextCollection],
          category: y.Diversity,
          shortDescription:
            "Looks back at window of attempts for a tasker and checks the # of attempts that match the regex, and blocks them.",
        },
        {
          validatorType: f.UniqueResponse,
          linterName: h.TextFieldUniqueResponse,
          validatorName: "Unique Response",
          shortName: "unique-response",
          taskTypes: [r.TaskType.TextCollection],
          category: y.Diversity,
          shortDescription:
            "Looks back at attempts done in the last 24 hours and prevents any within a certain Levenshtein distance.",
        },
        {
          validatorType: f.GPTZero,
          linterName: h.GPTZeroLinter,
          validatorName: "GPT Zero",
          shortName: "gptzero",
          taskTypes: [r.TaskType.TextCollection],
          category: y.CheatingSpam,
          shortDescription:
            "Checks if the field text exceeds a certain GPTZero threshold.",
        },
        {
          validatorType: f.GPTScale,
          linterName: h.GPTScaleLinter,
          validatorName: "GPT Scale Linter",
          shortName: "gptscale",
          taskTypes: [r.TaskType.TextCollection],
          category: y.CheatingSpam,
        },
        {
          validatorType: f.Cheating,
          linterName: h.TextFieldCheatingLinter,
          validatorName: "Cheating",
          shortName: "cheating",
          taskTypes: [r.TaskType.TextCollection],
          category: y.CheatingSpam,
          shortDescription:
            "Used to ban taskers suspected of cheating (e.g., copying/pasting from ChatGPT), or escalate tasks suspected of cheating.",
        },
        {
          validatorType: f.NGramDiversity,
          linterName: h.NGramDiversityLinter,
          validatorName: "NGram Diversity",
          shortName: "ngram-diversity",
          taskTypes: [r.TaskType.TextCollection],
          category: y.Diversity,
          shortDescription: "Enforce diversity of word choice across tasks.",
        },
        {
          validatorType: f.MLQualitySingletonMetric,
          linterName: h.MLQualitySingletonMetric,
          validatorName: "ML Quality Singleton Metric",
          shortName: "ml-quality-singleton-metric",
          taskTypes: [r.TaskType.TextCollection],
          category: y.Diversity,
        },
        {
          validatorType: f.SemanticSimilarity,
          linterName: h.TextFieldSemanticSimilarity,
          validatorName: "Semantic Similarity",
          shortName: "semanticsimilarity",
          taskTypes: [r.TaskType.TextCollection],
          category: y.Diversity,
          shortDescription:
            "Blocks a prompt from being submitted if the cosine similarity to existing prompts submitted (across the entire project) is above the threshold.",
        },
        {
          validatorType: f.PRPLinter,
          linterName: h.TextFieldPromptResponsePairLinter,
          validatorName: "PRP Linter",
          shortName: "prplinter",
          taskTypes: [r.TaskType.TextCollection],
          category: y.Diversity,
          shortDescription: "Run a GPT-4 prompt and lint based on output.",
        },
        {
          validatorType: f.TextFieldSphereExecutionOutputLinter,
          linterName: h.TextFieldSphereExecutionOutputLinter,
          validatorName: "Text Field Sphere Execution Output Linter",
          shortName: "text-field-sphere-execution-output-linter",
          taskTypes: [r.TaskType.TextCollection],
          category: y.ProjectConstraints,
        },
      ];
      t.AVAILABLE_VALIDATORS = T;
      const _ = {
        [h.TextFieldWordCount]: f.WordCount,
        [h.TextFieldCorrectLanguage]: f.Language,
        [h.URLExists]: f.URL,
        [h.TCRegex]: f.Regex,
        [h.TCBadWords]: f.BadWords,
        [h.TextFieldOverlap]: f.Overlap,
        [h.TextFieldPromptSpam]: f.InstructionsSimilarity,
        [h.TextFieldSaplingGrammarLinter]: f.Grammar,
        [h.MissingResponse]: f.MissingResponse,
        [h.MinMaxSize]: f.Size,
        [h.TimesUsed]: f.TimesUsed,
        [h.ContiguousFrameTrack]: f.ContiguousFrameTrack,
        [h.PolygonStraightLine]: f.StraightLine,
        [h.OverlappingVertices]: f.OverlappingVertices,
        [h.Overlapping]: f.AnnotationOverlap,
        [h.SemsegLabelMinMax]: f.PixelPercentage,
      };
      var S, v, C, I, R, x, L, w, P, E, A;
      (t.DEFAULT_VALIDATOR = _),
        (t.HypothesisChangedLintMode = S),
        (function (e) {
          (e.AnyChange = "any-change"), (e.NoChange = "no-change");
        })(S || (t.HypothesisChangedLintMode = S = {})),
        (t.NerRelationshipsOverlapType = v),
        (function (e) {
          (e.Full = "full"), (e.None = "none");
        })(v || (t.NerRelationshipsOverlapType = v = {})),
        (t.MetadataUnitConversionType = C),
        (function (e) {
          (e.Same = "same"), (e.Different = "different");
        })(C || (t.MetadataUnitConversionType = C = {})),
        (t.ContainmentDependentOn = I),
        (function (e) {
          (e.OUTER = "outer"), (e.INNER = "inner");
        })(I || (t.ContainmentDependentOn = I = {})),
        (t.LogicalOperator = R),
        (function (e) {
          (e.AND = "AND"), (e.OR = "OR");
        })(R || (t.LogicalOperator = R = {})),
        (t.ComparisonOperator = x),
        (function (e) {
          (e.EQ = "==="),
            (e.NEQ = "!=="),
            (e.GT = ">"),
            (e.GTE = ">="),
            (e.LT = "<"),
            (e.LTE = "<=");
        })(x || (t.ComparisonOperator = x = {})),
        (t.ValidJsonLintModes = L),
        (function (e) {
          (e.JSON = "JSON"),
            (e.Array = "array"),
            (e.DoubleArray = "doubleArray");
        })(L || (t.ValidJsonLintModes = L = {})),
        (t.RegexMatches = w),
        (function (e) {
          (e.Every = "every"), (e.Some = "some"), (e.None = "none");
        })(w || (t.RegexMatches = w = {})),
        (t.UserAgentsStrategy = P),
        (function (e) {
          (e.Every = "every"), (e.Some = "some");
        })(P || (t.UserAgentsStrategy = P = {})),
        (t.ZIndexLinterOperator = E),
        (function (e) {
          (e.LT = "lt"), (e.LTE = "lte"), (e.GT = "gt"), (e.GTE = "gte");
        })(E || (t.ZIndexLinterOperator = E = {})),
        (t.KeypointsDistanceOrientation = A),
        (function (e) {
          (e.Horizontal = "horizontal"),
            (e.Vertical = "vertical"),
            (e.TotalDistance = "totalDistance");
        })(A || (t.KeypointsDistanceOrientation = A = {}));
      const k = [h.EmptyTask, h.TimeSpent];
      t.enterpriseDefaultScriptLinterNames = k;
      const O = Object.values(r.TaskType).filter(
        (e) => e !== r.TaskType.SensorFusion
      );
      t.timeSpentLinterAllowedTaskTypes = O;
      const M = [
        r.TaskType.Annotation,
        r.TaskType.PolygonAnnotation,
        r.TaskType.CuboidAnnotation,
        r.TaskType.LineAnnotation,
        r.TaskType.ImageAnnotation,
        r.TaskType.LineAnnotation,
        r.TaskType.CuboidAnnotation,
        r.TaskType.PointAnnotation,
        r.TaskType.VideoAnnotation,
        r.TaskType.VideoBoxAnnotation,
        r.TaskType.VideoCuboidAnnotation,
        r.TaskType.VideoPolygonAnnotation,
        r.TaskType.VideoPlaybackAnnotation,
        r.TaskType.LidarAnnotation,
        r.TaskType.TextCollection,
        r.TaskType.GenericDataCollection,
        r.TaskType.SegmentAnnotation,
        r.TaskType.Categorization,
        r.TaskType.SensorFusion,
      ];
      var N, z, j, D;
      (t.emptyTaskLinterAllowedTaskTypes = M),
        (t.TextInAttachmentMode = N),
        (function (e) {
          (e.FullText = "fulltext"), (e.Word = "word");
        })(N || (t.TextInAttachmentMode = N = {})),
        (t.TextInAttachmentCustom = z),
        (function (e) {
          e.WoodpeckerEnrichment = "woodpecker-enrichment";
        })(z || (t.TextInAttachmentCustom = z = {})),
        (t.AcceptedSphereLanguage = j),
        (function (e) {
          (e.Python = "python"),
            (e.Cplusplus = "c++"),
            (e.Javascript = "javascript"),
            (e.Java = "java"),
            (e.SQL = "sql"),
            (e.None = "");
        })(j || (t.AcceptedSphereLanguage = j = {})),
        (t.LidarCuboidShiftMode = D),
        (function (e) {
          (e.Legacy = "legacy"),
            (e.DistanceToEgo = "distance-to-ego"),
            (e.TravelledDistance = "travelled-distance"),
            (e.LegacyWithMetrics = "legacy-with-metrics"),
            (e.DistanceToEgoV2 = "distance-to-ego-v2");
        })(D || (t.LidarCuboidShiftMode = D = {}));
      var F;
      (t.isLidarCuboidShiftMetadata = (e) =>
        "mode" in e?.extra && Object.values(D).includes(e.extra.mode)),
        (t.GoogleTranslationLanguages = F),
        (function (e) {
          (e.Afrikaans = "Afrikaans"),
            (e.Albanian = "Albanian"),
            (e.Amharic = "Amharic"),
            (e.Arabic = "Arabic"),
            (e.Armenian = "Armenian"),
            (e.Assamese = "Assamese"),
            (e.Aymara = "Aymara"),
            (e.Azerbaijani = "Azerbaijani"),
            (e.Bambara = "Bambara"),
            (e.Basque = "Basque"),
            (e.Belarusian = "Belarusian"),
            (e.Bengali = "Bengali"),
            (e.Bhojpuri = "Bhojpuri"),
            (e.Bosnian = "Bosnian"),
            (e.Bulgarian = "Bulgarian"),
            (e.Catalan = "Catalan"),
            (e.Cebuano = "Cebuano"),
            (e.ChineseSimplified = "Chinese (Simplified)"),
            (e.Chinese = "Chinese (Traditional)"),
            (e.Corsican = "Corsican"),
            (e.Croatian = "Croatian"),
            (e.Czech = "Czech"),
            (e.Danish = "Danish"),
            (e.Dhivehi = "Dhivehi"),
            (e.Dogri = "Dogri"),
            (e.Dutch = "Dutch"),
            (e.English = "English"),
            (e.Esperanto = "Esperanto"),
            (e.Estonian = "Estonian"),
            (e.Ewe = "Ewe"),
            (e.Filipino = "Filipino (Tagalog)"),
            (e.Finnish = "Finnish"),
            (e.French = "French"),
            (e.Frisian = "Frisian"),
            (e.Galician = "Galician"),
            (e.Georgian = "Georgian"),
            (e.German = "German"),
            (e.Greek = "Greek"),
            (e.Guarani = "Guarani"),
            (e.Gujarati = "Gujarati"),
            (e.Haitian = "Haitian Creole"),
            (e.Hausa = "Hausa"),
            (e.Hawaiian = "Hawaiian"),
            (e.Hebrew = "Hebrew"),
            (e.Hindi = "Hindi"),
            (e.Hmong = "Hmong"),
            (e.Hungarian = "Hungarian"),
            (e.Icelandic = "Icelandic"),
            (e.Igbo = "Igbo"),
            (e.Ilocano = "Ilocano"),
            (e.Indonesian = "Indonesian"),
            (e.Irish = "Irish"),
            (e.Italian = "Italian"),
            (e.Japanese = "Japanese"),
            (e.Javanese = "Javanese"),
            (e.Kannada = "Kannada"),
            (e.Kazakh = "Kazakh"),
            (e.Khmer = "Khmer"),
            (e.Kinyarwanda = "Kinyarwanda"),
            (e.Konkani = "Konkani"),
            (e.Korean = "Korean"),
            (e.Krio = "Krio"),
            (e.Kurdish = "Kurdish"),
            (e.KurdishSorani = "Kurdish (Sorani)"),
            (e.Kyrgyz = "Kyrgyz"),
            (e.Lao = "Lao"),
            (e.Latin = "Latin"),
            (e.Latvian = "Latvian"),
            (e.Lingala = "Lingala"),
            (e.Lithuanian = "Lithuanian"),
            (e.Luganda = "Luganda"),
            (e.Luxembourgish = "Luxembourgish"),
            (e.Macedonian = "Macedonian"),
            (e.Maithili = "Maithili"),
            (e.Malagasy = "Malagasy"),
            (e.Malay = "Malay"),
            (e.Malayalam = "Malayalam"),
            (e.Maltese = "Maltese"),
            (e.Maori = "Maori"),
            (e.Marathi = "Marathi"),
            (e.Meiteilon = "Meiteilon (Manipuri)"),
            (e.Mizo = "Mizo"),
            (e.Mongolian = "Mongolian"),
            (e.Myanmar = "Myanmar (Burmese)"),
            (e.Nepali = "Nepali"),
            (e.Norwegian = "Norwegian"),
            (e.Nyanja = "Nyanja (Chichewa)"),
            (e.Odia = "Odia (Oriya)"),
            (e.Oromo = "Oromo"),
            (e.Pashto = "Pashto"),
            (e.Persian = "Persian"),
            (e.Polish = "Polish"),
            (e.Portuguese = "Portuguese (Portugal, Brazil)"),
            (e.Punjabi = "Punjabi"),
            (e.Quechua = "Quechua"),
            (e.Romanian = "Romanian"),
            (e.Russian = "Russian"),
            (e.Samoan = "Samoan"),
            (e.Sanskrit = "Sanskrit"),
            (e.Scots = "Scots Gaelic"),
            (e.Sepedi = "Sepedi"),
            (e.Serbian = "Serbian"),
            (e.Sesotho = "Sesotho"),
            (e.Shona = "Shona"),
            (e.Sindhi = "Sindhi"),
            (e.Sinhala = "Sinhala (Sinhalese)"),
            (e.Slovak = "Slovak"),
            (e.Slovenian = "Slovenian"),
            (e.Somali = "Somali"),
            (e.Spanish = "Spanish"),
            (e.Sundanese = "Sundanese"),
            (e.Swahili = "Swahili"),
            (e.Swedish = "Swedish"),
            (e.Tagalog = "Tagalog (Filipino)"),
            (e.Tajik = "Tajik"),
            (e.Tamil = "Tamil"),
            (e.Tatar = "Tatar"),
            (e.Telugu = "Telugu"),
            (e.Thai = "Thai"),
            (e.Tigrinya = "Tigrinya"),
            (e.Tsonga = "Tsonga"),
            (e.Turkish = "Turkish"),
            (e.Turkmen = "Turkmen"),
            (e.Twi = "Twi (Akan)"),
            (e.Ukrainian = "Ukrainian"),
            (e.Urdu = "Urdu"),
            (e.Uyghur = "Uyghur"),
            (e.Uzbek = "Uzbek"),
            (e.Vietnamese = "Vietnamese"),
            (e.Welsh = "Welsh"),
            (e.Xhosa = "Xhosa"),
            (e.Yiddish = "Yiddish"),
            (e.Yoruba = "Yoruba"),
            (e.Zulu = "Zulu");
        })(F || (t.GoogleTranslationLanguages = F = {}));
    },
    893926: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.AnthropicMessagesParamsSchema = void 0);
      var i,
        r = (i = n(689510)) && i.__esModule ? i : { default: i };
      const o = r.default.object({
        max_tokens: r.default
          .number()
          .int()
          .positive()
          .describe(
            "The maximum number of tokens to generate before stopping."
          ),
        temperature: r.default
          .number()
          .min(0)
          .max(1)
          .optional()
          .describe(
            "Amount of randomness injected into the response. Defaults to 1.0."
          ),
        top_k: r.default
          .number()
          .int()
          .nonnegative()
          .optional()
          .describe(
            "Only sample from the top K options for each subsequent token."
          ),
        top_p: r.default
          .number()
          .min(0)
          .max(1)
          .optional()
          .describe(
            "Use nucleus sampling; cuts off options once cumulative probability reaches top_p."
          ),
        stop_sequences: r.default
          .array(r.default.string())
          .optional()
          .describe(
            "Custom text sequences that will cause the model to stop generating."
          ),
        stream: r.default
          .boolean()
          .optional()
          .describe(
            "Whether to incrementally stream the response using server-sent events."
          ),
        system: r.default
          .string()
          .optional()
          .describe(
            "A system prompt providing context and instructions to Claude."
          ),
        metadata: r.default
          .object({})
          .optional()
          .describe("An object describing metadata about the request."),
      });
      t.AnthropicMessagesParamsSchema = o;
    },
    527096: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 });
      var i = {},
        r = s(n(893926));
      Object.keys(r).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === r[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return r[e];
              },
            }));
      });
      var o = s(n(421584));
      Object.keys(o).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === o[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return o[e];
              },
            }));
      });
      var a = s(n(19016));
      function s(e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (null != e)
          for (var n in e)
            if (Object.prototype.hasOwnProperty.call(e, n)) {
              var i =
                Object.defineProperty && Object.getOwnPropertyDescriptor
                  ? Object.getOwnPropertyDescriptor(e, n)
                  : {};
              i.get || i.set ? Object.defineProperty(t, n, i) : (t[n] = e[n]);
            }
        return (t.default = e), t;
      }
      Object.keys(a).forEach(function (e) {
        "default" !== e &&
          "__esModule" !== e &&
          (Object.prototype.hasOwnProperty.call(i, e) ||
            (e in t && t[e] === a[e]) ||
            Object.defineProperty(t, e, {
              enumerable: !0,
              get: function () {
                return a[e];
              },
            }));
      });
    },
    421584: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.OpenAIChatCompletionParamsSchema =
          t.FunctionObjectSchema =
          t.OpenAIModelsSchema =
            void 0);
      var i = n(689510);
      const r = i.z
        .enum([
          "gpt-3.5-turbo",
          "gpt-4",
          "gpt-4-turbo",
          "gpt-4-1106-preview",
          "gpt-4-vision-preview",
          "gpt-4-turbo-preview",
          "gpt-4o",
          "gpt-4o-mini",
          "gpt-4o-2024-08-06",
          "gpt-4o-rrr-0903",
          "gpt-4o-rrr-n",
          "o1-preview",
          "o1-mini",
          "gpt-4o-audio-preview",
        ])
        .describe("Models available from OpenAI.");
      t.OpenAIModelsSchema = r;
      const o = i.z.object({
        description: i.z
          .string()
          .optional()
          .describe(
            "A description of what the function does, used by the model to choose when and how to call the function."
          ),
        name: i.z
          .string()
          .describe(
            "The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."
          ),
        parameters: i.z.any().optional(),
        strict: i.z
          .boolean()
          .optional()
          .describe(
            "Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Learn more about Structured Outputs in the [function calling guide](docs/guides/function-calling)."
          ),
      });
      t.FunctionObjectSchema = o;
      const a = i.z.object({
        stream: i.z
          .boolean()
          .optional()
          .describe(
            "If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message."
          ),
        stream_options: i.z
          .object({
            include_usage: i.z
              .boolean()
              .optional()
              .describe(
                "If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value."
              ),
          })
          .optional(),
        temperature: i.z
          .number()
          .min(0)
          .max(2)
          .optional()
          .describe(
            "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic."
          ),
        top_p: i.z
          .number()
          .min(0)
          .max(1)
          .optional()
          .describe(
            "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered."
          ),
        frequency_penalty: i.z
          .number()
          .min(-2)
          .max(2)
          .optional()
          .describe(
            "Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim."
          ),
        logit_bias: i.z
          .record(i.z.string(), i.z.number().min(-100).max(100))
          .optional()
          .describe(
            "Modify the likelihood of specified tokens appearing in the completion."
          ),
        logprobs: i.z
          .boolean()
          .optional()
          .describe(
            "Whether to return log probabilities of the output tokens or not."
          ),
        top_logprobs: i.z
          .number()
          .min(0)
          .max(20)
          .optional()
          .describe(
            "An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. `logprobs` must be set to `true` if this parameter is used."
          ),
        max_tokens: i.z
          .number()
          .optional()
          .describe(
            "The maximum number of [tokens](/tokenizer) that can be generated in the chat completion."
          ),
        n: i.z
          .number()
          .min(1)
          .max(128)
          .optional()
          .describe(
            "How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep `n` as `1` to minimize costs."
          ),
        presence_penalty: i.z
          .number()
          .min(-2)
          .max(2)
          .optional()
          .describe(
            "Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics."
          ),
        response_format: i.z
          .discriminatedUnion("type", [
            i.z.object({
              type: i.z.literal("json_schema"),
              json_schema: i.z.record(i.z.any()),
            }),
            i.z.object({ type: i.z.literal("json_object") }),
            i.z.object({ type: i.z.literal("text") }),
          ])
          .optional()
          .describe(
            "An object specifying the format that the model must output."
          ),
        seed: i.z
          .number()
          .min(-0x8000000000000000)
          .max(0x8000000000000000)
          .optional()
          .describe(
            "This feature is in Beta. If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result."
          ),
        service_tier: i.z
          .enum(["auto", "default"])
          .optional()
          .describe(
            "Specifies the latency tier to use for processing the request. This parameter is relevant for customers subscribed to the scale tier service."
          ),
        stop: i.z
          .array(i.z.string())
          .optional()
          .describe(
            "Up to 4 sequences where the API will stop generating further tokens."
          ),
        tools: i.z
          .array(
            i.z.object({
              type: i.z
                .enum(["function"])
                .describe(
                  "The type of the tool. Currently, only `function` is supported."
                ),
              function: o,
            })
          )
          .transform((e) => (0 === e.length ? void 0 : e))
          .optional()
          .describe(
            "A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for. A max of 128 functions are supported."
          ),
        tool_choice: i.z.record(i.z.any()).optional(),
        parallel_tool_calls: i.z.record(i.z.any()).optional(),
        user: i.z
          .string()
          .optional()
          .describe(
            "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse."
          ),
      });
      t.OpenAIChatCompletionParamsSchema = a;
    },
    19016: function (e, t, n) {
      "use strict";
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.VLLMAdditionalParamsSchema = void 0);
      var i = n(689510);
      const r = i.z.object({
        best_of: i.z
          .number()
          .int()
          .optional()
          .describe(
            "Number of output sequences that are generated from the prompt.\n    From these 'best_of' sequences, the top 'n' sequences are returned.\n    'best_of' must be greater than or equal to 'n'. This is treated as\n    the beam width when 'use_beam_search' is True. By default, 'best_of'\n    is set to 'n'."
          ),
        top_k: i.z
          .number()
          .int()
          .min(-1)
          .optional()
          .describe(
            "Controls the number of top tokens to consider. -1 means consider all tokens."
          ),
        min_p: i.z
          .number()
          .min(0)
          .max(1)
          .optional()
          .describe(
            "Float that represents the minimum probability for a token to be\n    considered, relative to the probability of the most likely token.\n    Must be in [0, 1]. Set to 0 to disable this."
          ),
        use_beam_search: i.z
          .boolean()
          .optional()
          .describe("Whether to use beam search for sampling."),
        length_penalty: i.z
          .number()
          .optional()
          .describe(
            "Float that penalizes sequences based on their length.\n    Used in beam search."
          ),
        repetition_penalty: i.z
          .number()
          .optional()
          .describe(
            "Float that penalizes new tokens based on whether\n    they appear in the prompt and the generated text so far. Values > 1\n    encourage the model to use new tokens, while values < 1 encourage\n    the model to repeat tokens."
          ),
        early_stopping: i.z
          .boolean()
          .optional()
          .describe(
            "Controls the stopping condition for beam search. It\n    accepts the following values: 'True', where the generation stops as\n    soon as there are 'best_of' complete candidates; 'False', where an\n    heuristic is applied and the generation stops when is it very\n    unlikely to find better candidates; 'never', where the beam search\n    procedure only stops when there cannot be better candidates\n    (canonical beam search algorithm)."
          ),
        stop_token_ids: i.z
          .array(i.z.number().int())
          .optional()
          .describe(
            "List of tokens that stop the generation when they are\n    generated. The returned output will contain the stop tokens unless\n    the stop tokens are special tokens."
          ),
        include_stop_str_in_output: i.z
          .boolean()
          .optional()
          .describe(
            "Whether to include the stop strings in\n    output text. Defaults to False."
          ),
        ignore_eos: i.z
          .boolean()
          .optional()
          .describe(
            "Whether to ignore the EOS token and continue generating\n    tokens after the EOS token is generated."
          ),
        min_tokens: i.z
          .number()
          .int()
          .optional()
          .describe(
            "Minimum number of tokens to generate per output sequence\n    before EOS or stop_token_ids can be generated"
          ),
        skip_special_tokens: i.z
          .boolean()
          .optional()
          .describe(
            "Whether to skip special tokens in the output. Only supported in vllm."
          ),
        spaces_between_special_tokens: i.z
          .boolean()
          .optional()
          .describe(
            "Whether to add spaces between special tokens in the output. Only supported in vllm."
          ),
        chat_template: i.z
          .string()
          .describe("A Jinja template to use for this conversion")
          .optional(),
        chat_template_kwargs: i.z
          .record(i.z.any())
          .describe("Additional kwargs to pass to the template render")
          .optional(),
        guided_json: i.z
          .record(i.z.any())
          .describe("JSON schema for guided decoding")
          .optional(),
        guided_regex: i.z
          .string()
          .describe("Regex for guided decoding")
          .optional(),
        guided_choice: i.z
          .array(i.z.string())
          .describe("Choices for guided decoding")
          .optional(),
        guided_grammar: i.z
          .string()
          .describe("Context-free grammar for guided decoding")
          .optional(),
        guided_decoding_backend: i.z
          .enum(["outlines", "lm-format-enforcer"])
          .describe("Guided decoding backend")
          .optional(),
        guided_whitespace_pattern: i.z
          .string()
          .describe("Whitespace pattern for guided json decoding")
          .optional(),
      });
      t.VLLMAdditionalParamsSchema = r;
    },
    388703: function (e, t) {
      "use strict";
      var n, i, r, o, a;
      Object.defineProperty(t, "__esModule", { value: !0 }),
        (t.DEFAULT_EGREGIOUS_THRESHOLDS =
          t.EgregiousnessLevel =
          t.CustomEndpointType =
          t.PromptResponsePairQualityMetricType =
          t.SingletonQualityMetricType =
          t.QualityMetricType =
            void 0),
        (t.QualityMetricType = n),
        (function (e) {
          (e.GrammaticalityNormalized = "Grammaticality-Normalized"),
            (e.PassiveVoiceNormalized = "PassiveVoice-Normalized"),
            (e.LogicalComplexityNormalized = "LogicalComplexity-Normalized"),
            (e.WritingLevelNormalized = "WritingLevel-Normalized"),
            (e.ContradictionsNormalized = "Contradictions-Normalized"),
            (e.SemanticRepetitionNormalized = "SemanticRepetition-Normalized"),
            (e.RelevanceNormalized = "Relevance-Normalized"),
            (e.InformativenessNormalized = "Informativeness-Normalized"),
            (e.SpamNormalized = "Spam-Normalized"),
            (e.ToxicityNormalized = "Toxicity-Normalized"),
            (e.MultilingualToxicityNormalized =
              "MultilingualToxicity-Normalized");
        })(n || (t.QualityMetricType = n = {})),
        (t.SingletonQualityMetricType = i),
        (function (e) {
          (e.GrammaticalityNormalized = "Grammaticality-Normalized"),
            (e.PassiveVoiceNormalized = "PassiveVoice-Normalized"),
            (e.LogicalComplexityNormalized = "LogicalComplexity-Normalized"),
            (e.WritingLevelNormalized = "WritingLevel-Normalized"),
            (e.ContradictionsNormalized = "Contradictions-Normalized"),
            (e.SemanticRepetitionNormalized = "SemanticRepetition-Normalized"),
            (e.SpamNormalized = "Spam-Normalized"),
            (e.ToxicityNormalized = "Toxicity-Normalized"),
            (e.MultilingualToxicityNormalized =
              "MultilingualToxicity-Normalized");
        })(i || (t.SingletonQualityMetricType = i = {})),
        (t.PromptResponsePairQualityMetricType = r),
        (function (e) {
          e.RelevanceNormalized = "Relevance-Normalized";
        })(r || (t.PromptResponsePairQualityMetricType = r = {})),
        (t.CustomEndpointType = o),
        (function (e) {
          e.LazarusCodePromptCategory = "LazarusCodePromptCategory";
        })(o || (t.CustomEndpointType = o = {})),
        (t.EgregiousnessLevel = a),
        (function (e) {
          (e.Egregious = "Egregious"),
            (e.Suspect = "Suspect"),
            (e.Acceptable = "Acceptable");
        })(a || (t.EgregiousnessLevel = a = {}));
      const s = {
        [n.GrammaticalityNormalized]: {
          promptThresholds: {
            egregiousThreshold: 0.05,
            suspectThreshold: 0.15,
          },
          completionThresholds: {
            egregiousThreshold: 0.05,
            suspectThreshold: 0.15,
          },
        },
        [n.SpamNormalized]: {
          promptThresholds: { egregiousThreshold: 0.4, suspectThreshold: 0.5 },
          completionThresholds: {
            egregiousThreshold: 0.4,
            suspectThreshold: 0.5,
          },
        },
        [n.ToxicityNormalized]: {
          promptThresholds: { egregiousThreshold: 0.9, suspectThreshold: 0.95 },
          completionThresholds: {
            egregiousThreshold: 0.9,
            suspectThreshold: 0.95,
          },
        },
        [n.MultilingualToxicityNormalized]: {
          promptThresholds: { egregiousThreshold: 0.1, suspectThreshold: 0.2 },
          completionThresholds: {
            egregiousThreshold: 0.1,
            suspectThreshold: 0.2,
          },
        },
        [n.PassiveVoiceNormalized]: {},
        [n.LogicalComplexityNormalized]: {},
        [n.WritingLevelNormalized]: {},
        [n.ContradictionsNormalized]: {},
        [n.SemanticRepetitionNormalized]: {},
        [n.RelevanceNormalized]: {},
        [n.InformativenessNormalized]: {},
      };
      t.DEFAULT_EGREGIOUS_THRESHOLDS = s;
    },
    39300: function (e) {
      var t;
      self,
        (t = () => {
          return (
            (e = {
              7629: (e, t, n) => {
                "use strict";
                const i = n(375),
                  r = n(8571),
                  o = n(9474),
                  a = n(1687),
                  s = n(8652),
                  l = n(8160),
                  c = n(3292),
                  p = n(6354),
                  u = n(8901),
                  d = n(9708),
                  m = n(6914),
                  h = n(2294),
                  f = n(6133),
                  g = n(1152),
                  y = n(8863),
                  b = n(2036),
                  T = {
                    Base: class {
                      constructor(e) {
                        (this.type = e),
                          (this.$_root = null),
                          (this._definition = {}),
                          this._reset();
                      }
                      _reset() {
                        (this._ids = new h.Ids()),
                          (this._preferences = null),
                          (this._refs = new f.Manager()),
                          (this._cache = null),
                          (this._valids = null),
                          (this._invalids = null),
                          (this._flags = {}),
                          (this._rules = []),
                          (this._singleRules = new Map()),
                          (this.$_terms = {}),
                          (this.$_temp = { ruleset: null, whens: {} });
                      }
                      describe() {
                        return (
                          i(
                            "function" == typeof d.describe,
                            "Manifest functionality disabled"
                          ),
                          d.describe(this)
                        );
                      }
                      allow() {
                        for (
                          var e = arguments.length, t = new Array(e), n = 0;
                          n < e;
                          n++
                        )
                          t[n] = arguments[n];
                        return (
                          l.verifyFlat(t, "allow"), this._values(t, "_valids")
                        );
                      }
                      alter(e) {
                        i(
                          e && "object" == typeof e && !Array.isArray(e),
                          "Invalid targets argument"
                        ),
                          i(
                            !this._inRuleset(),
                            "Cannot set alterations inside a ruleset"
                          );
                        const t = this.clone();
                        t.$_terms.alterations = t.$_terms.alterations || [];
                        for (const n in e) {
                          const r = e[n];
                          i(
                            "function" == typeof r,
                            "Alteration adjuster for",
                            n,
                            "must be a function"
                          ),
                            t.$_terms.alterations.push({
                              target: n,
                              adjuster: r,
                            });
                        }
                        return (t.$_temp.ruleset = !1), t;
                      }
                      artifact(e) {
                        return (
                          i(void 0 !== e, "Artifact cannot be undefined"),
                          i(
                            !this._cache,
                            "Cannot set an artifact with a rule cache"
                          ),
                          this.$_setFlag("artifact", e)
                        );
                      }
                      cast(e) {
                        return (
                          i(
                            !1 === e || "string" == typeof e,
                            "Invalid to value"
                          ),
                          i(
                            !1 === e || this._definition.cast[e],
                            "Type",
                            this.type,
                            "does not support casting to",
                            e
                          ),
                          this.$_setFlag("cast", !1 === e ? void 0 : e)
                        );
                      }
                      default(e, t) {
                        return this._default("default", e, t);
                      }
                      description(e) {
                        return (
                          i(
                            e && "string" == typeof e,
                            "Description must be a non-empty string"
                          ),
                          this.$_setFlag("description", e)
                        );
                      }
                      empty(e) {
                        const t = this.clone();
                        return (
                          void 0 !== e &&
                            (e = t.$_compile(e, { override: !1 })),
                          t.$_setFlag("empty", e, { clone: !1 })
                        );
                      }
                      error(e) {
                        return (
                          i(e, "Missing error"),
                          i(
                            e instanceof Error || "function" == typeof e,
                            "Must provide a valid Error object or a function"
                          ),
                          this.$_setFlag("error", e)
                        );
                      }
                      example(e) {
                        let t =
                          arguments.length > 1 && void 0 !== arguments[1]
                            ? arguments[1]
                            : {};
                        return (
                          i(void 0 !== e, "Missing example"),
                          l.assertOptions(t, ["override"]),
                          this._inner("examples", e, {
                            single: !0,
                            override: t.override,
                          })
                        );
                      }
                      external(e, t) {
                        return (
                          "object" == typeof e &&
                            (i(!t, "Cannot combine options with description"),
                            (t = e.description),
                            (e = e.method)),
                          i(
                            "function" == typeof e,
                            "Method must be a function"
                          ),
                          i(
                            void 0 === t || (t && "string" == typeof t),
                            "Description must be a non-empty string"
                          ),
                          this._inner(
                            "externals",
                            { method: e, description: t },
                            { single: !0 }
                          )
                        );
                      }
                      failover(e, t) {
                        return this._default("failover", e, t);
                      }
                      forbidden() {
                        return this.presence("forbidden");
                      }
                      id(e) {
                        return e
                          ? (i(
                              "string" == typeof e,
                              "id must be a non-empty string"
                            ),
                            i(
                              /^[^\.]+$/.test(e),
                              "id cannot contain period character"
                            ),
                            this.$_setFlag("id", e))
                          : this.$_setFlag("id", void 0);
                      }
                      invalid() {
                        for (
                          var e = arguments.length, t = new Array(e), n = 0;
                          n < e;
                          n++
                        )
                          t[n] = arguments[n];
                        return this._values(t, "_invalids");
                      }
                      label(e) {
                        return (
                          i(
                            e && "string" == typeof e,
                            "Label name must be a non-empty string"
                          ),
                          this.$_setFlag("label", e)
                        );
                      }
                      meta(e) {
                        return (
                          i(void 0 !== e, "Meta cannot be undefined"),
                          this._inner("metas", e, { single: !0 })
                        );
                      }
                      note() {
                        for (
                          var e = arguments.length, t = new Array(e), n = 0;
                          n < e;
                          n++
                        )
                          t[n] = arguments[n];
                        i(t.length, "Missing notes");
                        for (const r of t)
                          i(
                            r && "string" == typeof r,
                            "Notes must be non-empty strings"
                          );
                        return this._inner("notes", t);
                      }
                      only() {
                        let e =
                          !(arguments.length > 0 && void 0 !== arguments[0]) ||
                          arguments[0];
                        return (
                          i("boolean" == typeof e, "Invalid mode:", e),
                          this.$_setFlag("only", e)
                        );
                      }
                      optional() {
                        return this.presence("optional");
                      }
                      prefs(e) {
                        i(e, "Missing preferences"),
                          i(void 0 === e.context, "Cannot override context"),
                          i(
                            void 0 === e.externals,
                            "Cannot override externals"
                          ),
                          i(void 0 === e.warnings, "Cannot override warnings"),
                          i(void 0 === e.debug, "Cannot override debug"),
                          l.checkPreferences(e);
                        const t = this.clone();
                        return (
                          (t._preferences = l.preferences(t._preferences, e)), t
                        );
                      }
                      presence(e) {
                        return (
                          i(
                            ["optional", "required", "forbidden"].includes(e),
                            "Unknown presence mode",
                            e
                          ),
                          this.$_setFlag("presence", e)
                        );
                      }
                      raw() {
                        let e =
                          !(arguments.length > 0 && void 0 !== arguments[0]) ||
                          arguments[0];
                        return this.$_setFlag("result", e ? "raw" : void 0);
                      }
                      result(e) {
                        return (
                          i(
                            ["raw", "strip"].includes(e),
                            "Unknown result mode",
                            e
                          ),
                          this.$_setFlag("result", e)
                        );
                      }
                      required() {
                        return this.presence("required");
                      }
                      strict(e) {
                        const t = this.clone(),
                          n = void 0 !== e && !e;
                        return (
                          (t._preferences = l.preferences(t._preferences, {
                            convert: n,
                          })),
                          t
                        );
                      }
                      strip() {
                        let e =
                          !(arguments.length > 0 && void 0 !== arguments[0]) ||
                          arguments[0];
                        return this.$_setFlag("result", e ? "strip" : void 0);
                      }
                      tag() {
                        for (
                          var e = arguments.length, t = new Array(e), n = 0;
                          n < e;
                          n++
                        )
                          t[n] = arguments[n];
                        i(t.length, "Missing tags");
                        for (const r of t)
                          i(
                            r && "string" == typeof r,
                            "Tags must be non-empty strings"
                          );
                        return this._inner("tags", t);
                      }
                      unit(e) {
                        return (
                          i(
                            e && "string" == typeof e,
                            "Unit name must be a non-empty string"
                          ),
                          this.$_setFlag("unit", e)
                        );
                      }
                      valid() {
                        for (
                          var e = arguments.length, t = new Array(e), n = 0;
                          n < e;
                          n++
                        )
                          t[n] = arguments[n];
                        l.verifyFlat(t, "valid");
                        const i = this.allow(...t);
                        return (
                          i.$_setFlag("only", !!i._valids, { clone: !1 }), i
                        );
                      }
                      when(e, t) {
                        const n = this.clone();
                        n.$_terms.whens || (n.$_terms.whens = []);
                        const r = c.when(n, e, t);
                        if (!["any", "link"].includes(n.type)) {
                          const e = r.is ? [r] : r.switch;
                          for (const t of e)
                            i(
                              !t.then ||
                                "any" === t.then.type ||
                                t.then.type === n.type,
                              "Cannot combine",
                              n.type,
                              "with",
                              t.then && t.then.type
                            ),
                              i(
                                !t.otherwise ||
                                  "any" === t.otherwise.type ||
                                  t.otherwise.type === n.type,
                                "Cannot combine",
                                n.type,
                                "with",
                                t.otherwise && t.otherwise.type
                              );
                        }
                        return n.$_terms.whens.push(r), n.$_mutateRebuild();
                      }
                      cache(e) {
                        i(
                          !this._inRuleset(),
                          "Cannot set caching inside a ruleset"
                        ),
                          i(!this._cache, "Cannot override schema cache"),
                          i(
                            void 0 === this._flags.artifact,
                            "Cannot cache a rule with an artifact"
                          );
                        const t = this.clone();
                        return (
                          (t._cache = e || s.provider.provision()),
                          (t.$_temp.ruleset = !1),
                          t
                        );
                      }
                      clone() {
                        const e = Object.create(Object.getPrototypeOf(this));
                        return this._assign(e);
                      }
                      concat(e) {
                        i(l.isSchema(e), "Invalid schema object"),
                          i(
                            "any" === this.type ||
                              "any" === e.type ||
                              e.type === this.type,
                            "Cannot merge type",
                            this.type,
                            "with another type:",
                            e.type
                          ),
                          i(
                            !this._inRuleset(),
                            "Cannot concatenate onto a schema with open ruleset"
                          ),
                          i(
                            !e._inRuleset(),
                            "Cannot concatenate a schema with open ruleset"
                          );
                        let t = this.clone();
                        if ("any" === this.type && "any" !== e.type) {
                          const n = e.clone();
                          for (const e of Object.keys(t))
                            "type" !== e && (n[e] = t[e]);
                          t = n;
                        }
                        t._ids.concat(e._ids),
                          t._refs.register(e, f.toSibling),
                          (t._preferences = t._preferences
                            ? l.preferences(t._preferences, e._preferences)
                            : e._preferences),
                          (t._valids = b.merge(
                            t._valids,
                            e._valids,
                            e._invalids
                          )),
                          (t._invalids = b.merge(
                            t._invalids,
                            e._invalids,
                            e._valids
                          ));
                        for (const n of e._singleRules.keys())
                          t._singleRules.has(n) &&
                            ((t._rules = t._rules.filter(
                              (e) => e.keep || e.name !== n
                            )),
                            t._singleRules.delete(n));
                        for (const n of e._rules)
                          e._definition.rules[n.method].multi ||
                            t._singleRules.set(n.name, n),
                            t._rules.push(n);
                        if (t._flags.empty && e._flags.empty) {
                          t._flags.empty = t._flags.empty.concat(
                            e._flags.empty
                          );
                          const n = Object.assign({}, e._flags);
                          delete n.empty, a(t._flags, n);
                        } else if (e._flags.empty) {
                          t._flags.empty = e._flags.empty;
                          const n = Object.assign({}, e._flags);
                          delete n.empty, a(t._flags, n);
                        } else a(t._flags, e._flags);
                        for (const n in e.$_terms) {
                          const i = e.$_terms[n];
                          i
                            ? t.$_terms[n]
                              ? (t.$_terms[n] = t.$_terms[n].concat(i))
                              : (t.$_terms[n] = i.slice())
                            : t.$_terms[n] || (t.$_terms[n] = i);
                        }
                        return (
                          this.$_root._tracer &&
                            this.$_root._tracer._combine(t, [this, e]),
                          t.$_mutateRebuild()
                        );
                      }
                      extend(e) {
                        return (
                          i(!e.base, "Cannot extend type with another base"),
                          u.type(this, e)
                        );
                      }
                      extract(e) {
                        return (
                          (e = Array.isArray(e) ? e : e.split(".")),
                          this._ids.reach(e)
                        );
                      }
                      fork(e, t) {
                        i(!this._inRuleset(), "Cannot fork inside a ruleset");
                        let n = this;
                        for (let i of [].concat(e))
                          (i = Array.isArray(i) ? i : i.split(".")),
                            (n = n._ids.fork(i, t, n));
                        return (n.$_temp.ruleset = !1), n;
                      }
                      rule(e) {
                        const t = this._definition;
                        l.assertOptions(e, Object.keys(t.modifiers)),
                          i(
                            !1 !== this.$_temp.ruleset,
                            "Cannot apply rules to empty ruleset or the last rule added does not support rule properties"
                          );
                        const n =
                          null === this.$_temp.ruleset
                            ? this._rules.length - 1
                            : this.$_temp.ruleset;
                        i(
                          n >= 0 && n < this._rules.length,
                          "Cannot apply rules to empty ruleset"
                        );
                        const o = this.clone();
                        for (let a = n; a < o._rules.length; ++a) {
                          const n = o._rules[a],
                            s = r(n);
                          for (const r in e)
                            t.modifiers[r](s, e[r]),
                              i(s.name === n.name, "Cannot change rule name");
                          (o._rules[a] = s),
                            o._singleRules.get(s.name) === n &&
                              o._singleRules.set(s.name, s);
                        }
                        return (o.$_temp.ruleset = !1), o.$_mutateRebuild();
                      }
                      get ruleset() {
                        i(
                          !this._inRuleset(),
                          "Cannot start a new ruleset without closing the previous one"
                        );
                        const e = this.clone();
                        return (e.$_temp.ruleset = e._rules.length), e;
                      }
                      get $() {
                        return this.ruleset;
                      }
                      tailor(e) {
                        (e = [].concat(e)),
                          i(
                            !this._inRuleset(),
                            "Cannot tailor inside a ruleset"
                          );
                        let t = this;
                        if (this.$_terms.alterations)
                          for (const { target: n, adjuster: r } of this.$_terms
                            .alterations)
                            e.includes(n) &&
                              ((t = r(t)),
                              i(
                                l.isSchema(t),
                                "Alteration adjuster for",
                                n,
                                "failed to return a schema object"
                              ));
                        return (
                          (t = t.$_modify({
                            each: (t) => t.tailor(e),
                            ref: !1,
                          })),
                          (t.$_temp.ruleset = !1),
                          t.$_mutateRebuild()
                        );
                      }
                      tracer() {
                        return g.location ? g.location(this) : this;
                      }
                      validate(e, t) {
                        return y.entry(e, this, t);
                      }
                      validateAsync(e, t) {
                        return y.entryAsync(e, this, t);
                      }
                      $_addRule(e) {
                        "string" == typeof e && (e = { name: e }),
                          i(e && "object" == typeof e, "Invalid options"),
                          i(
                            e.name && "string" == typeof e.name,
                            "Invalid rule name"
                          );
                        for (const a in e)
                          i("_" !== a[0], "Cannot set private rule properties");
                        const t = Object.assign({}, e);
                        (t._resolve = []), (t.method = t.method || t.name);
                        const n = this._definition.rules[t.method],
                          r = t.args;
                        i(n, "Unknown rule", t.method);
                        const o = this.clone();
                        if (r) {
                          i(
                            1 === Object.keys(r).length ||
                              Object.keys(r).length ===
                                this._definition.rules[t.name].args.length,
                            "Invalid rule definition for",
                            this.type,
                            t.name
                          );
                          for (const e in r) {
                            let a = r[e];
                            if (n.argsByName) {
                              const s = n.argsByName.get(e);
                              if (s.ref && l.isResolvable(a))
                                t._resolve.push(e), o.$_mutateRegister(a);
                              else if (
                                (s.normalize &&
                                  ((a = s.normalize(a)), (r[e] = a)),
                                s.assert)
                              ) {
                                const t = l.validateArg(a, e, s);
                                i(!t, t, "or reference");
                              }
                            }
                            void 0 !== a ? (r[e] = a) : delete r[e];
                          }
                        }
                        return (
                          n.multi ||
                            (o._ruleRemove(t.name, { clone: !1 }),
                            o._singleRules.set(t.name, t)),
                          !1 === o.$_temp.ruleset && (o.$_temp.ruleset = null),
                          n.priority ? o._rules.unshift(t) : o._rules.push(t),
                          o
                        );
                      }
                      $_compile(e, t) {
                        return c.schema(this.$_root, e, t);
                      }
                      $_createError(e, t, n, i, r) {
                        let o =
                          arguments.length > 5 && void 0 !== arguments[5]
                            ? arguments[5]
                            : {};
                        const a = !1 !== o.flags ? this._flags : {},
                          s = o.messages
                            ? m.merge(this._definition.messages, o.messages)
                            : this._definition.messages;
                        return new p.Report(e, t, n, a, s, i, r);
                      }
                      $_getFlag(e) {
                        return this._flags[e];
                      }
                      $_getRule(e) {
                        return this._singleRules.get(e);
                      }
                      $_mapLabels(e) {
                        return (
                          (e = Array.isArray(e) ? e : e.split(".")),
                          this._ids.labels(e)
                        );
                      }
                      $_match(e, t, n, i) {
                        ((n = Object.assign({}, n)).abortEarly = !0),
                          (n._externals = !1),
                          t.snapshot();
                        const r = !y.validate(e, this, t, n, i).errors;
                        return t.restore(), r;
                      }
                      $_modify(e) {
                        return (
                          l.assertOptions(e, ["each", "once", "ref", "schema"]),
                          h.schema(this, e) || this
                        );
                      }
                      $_mutateRebuild() {
                        return (
                          i(
                            !this._inRuleset(),
                            "Cannot add this rule inside a ruleset"
                          ),
                          this._refs.reset(),
                          this._ids.reset(),
                          this.$_modify({
                            each: (e, t) => {
                              let { source: n, name: i, path: r, key: o } = t;
                              const a =
                                this._definition[n][i] &&
                                this._definition[n][i].register;
                              !1 !== a &&
                                this.$_mutateRegister(e, { family: a, key: o });
                            },
                          }),
                          this._definition.rebuild &&
                            this._definition.rebuild(this),
                          (this.$_temp.ruleset = !1),
                          this
                        );
                      }
                      $_mutateRegister(e) {
                        let { family: t, key: n } =
                          arguments.length > 1 && void 0 !== arguments[1]
                            ? arguments[1]
                            : {};
                        this._refs.register(e, t),
                          this._ids.register(e, { key: n });
                      }
                      $_property(e) {
                        return this._definition.properties[e];
                      }
                      $_reach(e) {
                        return this._ids.reach(e);
                      }
                      $_rootReferences() {
                        return this._refs.roots();
                      }
                      $_setFlag(e, t) {
                        let n =
                          arguments.length > 2 && void 0 !== arguments[2]
                            ? arguments[2]
                            : {};
                        i(
                          "_" === e[0] || !this._inRuleset(),
                          "Cannot set flag inside a ruleset"
                        );
                        const r = this._definition.flags[e] || {};
                        if (
                          (o(t, r.default) && (t = void 0),
                          o(t, this._flags[e]))
                        )
                          return this;
                        const a = !1 !== n.clone ? this.clone() : this;
                        return (
                          void 0 !== t
                            ? ((a._flags[e] = t), a.$_mutateRegister(t))
                            : delete a._flags[e],
                          "_" !== e[0] && (a.$_temp.ruleset = !1),
                          a
                        );
                      }
                      $_parent(e) {
                        for (
                          var t = arguments.length,
                            n = new Array(t > 1 ? t - 1 : 0),
                            i = 1;
                          i < t;
                          i++
                        )
                          n[i - 1] = arguments[i];
                        return this[e][l.symbols.parent].call(this, ...n);
                      }
                      $_validate(e, t, n) {
                        return y.validate(e, this, t, n);
                      }
                      _assign(e) {
                        (e.type = this.type),
                          (e.$_root = this.$_root),
                          (e.$_temp = Object.assign({}, this.$_temp)),
                          (e.$_temp.whens = {}),
                          (e._ids = this._ids.clone()),
                          (e._preferences = this._preferences),
                          (e._valids = this._valids && this._valids.clone()),
                          (e._invalids =
                            this._invalids && this._invalids.clone()),
                          (e._rules = this._rules.slice()),
                          (e._singleRules = r(this._singleRules, {
                            shallow: !0,
                          })),
                          (e._refs = this._refs.clone()),
                          (e._flags = Object.assign({}, this._flags)),
                          (e._cache = null),
                          (e.$_terms = {});
                        for (const t in this.$_terms)
                          e.$_terms[t] = this.$_terms[t]
                            ? this.$_terms[t].slice()
                            : null;
                        e.$_super = {};
                        for (const t in this.$_super)
                          e.$_super[t] = this._super[t].bind(e);
                        return e;
                      }
                      _bare() {
                        const e = this.clone();
                        e._reset();
                        const t = e._definition.terms;
                        for (const n in t) {
                          const i = t[n];
                          e.$_terms[n] = i.init;
                        }
                        return e.$_mutateRebuild();
                      }
                      _default(e, t) {
                        let n =
                          arguments.length > 2 && void 0 !== arguments[2]
                            ? arguments[2]
                            : {};
                        return (
                          l.assertOptions(n, "literal"),
                          i(void 0 !== t, "Missing", e, "value"),
                          i(
                            "function" == typeof t || !n.literal,
                            "Only function value supports literal option"
                          ),
                          "function" == typeof t &&
                            n.literal &&
                            (t = { [l.symbols.literal]: !0, literal: t }),
                          this.$_setFlag(e, t)
                        );
                      }
                      _generate(e, t, n) {
                        if (!this.$_terms.whens) return { schema: this };
                        const i = [],
                          r = [];
                        for (let s = 0; s < this.$_terms.whens.length; ++s) {
                          const o = this.$_terms.whens[s];
                          if (o.concat) {
                            i.push(o.concat), r.push(`${s}.concat`);
                            continue;
                          }
                          const a = o.ref ? o.ref.resolve(e, t, n) : e,
                            l = o.is ? [o] : o.switch,
                            c = r.length;
                          for (let p = 0; p < l.length; ++p) {
                            const { is: c, then: u, otherwise: d } = l[p],
                              m = `${s}${o.switch ? "." + p : ""}`;
                            if (c.$_match(a, t.nest(c, `${m}.is`), n)) {
                              if (u) {
                                const o = t.localize(
                                    [...t.path, `${m}.then`],
                                    t.ancestors,
                                    t.schemas
                                  ),
                                  { schema: a, id: s } = u._generate(e, o, n);
                                i.push(a),
                                  r.push(`${m}.then${s ? `(${s})` : ""}`);
                                break;
                              }
                            } else if (d) {
                              const o = t.localize(
                                  [...t.path, `${m}.otherwise`],
                                  t.ancestors,
                                  t.schemas
                                ),
                                { schema: a, id: s } = d._generate(e, o, n);
                              i.push(a),
                                r.push(`${m}.otherwise${s ? `(${s})` : ""}`);
                              break;
                            }
                          }
                          if (o.break && r.length > c) break;
                        }
                        const o = r.join(", ");
                        if ((t.mainstay.tracer.debug(t, "rule", "when", o), !o))
                          return { schema: this };
                        if (!t.mainstay.tracer.active && this.$_temp.whens[o])
                          return { schema: this.$_temp.whens[o], id: o };
                        let a = this;
                        this._definition.generate &&
                          (a = this._definition.generate(this, e, t, n));
                        for (const s of i) a = a.concat(s);
                        return (
                          this.$_root._tracer &&
                            this.$_root._tracer._combine(a, [this, ...i]),
                          (this.$_temp.whens[o] = a),
                          { schema: a, id: o }
                        );
                      }
                      _inner(e, t) {
                        let n =
                          arguments.length > 2 && void 0 !== arguments[2]
                            ? arguments[2]
                            : {};
                        i(
                          !this._inRuleset(),
                          `Cannot set ${e} inside a ruleset`
                        );
                        const r = this.clone();
                        return (
                          (r.$_terms[e] && !n.override) || (r.$_terms[e] = []),
                          n.single
                            ? r.$_terms[e].push(t)
                            : r.$_terms[e].push(...t),
                          (r.$_temp.ruleset = !1),
                          r
                        );
                      }
                      _inRuleset() {
                        return (
                          null !== this.$_temp.ruleset &&
                          !1 !== this.$_temp.ruleset
                        );
                      }
                      _ruleRemove(e) {
                        let t =
                          arguments.length > 1 && void 0 !== arguments[1]
                            ? arguments[1]
                            : {};
                        if (!this._singleRules.has(e)) return this;
                        const n = !1 !== t.clone ? this.clone() : this;
                        n._singleRules.delete(e);
                        const i = [];
                        for (let r = 0; r < n._rules.length; ++r) {
                          const t = n._rules[r];
                          t.name !== e || t.keep
                            ? i.push(t)
                            : n._inRuleset() &&
                              r < n.$_temp.ruleset &&
                              --n.$_temp.ruleset;
                        }
                        return (n._rules = i), n;
                      }
                      _values(e, t) {
                        l.verifyFlat(e, t.slice(1, -1));
                        const n = this.clone(),
                          r = e[0] === l.symbols.override;
                        if (
                          (r && (e = e.slice(1)),
                          !n[t] && e.length
                            ? (n[t] = new b())
                            : r &&
                              ((n[t] = e.length ? new b() : null),
                              n.$_mutateRebuild()),
                          !n[t])
                        )
                          return n;
                        r && n[t].override();
                        for (const o of e) {
                          i(
                            void 0 !== o,
                            "Cannot call allow/valid/invalid with undefined"
                          ),
                            i(
                              o !== l.symbols.override,
                              "Override must be the first value"
                            );
                          const e = "_invalids" === t ? "_valids" : "_invalids";
                          n[e] &&
                            (n[e].remove(o),
                            n[e].length ||
                              (i(
                                "_valids" === t || !n._flags.only,
                                "Setting invalid value",
                                o,
                                "leaves schema rejecting all values due to previous valid rule"
                              ),
                              (n[e] = null))),
                            n[t].add(o, n._refs);
                        }
                        return n;
                      }
                    },
                  };
                (T.Base.prototype[l.symbols.any] = {
                  version: l.version,
                  compile: c.compile,
                  root: "$_root",
                }),
                  (T.Base.prototype.isImmutable = !0),
                  (T.Base.prototype.deny = T.Base.prototype.invalid),
                  (T.Base.prototype.disallow = T.Base.prototype.invalid),
                  (T.Base.prototype.equal = T.Base.prototype.valid),
                  (T.Base.prototype.exist = T.Base.prototype.required),
                  (T.Base.prototype.not = T.Base.prototype.invalid),
                  (T.Base.prototype.options = T.Base.prototype.prefs),
                  (T.Base.prototype.preferences = T.Base.prototype.prefs),
                  (e.exports = new T.Base());
              },
              8652: (e, t, n) => {
                "use strict";
                const i = n(375),
                  r = n(8571),
                  o = n(8160),
                  a = {
                    max: 1e3,
                    supported: new Set([
                      "undefined",
                      "boolean",
                      "number",
                      "string",
                    ]),
                  };
                (t.provider = { provision: (e) => new a.Cache(e) }),
                  (a.Cache = class {
                    constructor() {
                      let e =
                        arguments.length > 0 && void 0 !== arguments[0]
                          ? arguments[0]
                          : {};
                      o.assertOptions(e, ["max"]),
                        i(
                          void 0 === e.max ||
                            (e.max && e.max > 0 && isFinite(e.max)),
                          "Invalid max cache size"
                        ),
                        (this._max = e.max || a.max),
                        (this._map = new Map()),
                        (this._list = new a.List());
                    }
                    get length() {
                      return this._map.size;
                    }
                    set(e, t) {
                      if (null !== e && !a.supported.has(typeof e)) return;
                      let n = this._map.get(e);
                      if (n) return (n.value = t), void this._list.first(n);
                      (n = this._list.unshift({ key: e, value: t })),
                        this._map.set(e, n),
                        this._compact();
                    }
                    get(e) {
                      const t = this._map.get(e);
                      if (t) return this._list.first(t), r(t.value);
                    }
                    _compact() {
                      if (this._map.size > this._max) {
                        const e = this._list.pop();
                        this._map.delete(e.key);
                      }
                    }
                  }),
                  (a.List = class {
                    constructor() {
                      (this.tail = null), (this.head = null);
                    }
                    unshift(e) {
                      return (
                        (e.next = null),
                        (e.prev = this.head),
                        this.head && (this.head.next = e),
                        (this.head = e),
                        this.tail || (this.tail = e),
                        e
                      );
                    }
                    first(e) {
                      e !== this.head && (this._remove(e), this.unshift(e));
                    }
                    pop() {
                      return this._remove(this.tail);
                    }
                    _remove(e) {
                      const { next: t, prev: n } = e;
                      return (
                        (t.prev = n),
                        n && (n.next = t),
                        e === this.tail && (this.tail = t),
                        (e.prev = null),
                        (e.next = null),
                        e
                      );
                    }
                  });
              },
              8160: (e, t, n) => {
                "use strict";
                const i = n(375),
                  r = n(7916),
                  o = n(5934);
                let a, s;
                const l = {
                  isoDate:
                    /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/,
                };
                (t.version = o.version),
                  (t.defaults = {
                    abortEarly: !0,
                    allowUnknown: !1,
                    artifacts: !1,
                    cache: !0,
                    context: null,
                    convert: !0,
                    dateFormat: "iso",
                    errors: {
                      escapeHtml: !1,
                      label: "path",
                      language: null,
                      render: !0,
                      stack: !1,
                      wrap: { label: '"', array: "[]" },
                    },
                    externals: !0,
                    messages: {},
                    nonEnumerables: !1,
                    noDefaults: !1,
                    presence: "optional",
                    skipFunctions: !1,
                    stripUnknown: !1,
                    warnings: !1,
                  }),
                  (t.symbols = {
                    any: Symbol.for("@hapi/joi/schema"),
                    arraySingle: Symbol("arraySingle"),
                    deepDefault: Symbol("deepDefault"),
                    errors: Symbol("errors"),
                    literal: Symbol("literal"),
                    override: Symbol("override"),
                    parent: Symbol("parent"),
                    prefs: Symbol("prefs"),
                    ref: Symbol("ref"),
                    template: Symbol("template"),
                    values: Symbol("values"),
                  }),
                  (t.assertOptions = function (e, t) {
                    let n =
                      arguments.length > 2 && void 0 !== arguments[2]
                        ? arguments[2]
                        : "Options";
                    i(
                      e && "object" == typeof e && !Array.isArray(e),
                      "Options must be of type object"
                    );
                    const r = Object.keys(e).filter((e) => !t.includes(e));
                    i(0 === r.length, `${n} contain unknown keys: ${r}`);
                  }),
                  (t.checkPreferences = function (e) {
                    s = s || n(3378);
                    const t = s.preferences.validate(e);
                    if (t.error) throw new r([t.error.details[0].message]);
                  }),
                  (t.compare = function (e, t, n) {
                    switch (n) {
                      case "=":
                        return e === t;
                      case ">":
                        return e > t;
                      case "<":
                        return e < t;
                      case ">=":
                        return e >= t;
                      case "<=":
                        return e <= t;
                    }
                  }),
                  (t.default = function (e, t) {
                    return void 0 === e ? t : e;
                  }),
                  (t.isIsoDate = function (e) {
                    return l.isoDate.test(e);
                  }),
                  (t.isNumber = function (e) {
                    return "number" == typeof e && !isNaN(e);
                  }),
                  (t.isResolvable = function (e) {
                    return !!e && (e[t.symbols.ref] || e[t.symbols.template]);
                  }),
                  (t.isSchema = function (e) {
                    let n =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : {};
                    const r = e && e[t.symbols.any];
                    return (
                      !!r &&
                      (i(
                        n.legacy || r.version === t.version,
                        "Cannot mix different versions of joi schemas"
                      ),
                      !0)
                    );
                  }),
                  (t.isValues = function (e) {
                    return e[t.symbols.values];
                  }),
                  (t.limit = function (e) {
                    return Number.isSafeInteger(e) && e >= 0;
                  }),
                  (t.preferences = function (e, i) {
                    (a = a || n(6914)), (e = e || {}), (i = i || {});
                    const r = Object.assign({}, e, i);
                    return (
                      i.errors &&
                        e.errors &&
                        ((r.errors = Object.assign({}, e.errors, i.errors)),
                        (r.errors.wrap = Object.assign(
                          {},
                          e.errors.wrap,
                          i.errors.wrap
                        ))),
                      i.messages &&
                        (r.messages = a.compile(i.messages, e.messages)),
                      delete r[t.symbols.prefs],
                      r
                    );
                  }),
                  (t.tryWithPath = function (e, t) {
                    let n =
                      arguments.length > 2 && void 0 !== arguments[2]
                        ? arguments[2]
                        : {};
                    try {
                      return e();
                    } catch (e) {
                      throw (
                        (void 0 !== e.path
                          ? (e.path = t + "." + e.path)
                          : (e.path = t),
                        n.append && (e.message = `${e.message} (${e.path})`),
                        e)
                      );
                    }
                  }),
                  (t.validateArg = function (e, n, i) {
                    let { assert: r, message: o } = i;
                    if (t.isSchema(r)) {
                      const t = r.validate(e);
                      if (!t.error) return;
                      return t.error.message;
                    }
                    if (!r(e)) return n ? `${n} ${o}` : o;
                  }),
                  (t.verifyFlat = function (e, t) {
                    for (const n of e)
                      i(
                        !Array.isArray(n),
                        "Method no longer accepts array arguments:",
                        t
                      );
                  });
              },
              3292: (e, t, n) => {
                "use strict";
                const i = n(375),
                  r = n(8160),
                  o = n(6133),
                  a = {};
                (t.schema = function (e, t) {
                  let n =
                    arguments.length > 2 && void 0 !== arguments[2]
                      ? arguments[2]
                      : {};
                  r.assertOptions(n, ["appendPath", "override"]);
                  try {
                    return a.schema(e, t, n);
                  } catch (e) {
                    throw (
                      (n.appendPath &&
                        void 0 !== e.path &&
                        (e.message = `${e.message} (${e.path})`),
                      e)
                    );
                  }
                }),
                  (a.schema = function (e, t, n) {
                    i(void 0 !== t, "Invalid undefined schema"),
                      Array.isArray(t) &&
                        (i(t.length, "Invalid empty array schema"),
                        1 === t.length && (t = t[0]));
                    const o = function (t) {
                      for (
                        var i = arguments.length,
                          r = new Array(i > 1 ? i - 1 : 0),
                          o = 1;
                        o < i;
                        o++
                      )
                        r[o - 1] = arguments[o];
                      return !1 !== n.override
                        ? t.valid(e.override, ...r)
                        : t.valid(...r);
                    };
                    if (a.simple(t)) return o(e, t);
                    if ("function" == typeof t) return e.custom(t);
                    if (
                      (i(
                        "object" == typeof t,
                        "Invalid schema content:",
                        typeof t
                      ),
                      r.isResolvable(t))
                    )
                      return o(e, t);
                    if (r.isSchema(t)) return t;
                    if (Array.isArray(t)) {
                      for (const n of t)
                        if (!a.simple(n)) return e.alternatives().try(...t);
                      return o(e, ...t);
                    }
                    return t instanceof RegExp
                      ? e.string().regex(t)
                      : t instanceof Date
                      ? o(e.date(), t)
                      : (i(
                          Object.getPrototypeOf(t) ===
                            Object.getPrototypeOf({}),
                          "Schema can only contain plain objects"
                        ),
                        e.object().keys(t));
                  }),
                  (t.ref = function (e, t) {
                    return o.isRef(e) ? e : o.create(e, t);
                  }),
                  (t.compile = function (e, n) {
                    let o =
                      arguments.length > 2 && void 0 !== arguments[2]
                        ? arguments[2]
                        : {};
                    r.assertOptions(o, ["legacy"]);
                    const s = n && n[r.symbols.any];
                    if (s)
                      return (
                        i(
                          o.legacy || s.version === r.version,
                          "Cannot mix different versions of joi schemas:",
                          s.version,
                          r.version
                        ),
                        n
                      );
                    if ("object" != typeof n || !o.legacy)
                      return t.schema(e, n, { appendPath: !0 });
                    const l = a.walk(n);
                    return l
                      ? l.compile(l.root, n)
                      : t.schema(e, n, { appendPath: !0 });
                  }),
                  (a.walk = function (e) {
                    if ("object" != typeof e) return null;
                    if (Array.isArray(e)) {
                      for (const t of e) {
                        const e = a.walk(t);
                        if (e) return e;
                      }
                      return null;
                    }
                    const t = e[r.symbols.any];
                    if (t) return { root: e[t.root], compile: t.compile };
                    i(
                      Object.getPrototypeOf(e) === Object.getPrototypeOf({}),
                      "Schema can only contain plain objects"
                    );
                    for (const n in e) {
                      const t = a.walk(e[n]);
                      if (t) return t;
                    }
                    return null;
                  }),
                  (a.simple = function (e) {
                    return (
                      null === e ||
                      ["boolean", "string", "number"].includes(typeof e)
                    );
                  }),
                  (t.when = function (e, n, s) {
                    if (
                      (void 0 === s &&
                        (i(n && "object" == typeof n, "Missing options"),
                        (s = n),
                        (n = o.create("."))),
                      Array.isArray(s) && (s = { switch: s }),
                      r.assertOptions(s, [
                        "is",
                        "not",
                        "then",
                        "otherwise",
                        "switch",
                        "break",
                      ]),
                      r.isSchema(n))
                    )
                      return (
                        i(
                          void 0 === s.is,
                          '"is" can not be used with a schema condition'
                        ),
                        i(
                          void 0 === s.not,
                          '"not" can not be used with a schema condition'
                        ),
                        i(
                          void 0 === s.switch,
                          '"switch" can not be used with a schema condition'
                        ),
                        a.condition(e, {
                          is: n,
                          then: s.then,
                          otherwise: s.otherwise,
                          break: s.break,
                        })
                      );
                    if (
                      (i(
                        o.isRef(n) || "string" == typeof n,
                        "Invalid condition:",
                        n
                      ),
                      i(
                        void 0 === s.not || void 0 === s.is,
                        'Cannot combine "is" with "not"'
                      ),
                      void 0 === s.switch)
                    ) {
                      let l = s;
                      void 0 !== s.not &&
                        (l = {
                          is: s.not,
                          then: s.otherwise,
                          otherwise: s.then,
                          break: s.break,
                        });
                      let c =
                        void 0 !== l.is
                          ? e.$_compile(l.is)
                          : e.$_root.invalid(null, !1, 0, "").required();
                      return (
                        i(
                          void 0 !== l.then || void 0 !== l.otherwise,
                          'options must have at least one of "then", "otherwise", or "switch"'
                        ),
                        i(
                          void 0 === l.break ||
                            void 0 === l.then ||
                            void 0 === l.otherwise,
                          "Cannot specify then, otherwise, and break all together"
                        ),
                        void 0 === s.is ||
                          o.isRef(s.is) ||
                          r.isSchema(s.is) ||
                          (c = c.required()),
                        a.condition(e, {
                          ref: t.ref(n),
                          is: c,
                          then: l.then,
                          otherwise: l.otherwise,
                          break: l.break,
                        })
                      );
                    }
                    i(Array.isArray(s.switch), '"switch" must be an array'),
                      i(void 0 === s.is, 'Cannot combine "switch" with "is"'),
                      i(void 0 === s.not, 'Cannot combine "switch" with "not"'),
                      i(
                        void 0 === s.then,
                        'Cannot combine "switch" with "then"'
                      );
                    const l = { ref: t.ref(n), switch: [], break: s.break };
                    for (let t = 0; t < s.switch.length; ++t) {
                      const n = s.switch[t],
                        a = t === s.switch.length - 1;
                      r.assertOptions(
                        n,
                        a ? ["is", "then", "otherwise"] : ["is", "then"]
                      ),
                        i(void 0 !== n.is, 'Switch statement missing "is"'),
                        i(void 0 !== n.then, 'Switch statement missing "then"');
                      const c = {
                        is: e.$_compile(n.is),
                        then: e.$_compile(n.then),
                      };
                      if (
                        (o.isRef(n.is) ||
                          r.isSchema(n.is) ||
                          (c.is = c.is.required()),
                        a)
                      ) {
                        i(
                          void 0 === s.otherwise || void 0 === n.otherwise,
                          'Cannot specify "otherwise" inside and outside a "switch"'
                        );
                        const t =
                          void 0 !== s.otherwise ? s.otherwise : n.otherwise;
                        void 0 !== t &&
                          (i(
                            void 0 === l.break,
                            "Cannot specify both otherwise and break"
                          ),
                          (c.otherwise = e.$_compile(t)));
                      }
                      l.switch.push(c);
                    }
                    return l;
                  }),
                  (a.condition = function (e, t) {
                    for (const n of ["then", "otherwise"])
                      void 0 === t[n]
                        ? delete t[n]
                        : (t[n] = e.$_compile(t[n]));
                    return t;
                  });
              },
              6354: (e, t, n) => {
                "use strict";
                const i = n(5688),
                  r = n(8160),
                  o = n(3328);
                (t.Report = class {
                  constructor(e, n, i, r, o, a, s) {
                    if (
                      ((this.code = e),
                      (this.flags = r),
                      (this.messages = o),
                      (this.path = a.path),
                      (this.prefs = s),
                      (this.state = a),
                      (this.value = n),
                      (this.message = null),
                      (this.template = null),
                      (this.local = i || {}),
                      (this.local.label = t.label(
                        this.flags,
                        this.state,
                        this.prefs,
                        this.messages
                      )),
                      void 0 === this.value ||
                        this.local.hasOwnProperty("value") ||
                        (this.local.value = this.value),
                      this.path.length)
                    ) {
                      const e = this.path[this.path.length - 1];
                      "object" != typeof e && (this.local.key = e);
                    }
                  }
                  _setTemplate(e) {
                    if (
                      ((this.template = e),
                      !this.flags.label && 0 === this.path.length)
                    ) {
                      const e = this._template(this.template, "root");
                      e && (this.local.label = e);
                    }
                  }
                  toString() {
                    if (this.message) return this.message;
                    const e = this.code;
                    if (!this.prefs.errors.render) return this.code;
                    const t =
                      this._template(this.template) ||
                      this._template(this.prefs.messages) ||
                      this._template(this.messages);
                    return void 0 === t
                      ? `Error code "${e}" is not defined, your custom type is missing the correct messages definition`
                      : ((this.message = t.render(
                          this.value,
                          this.state,
                          this.prefs,
                          this.local,
                          {
                            errors: this.prefs.errors,
                            messages: [this.prefs.messages, this.messages],
                          }
                        )),
                        this.prefs.errors.label ||
                          (this.message = this.message
                            .replace(/^"" /, "")
                            .trim()),
                        this.message);
                  }
                  _template(e, n) {
                    return t.template(
                      this.value,
                      e,
                      n || this.code,
                      this.state,
                      this.prefs
                    );
                  }
                }),
                  (t.path = function (e) {
                    let t = "";
                    for (const n of e)
                      "object" != typeof n &&
                        ("string" == typeof n
                          ? (t && (t += "."), (t += n))
                          : (t += `[${n}]`));
                    return t;
                  }),
                  (t.template = function (e, t, n, i, a) {
                    if (!t) return;
                    if (o.isTemplate(t)) return "root" !== n ? t : null;
                    let s = a.errors.language;
                    if (
                      (r.isResolvable(s) && (s = s.resolve(e, i, a)), s && t[s])
                    ) {
                      if (void 0 !== t[s][n]) return t[s][n];
                      if (void 0 !== t[s]["*"]) return t[s]["*"];
                    }
                    return t[n] ? t[n] : t["*"];
                  }),
                  (t.label = function (e, n, i, r) {
                    if (e.label) return e.label;
                    if (!i.errors.label) return "";
                    let o = n.path;
                    return (
                      "key" === i.errors.label &&
                        n.path.length > 1 &&
                        (o = n.path.slice(-1)),
                      t.path(o) ||
                        t.template(null, i.messages, "root", n, i) ||
                        (r && t.template(null, r, "root", n, i)) ||
                        "value"
                    );
                  }),
                  (t.process = function (e, n, i) {
                    if (!e) return null;
                    const {
                      override: r,
                      message: o,
                      details: a,
                    } = t.details(e);
                    if (r) return r;
                    if (i.errors.stack) return new t.ValidationError(o, a, n);
                    const s = Error.stackTraceLimit;
                    Error.stackTraceLimit = 0;
                    const l = new t.ValidationError(o, a, n);
                    return (Error.stackTraceLimit = s), l;
                  }),
                  (t.details = function (e) {
                    let t =
                        arguments.length > 1 && void 0 !== arguments[1]
                          ? arguments[1]
                          : {},
                      n = [];
                    const i = [];
                    for (const r of e) {
                      if (r instanceof Error) {
                        if (!1 !== t.override) return { override: r };
                        const e = r.toString();
                        n.push(e),
                          i.push({
                            message: e,
                            type: "override",
                            context: { error: r },
                          });
                        continue;
                      }
                      const e = r.toString();
                      n.push(e),
                        i.push({
                          message: e,
                          path: r.path.filter((e) => "object" != typeof e),
                          type: r.code,
                          context: r.local,
                        });
                    }
                    return (
                      n.length > 1 && (n = [...new Set(n)]),
                      { message: n.join(". "), details: i }
                    );
                  }),
                  (t.ValidationError = class extends Error {
                    constructor(e, t, n) {
                      super(e), (this._original = n), (this.details = t);
                    }
                    static isError(e) {
                      return e instanceof t.ValidationError;
                    }
                  }),
                  (t.ValidationError.prototype.isJoi = !0),
                  (t.ValidationError.prototype.name = "ValidationError"),
                  (t.ValidationError.prototype.annotate = i.error);
              },
              8901: (e, t, n) => {
                "use strict";
                const i = n(375),
                  r = n(8571),
                  o = n(8160),
                  a = n(6914),
                  s = {};
                (t.type = function (e, t) {
                  const n = Object.getPrototypeOf(e),
                    l = r(n),
                    c = e._assign(Object.create(l)),
                    p = Object.assign({}, t);
                  delete p.base, (l._definition = p);
                  const u = n._definition || {};
                  (p.messages = a.merge(u.messages, p.messages)),
                    (p.properties = Object.assign(
                      {},
                      u.properties,
                      p.properties
                    )),
                    (c.type = p.type),
                    (p.flags = Object.assign({}, u.flags, p.flags));
                  const d = Object.assign({}, u.terms);
                  if (p.terms)
                    for (const r in p.terms) {
                      const e = p.terms[r];
                      i(
                        void 0 === c.$_terms[r],
                        "Invalid term override for",
                        p.type,
                        r
                      ),
                        (c.$_terms[r] = e.init),
                        (d[r] = e);
                    }
                  (p.terms = d),
                    p.args || (p.args = u.args),
                    (p.prepare = s.prepare(p.prepare, u.prepare)),
                    p.coerce &&
                      ("function" == typeof p.coerce &&
                        (p.coerce = { method: p.coerce }),
                      p.coerce.from &&
                        !Array.isArray(p.coerce.from) &&
                        (p.coerce = {
                          method: p.coerce.method,
                          from: [].concat(p.coerce.from),
                        })),
                    (p.coerce = s.coerce(p.coerce, u.coerce)),
                    (p.validate = s.validate(p.validate, u.validate));
                  const m = Object.assign({}, u.rules);
                  if (p.rules)
                    for (const r in p.rules) {
                      const e = p.rules[r];
                      i(
                        "object" == typeof e,
                        "Invalid rule definition for",
                        p.type,
                        r
                      );
                      let t = e.method;
                      if (
                        (void 0 === t &&
                          (t = function () {
                            return this.$_addRule(r);
                          }),
                        t &&
                          (i(!l[r], "Rule conflict in", p.type, r), (l[r] = t)),
                        i(!m[r], "Rule conflict in", p.type, r),
                        (m[r] = e),
                        e.alias)
                      ) {
                        const t = [].concat(e.alias);
                        for (const n of t) l[n] = e.method;
                      }
                      e.args &&
                        ((e.argsByName = new Map()),
                        (e.args = e.args.map(
                          (t) => (
                            "string" == typeof t && (t = { name: t }),
                            i(
                              !e.argsByName.has(t.name),
                              "Duplicated argument name",
                              t.name
                            ),
                            o.isSchema(t.assert) &&
                              (t.assert = t.assert.strict().label(t.name)),
                            e.argsByName.set(t.name, t),
                            t
                          )
                        )));
                    }
                  p.rules = m;
                  const h = Object.assign({}, u.modifiers);
                  if (p.modifiers)
                    for (const r in p.modifiers) {
                      i(!l[r], "Rule conflict in", p.type, r);
                      const e = p.modifiers[r];
                      i(
                        "function" == typeof e,
                        "Invalid modifier definition for",
                        p.type,
                        r
                      );
                      const t = function (e) {
                        return this.rule({ [r]: e });
                      };
                      (l[r] = t), (h[r] = e);
                    }
                  if (((p.modifiers = h), p.overrides)) {
                    (l._super = n), (c.$_super = {});
                    for (const e in p.overrides)
                      i(n[e], "Cannot override missing", e),
                        (p.overrides[e][o.symbols.parent] = n[e]),
                        (c.$_super[e] = n[e].bind(c));
                    Object.assign(l, p.overrides);
                  }
                  p.cast = Object.assign({}, u.cast, p.cast);
                  const f = Object.assign({}, u.manifest, p.manifest);
                  return (
                    (f.build = s.build(
                      p.manifest && p.manifest.build,
                      u.manifest && u.manifest.build
                    )),
                    (p.manifest = f),
                    (p.rebuild = s.rebuild(p.rebuild, u.rebuild)),
                    c
                  );
                }),
                  (s.build = function (e, t) {
                    return e && t
                      ? function (n, i) {
                          return t(e(n, i), i);
                        }
                      : e || t;
                  }),
                  (s.coerce = function (e, t) {
                    return e && t
                      ? {
                          from:
                            e.from && t.from
                              ? [...new Set([...e.from, ...t.from])]
                              : null,
                          method(n, i) {
                            let r;
                            if (
                              (!t.from || t.from.includes(typeof n)) &&
                              ((r = t.method(n, i)), r)
                            ) {
                              if (r.errors || void 0 === r.value) return r;
                              n = r.value;
                            }
                            if (!e.from || e.from.includes(typeof n)) {
                              const t = e.method(n, i);
                              if (t) return t;
                            }
                            return r;
                          },
                        }
                      : e || t;
                  }),
                  (s.prepare = function (e, t) {
                    return e && t
                      ? function (n, i) {
                          const r = e(n, i);
                          if (r) {
                            if (r.errors || void 0 === r.value) return r;
                            n = r.value;
                          }
                          return t(n, i) || r;
                        }
                      : e || t;
                  }),
                  (s.rebuild = function (e, t) {
                    return e && t
                      ? function (n) {
                          t(n), e(n);
                        }
                      : e || t;
                  }),
                  (s.validate = function (e, t) {
                    return e && t
                      ? function (n, i) {
                          const r = t(n, i);
                          if (r) {
                            if (
                              r.errors &&
                              (!Array.isArray(r.errors) || r.errors.length)
                            )
                              return r;
                            n = r.value;
                          }
                          return e(n, i) || r;
                        }
                      : e || t;
                  });
              },
              5107: (e, t, n) => {
                "use strict";
                const i = n(375),
                  r = n(8571),
                  o = n(8652),
                  a = n(8160),
                  s = n(3292),
                  l = n(6354),
                  c = n(8901),
                  p = n(9708),
                  u = n(6133),
                  d = n(3328),
                  m = n(1152);
                let h;
                const f = {
                  types: {
                    alternatives: n(4946),
                    any: n(8068),
                    array: n(546),
                    boolean: n(4937),
                    date: n(7500),
                    function: n(390),
                    link: n(8785),
                    number: n(3832),
                    object: n(8966),
                    string: n(7417),
                    symbol: n(8826),
                  },
                  aliases: {
                    alt: "alternatives",
                    bool: "boolean",
                    func: "function",
                  },
                  root: function () {
                    const e = { _types: new Set(Object.keys(f.types)) };
                    for (const t of e._types)
                      e[t] = function () {
                        for (
                          var e = arguments.length, n = new Array(e), r = 0;
                          r < e;
                          r++
                        )
                          n[r] = arguments[r];
                        return (
                          i(
                            !n.length ||
                              ["alternatives", "link", "object"].includes(t),
                            "The",
                            t,
                            "type does not allow arguments"
                          ),
                          f.generate(this, f.types[t], n)
                        );
                      };
                    for (const t of [
                      "allow",
                      "custom",
                      "disallow",
                      "equal",
                      "exist",
                      "forbidden",
                      "invalid",
                      "not",
                      "only",
                      "optional",
                      "options",
                      "prefs",
                      "preferences",
                      "required",
                      "strip",
                      "valid",
                      "when",
                    ])
                      e[t] = function () {
                        return this.any()[t](...arguments);
                      };
                    Object.assign(e, f.methods);
                    for (const t in f.aliases) {
                      const n = f.aliases[t];
                      e[t] = e[n];
                    }
                    return (e.x = e.expression), m.setup && m.setup(e), e;
                  },
                };
                (f.methods = {
                  ValidationError: l.ValidationError,
                  version: a.version,
                  cache: o.provider,
                  assert(e, t) {
                    for (
                      var n = arguments.length,
                        i = new Array(n > 2 ? n - 2 : 0),
                        r = 2;
                      r < n;
                      r++
                    )
                      i[r - 2] = arguments[r];
                    f.assert(e, t, !0, i);
                  },
                  attempt(e, t) {
                    for (
                      var n = arguments.length,
                        i = new Array(n > 2 ? n - 2 : 0),
                        r = 2;
                      r < n;
                      r++
                    )
                      i[r - 2] = arguments[r];
                    return f.assert(e, t, !1, i);
                  },
                  build(e) {
                    return (
                      i(
                        "function" == typeof p.build,
                        "Manifest functionality disabled"
                      ),
                      p.build(this, e)
                    );
                  },
                  checkPreferences(e) {
                    a.checkPreferences(e);
                  },
                  compile(e, t) {
                    return s.compile(this, e, t);
                  },
                  defaults(e) {
                    i("function" == typeof e, "modifier must be a function");
                    const t = Object.assign({}, this);
                    for (const n of t._types) {
                      const r = e(t[n]());
                      i(
                        a.isSchema(r),
                        "modifier must return a valid schema object"
                      ),
                        (t[n] = function () {
                          for (
                            var e = arguments.length, t = new Array(e), n = 0;
                            n < e;
                            n++
                          )
                            t[n] = arguments[n];
                          return f.generate(this, r, t);
                        });
                    }
                    return t;
                  },
                  expression() {
                    for (
                      var e = arguments.length, t = new Array(e), n = 0;
                      n < e;
                      n++
                    )
                      t[n] = arguments[n];
                    return new d(...t);
                  },
                  extend() {
                    for (
                      var e = arguments.length, t = new Array(e), r = 0;
                      r < e;
                      r++
                    )
                      t[r] = arguments[r];
                    a.verifyFlat(t, "extend"),
                      (h = h || n(3378)),
                      i(t.length, "You need to provide at least one extension"),
                      this.assert(t, h.extensions);
                    const o = Object.assign({}, this);
                    o._types = new Set(o._types);
                    for (let n of t) {
                      "function" == typeof n && (n = n(o)),
                        this.assert(n, h.extension);
                      const e = f.expandExtension(n, o);
                      for (const t of e) {
                        i(
                          void 0 === o[t.type] || o._types.has(t.type),
                          "Cannot override name",
                          t.type
                        );
                        const e = t.base || this.any(),
                          n = c.type(e, t);
                        o._types.add(t.type),
                          (o[t.type] = function () {
                            for (
                              var e = arguments.length, t = new Array(e), i = 0;
                              i < e;
                              i++
                            )
                              t[i] = arguments[i];
                            return f.generate(this, n, t);
                          });
                      }
                    }
                    return o;
                  },
                  isError: l.ValidationError.isError,
                  isExpression: d.isTemplate,
                  isRef: u.isRef,
                  isSchema: a.isSchema,
                  in() {
                    return u.in(...arguments);
                  },
                  override: a.symbols.override,
                  ref() {
                    return u.create(...arguments);
                  },
                  types() {
                    const e = {};
                    for (const t of this._types) e[t] = this[t]();
                    for (const t in f.aliases) e[t] = this[t]();
                    return e;
                  },
                }),
                  (f.assert = function (e, t, n, i) {
                    const o =
                        i[0] instanceof Error || "string" == typeof i[0]
                          ? i[0]
                          : null,
                      s = null !== o ? i[1] : i[0],
                      c = t.validate(
                        e,
                        a.preferences({ errors: { stack: !0 } }, s || {})
                      );
                    let p = c.error;
                    if (!p) return c.value;
                    if (o instanceof Error) throw o;
                    const u =
                      n && "function" == typeof p.annotate
                        ? p.annotate()
                        : p.message;
                    throw (
                      (p instanceof l.ValidationError == 0 && (p = r(p)),
                      (p.message = o ? `${o} ${u}` : u),
                      p)
                    );
                  }),
                  (f.generate = function (e, t, n) {
                    return (
                      i(e, "Must be invoked on a Joi instance."),
                      (t.$_root = e),
                      t._definition.args && n.length
                        ? t._definition.args(t, ...n)
                        : t
                    );
                  }),
                  (f.expandExtension = function (e, t) {
                    if ("string" == typeof e.type) return [e];
                    const n = [];
                    for (const i of t._types)
                      if (e.type.test(i)) {
                        const r = Object.assign({}, e);
                        (r.type = i), (r.base = t[i]()), n.push(r);
                      }
                    return n;
                  }),
                  (e.exports = f.root());
              },
              6914: (e, t, n) => {
                "use strict";
                const i = n(375),
                  r = n(8571),
                  o = n(3328);
                (t.compile = function (e, t) {
                  if ("string" == typeof e)
                    return i(!t, "Cannot set single message string"), new o(e);
                  if (o.isTemplate(e))
                    return i(!t, "Cannot set single message template"), e;
                  i(
                    "object" == typeof e && !Array.isArray(e),
                    "Invalid message options"
                  ),
                    (t = t ? r(t) : {});
                  for (let n in e) {
                    const r = e[n];
                    if ("root" === n || o.isTemplate(r)) {
                      t[n] = r;
                      continue;
                    }
                    if ("string" == typeof r) {
                      t[n] = new o(r);
                      continue;
                    }
                    i(
                      "object" == typeof r && !Array.isArray(r),
                      "Invalid message for",
                      n
                    );
                    const a = n;
                    for (n in ((t[a] = t[a] || {}), r)) {
                      const e = r[n];
                      "root" === n || o.isTemplate(e)
                        ? (t[a][n] = e)
                        : (i(
                            "string" == typeof e,
                            "Invalid message for",
                            n,
                            "in",
                            a
                          ),
                          (t[a][n] = new o(e)));
                    }
                  }
                  return t;
                }),
                  (t.decompile = function (e) {
                    const t = {};
                    for (let n in e) {
                      const i = e[n];
                      if ("root" === n) {
                        t.root = i;
                        continue;
                      }
                      if (o.isTemplate(i)) {
                        t[n] = i.describe({ compact: !0 });
                        continue;
                      }
                      const r = n;
                      for (n in ((t[r] = {}), i)) {
                        const e = i[n];
                        "root" !== n
                          ? (t[r][n] = e.describe({ compact: !0 }))
                          : (t[r].root = e);
                      }
                    }
                    return t;
                  }),
                  (t.merge = function (e, n) {
                    if (!e) return t.compile(n);
                    if (!n) return e;
                    if ("string" == typeof n) return new o(n);
                    if (o.isTemplate(n)) return n;
                    const a = r(e);
                    for (let t in n) {
                      const e = n[t];
                      if ("root" === t || o.isTemplate(e)) {
                        a[t] = e;
                        continue;
                      }
                      if ("string" == typeof e) {
                        a[t] = new o(e);
                        continue;
                      }
                      i(
                        "object" == typeof e && !Array.isArray(e),
                        "Invalid message for",
                        t
                      );
                      const r = t;
                      for (t in ((a[r] = a[r] || {}), e)) {
                        const n = e[t];
                        "root" === t || o.isTemplate(n)
                          ? (a[r][t] = n)
                          : (i(
                              "string" == typeof n,
                              "Invalid message for",
                              t,
                              "in",
                              r
                            ),
                            (a[r][t] = new o(n)));
                      }
                    }
                    return a;
                  });
              },
              2294: (e, t, n) => {
                "use strict";
                const i = n(375),
                  r = n(8160),
                  o = n(6133),
                  a = {};
                (t.Ids = a.Ids =
                  class {
                    constructor() {
                      (this._byId = new Map()),
                        (this._byKey = new Map()),
                        (this._schemaChain = !1);
                    }
                    clone() {
                      const e = new a.Ids();
                      return (
                        (e._byId = new Map(this._byId)),
                        (e._byKey = new Map(this._byKey)),
                        (e._schemaChain = this._schemaChain),
                        e
                      );
                    }
                    concat(e) {
                      e._schemaChain && (this._schemaChain = !0);
                      for (const [t, n] of e._byId.entries())
                        i(
                          !this._byKey.has(t),
                          "Schema id conflicts with existing key:",
                          t
                        ),
                          this._byId.set(t, n);
                      for (const [t, n] of e._byKey.entries())
                        i(
                          !this._byId.has(t),
                          "Schema key conflicts with existing id:",
                          t
                        ),
                          this._byKey.set(t, n);
                    }
                    fork(e, t, n) {
                      const o = this._collect(e);
                      o.push({ schema: n });
                      const s = o.shift();
                      let l = { id: s.id, schema: t(s.schema) };
                      i(
                        r.isSchema(l.schema),
                        "adjuster function failed to return a joi schema type"
                      );
                      for (const i of o)
                        l = {
                          id: i.id,
                          schema: a.fork(i.schema, l.id, l.schema),
                        };
                      return l.schema;
                    }
                    labels(e) {
                      let t =
                        arguments.length > 1 && void 0 !== arguments[1]
                          ? arguments[1]
                          : [];
                      const n = e[0],
                        i = this._get(n);
                      if (!i) return [...t, ...e].join(".");
                      const r = e.slice(1);
                      return (
                        (t = [...t, i.schema._flags.label || n]),
                        r.length ? i.schema._ids.labels(r, t) : t.join(".")
                      );
                    }
                    reach(e) {
                      let t =
                        arguments.length > 1 && void 0 !== arguments[1]
                          ? arguments[1]
                          : [];
                      const n = e[0],
                        r = this._get(n);
                      i(
                        r,
                        "Schema does not contain path",
                        [...t, ...e].join(".")
                      );
                      const o = e.slice(1);
                      return o.length
                        ? r.schema._ids.reach(o, [...t, n])
                        : r.schema;
                    }
                    register(e) {
                      let { key: t } =
                        arguments.length > 1 && void 0 !== arguments[1]
                          ? arguments[1]
                          : {};
                      if (!e || !r.isSchema(e)) return;
                      (e.$_property("schemaChain") || e._ids._schemaChain) &&
                        (this._schemaChain = !0);
                      const n = e._flags.id;
                      if (n) {
                        const t = this._byId.get(n);
                        i(
                          !t || t.schema === e,
                          "Cannot add different schemas with the same id:",
                          n
                        ),
                          i(
                            !this._byKey.has(n),
                            "Schema id conflicts with existing key:",
                            n
                          ),
                          this._byId.set(n, { schema: e, id: n });
                      }
                      t &&
                        (i(
                          !this._byKey.has(t),
                          "Schema already contains key:",
                          t
                        ),
                        i(
                          !this._byId.has(t),
                          "Schema key conflicts with existing id:",
                          t
                        ),
                        this._byKey.set(t, { schema: e, id: t }));
                    }
                    reset() {
                      (this._byId = new Map()),
                        (this._byKey = new Map()),
                        (this._schemaChain = !1);
                    }
                    _collect(e) {
                      let t =
                          arguments.length > 1 && void 0 !== arguments[1]
                            ? arguments[1]
                            : [],
                        n =
                          arguments.length > 2 && void 0 !== arguments[2]
                            ? arguments[2]
                            : [];
                      const r = e[0],
                        o = this._get(r);
                      i(
                        o,
                        "Schema does not contain path",
                        [...t, ...e].join(".")
                      ),
                        (n = [o, ...n]);
                      const a = e.slice(1);
                      return a.length
                        ? o.schema._ids._collect(a, [...t, r], n)
                        : n;
                    }
                    _get(e) {
                      return this._byId.get(e) || this._byKey.get(e);
                    }
                  }),
                  (a.fork = function (e, n, i) {
                    const r = t.schema(e, {
                      each: (e, t) => {
                        let { key: r } = t;
                        if (n === (e._flags.id || r)) return i;
                      },
                      ref: !1,
                    });
                    return r ? r.$_mutateRebuild() : e;
                  }),
                  (t.schema = function (e, t) {
                    let n;
                    for (const i in e._flags) {
                      if ("_" === i[0]) continue;
                      const r = a.scan(
                        e._flags[i],
                        { source: "flags", name: i },
                        t
                      );
                      void 0 !== r && ((n = n || e.clone()), (n._flags[i] = r));
                    }
                    for (let i = 0; i < e._rules.length; ++i) {
                      const r = e._rules[i],
                        o = a.scan(
                          r.args,
                          { source: "rules", name: r.name },
                          t
                        );
                      if (void 0 !== o) {
                        n = n || e.clone();
                        const t = Object.assign({}, r);
                        (t.args = o),
                          (n._rules[i] = t),
                          n._singleRules.get(r.name) === r &&
                            n._singleRules.set(r.name, t);
                      }
                    }
                    for (const i in e.$_terms) {
                      if ("_" === i[0]) continue;
                      const r = a.scan(
                        e.$_terms[i],
                        { source: "terms", name: i },
                        t
                      );
                      void 0 !== r &&
                        ((n = n || e.clone()), (n.$_terms[i] = r));
                    }
                    return n;
                  }),
                  (a.scan = function (e, t, n, i, s) {
                    const l = i || [];
                    if (null === e || "object" != typeof e) return;
                    let c;
                    if (Array.isArray(e)) {
                      for (let i = 0; i < e.length; ++i) {
                        const r =
                            "terms" === t.source &&
                            "keys" === t.name &&
                            e[i].key,
                          o = a.scan(e[i], t, n, [i, ...l], r);
                        void 0 !== o && ((c = c || e.slice()), (c[i] = o));
                      }
                      return c;
                    }
                    if (
                      (!1 !== n.schema && r.isSchema(e)) ||
                      (!1 !== n.ref && o.isRef(e))
                    ) {
                      const i = n.each(e, { ...t, path: l, key: s });
                      if (i === e) return;
                      return i;
                    }
                    for (const r in e) {
                      if ("_" === r[0]) continue;
                      const i = a.scan(e[r], t, n, [r, ...l], s);
                      void 0 !== i &&
                        ((c = c || Object.assign({}, e)), (c[r] = i));
                    }
                    return c;
                  });
              },
              6133: (e, t, n) => {
                "use strict";
                const i = n(375),
                  r = n(8571),
                  o = n(9621),
                  a = n(8160);
                let s;
                const l = {
                  symbol: Symbol("ref"),
                  defaults: {
                    adjust: null,
                    in: !1,
                    iterables: null,
                    map: null,
                    separator: ".",
                    type: "value",
                  },
                };
                (t.create = function (e) {
                  let t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : {};
                  i("string" == typeof e, "Invalid reference key:", e),
                    a.assertOptions(t, [
                      "adjust",
                      "ancestor",
                      "in",
                      "iterables",
                      "map",
                      "prefix",
                      "render",
                      "separator",
                    ]),
                    i(
                      !t.prefix || "object" == typeof t.prefix,
                      "options.prefix must be of type object"
                    );
                  const n = Object.assign({}, l.defaults, t);
                  delete n.prefix;
                  const r = n.separator,
                    o = l.context(e, r, t.prefix);
                  if (((n.type = o.type), (e = o.key), "value" === n.type))
                    if (
                      (o.root &&
                        (i(
                          !r || e[0] !== r,
                          "Cannot specify relative path with root prefix"
                        ),
                        (n.ancestor = "root"),
                        e || (e = null)),
                      r && r === e)
                    )
                      (e = null), (n.ancestor = 0);
                    else if (void 0 !== n.ancestor)
                      i(
                        !r || !e || e[0] !== r,
                        "Cannot combine prefix with ancestor option"
                      );
                    else {
                      const [t, i] = l.ancestor(e, r);
                      i && "" === (e = e.slice(i)) && (e = null),
                        (n.ancestor = t);
                    }
                  return (
                    (n.path = r ? (null === e ? [] : e.split(r)) : [e]),
                    new l.Ref(n)
                  );
                }),
                  (t.in = function (e) {
                    let n =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : {};
                    return t.create(e, { ...n, in: !0 });
                  }),
                  (t.isRef = function (e) {
                    return !!e && !!e[a.symbols.ref];
                  }),
                  (l.Ref = class {
                    constructor(e) {
                      i("object" == typeof e, "Invalid reference construction"),
                        a.assertOptions(e, [
                          "adjust",
                          "ancestor",
                          "in",
                          "iterables",
                          "map",
                          "path",
                          "render",
                          "separator",
                          "type",
                          "depth",
                          "key",
                          "root",
                          "display",
                        ]),
                        i(
                          [!1, void 0].includes(e.separator) ||
                            ("string" == typeof e.separator &&
                              1 === e.separator.length),
                          "Invalid separator"
                        ),
                        i(
                          !e.adjust || "function" == typeof e.adjust,
                          "options.adjust must be a function"
                        ),
                        i(
                          !e.map || Array.isArray(e.map),
                          "options.map must be an array"
                        ),
                        i(
                          !e.map || !e.adjust,
                          "Cannot set both map and adjust options"
                        ),
                        Object.assign(this, l.defaults, e),
                        i(
                          "value" === this.type || void 0 === this.ancestor,
                          "Non-value references cannot reference ancestors"
                        ),
                        Array.isArray(this.map) &&
                          (this.map = new Map(this.map)),
                        (this.depth = this.path.length),
                        (this.key = this.path.length
                          ? this.path.join(this.separator)
                          : null),
                        (this.root = this.path[0]),
                        this.updateDisplay();
                    }
                    resolve(e, t, n, r) {
                      let o =
                        arguments.length > 4 && void 0 !== arguments[4]
                          ? arguments[4]
                          : {};
                      return (
                        i(!this.in || o.in, "Invalid in() reference usage"),
                        "global" === this.type
                          ? this._resolve(n.context, t, o)
                          : "local" === this.type
                          ? this._resolve(r, t, o)
                          : this.ancestor
                          ? "root" === this.ancestor
                            ? this._resolve(
                                t.ancestors[t.ancestors.length - 1],
                                t,
                                o
                              )
                            : (i(
                                this.ancestor <= t.ancestors.length,
                                "Invalid reference exceeds the schema root:",
                                this.display
                              ),
                              this._resolve(
                                t.ancestors[this.ancestor - 1],
                                t,
                                o
                              ))
                          : this._resolve(e, t, o)
                      );
                    }
                    _resolve(e, t, n) {
                      let i;
                      if (
                        ("value" === this.type &&
                          t.mainstay.shadow &&
                          !1 !== n.shadow &&
                          (i = t.mainstay.shadow.get(this.absolute(t))),
                        void 0 === i &&
                          (i = o(e, this.path, {
                            iterables: this.iterables,
                            functions: !0,
                          })),
                        this.adjust && (i = this.adjust(i)),
                        this.map)
                      ) {
                        const e = this.map.get(i);
                        void 0 !== e && (i = e);
                      }
                      return (
                        t.mainstay && t.mainstay.tracer.resolve(t, this, i), i
                      );
                    }
                    toString() {
                      return this.display;
                    }
                    absolute(e) {
                      return [...e.path.slice(0, -this.ancestor), ...this.path];
                    }
                    clone() {
                      return new l.Ref(this);
                    }
                    describe() {
                      const e = { path: this.path };
                      "value" !== this.type && (e.type = this.type),
                        "." !== this.separator &&
                          (e.separator = this.separator),
                        "value" === this.type &&
                          1 !== this.ancestor &&
                          (e.ancestor = this.ancestor),
                        this.map && (e.map = [...this.map]);
                      for (const t of ["adjust", "iterables", "render"])
                        null !== this[t] &&
                          void 0 !== this[t] &&
                          (e[t] = this[t]);
                      return !1 !== this.in && (e.in = !0), { ref: e };
                    }
                    updateDisplay() {
                      const e = null !== this.key ? this.key : "";
                      if ("value" !== this.type)
                        return void (this.display = `ref:${this.type}:${e}`);
                      if (!this.separator)
                        return void (this.display = `ref:${e}`);
                      if (!this.ancestor)
                        return void (this.display = `ref:${this.separator}${e}`);
                      if ("root" === this.ancestor)
                        return void (this.display = `ref:root:${e}`);
                      if (1 === this.ancestor)
                        return void (this.display = `ref:${e || ".."}`);
                      const t = new Array(this.ancestor + 1)
                        .fill(this.separator)
                        .join("");
                      this.display = `ref:${t}${e || ""}`;
                    }
                  }),
                  (l.Ref.prototype[a.symbols.ref] = !0),
                  (t.build = function (e) {
                    return (
                      "value" === (e = Object.assign({}, l.defaults, e)).type &&
                        void 0 === e.ancestor &&
                        (e.ancestor = 1),
                      new l.Ref(e)
                    );
                  }),
                  (l.context = function (e, t) {
                    let n =
                      arguments.length > 2 && void 0 !== arguments[2]
                        ? arguments[2]
                        : {};
                    if (((e = e.trim()), n)) {
                      const i = void 0 === n.global ? "$" : n.global;
                      if (i !== t && e.startsWith(i))
                        return { key: e.slice(i.length), type: "global" };
                      const r = void 0 === n.local ? "#" : n.local;
                      if (r !== t && e.startsWith(r))
                        return { key: e.slice(r.length), type: "local" };
                      const o = void 0 === n.root ? "/" : n.root;
                      if (o !== t && e.startsWith(o))
                        return {
                          key: e.slice(o.length),
                          type: "value",
                          root: !0,
                        };
                    }
                    return { key: e, type: "value" };
                  }),
                  (l.ancestor = function (e, t) {
                    if (!t) return [1, 0];
                    if (e[0] !== t) return [1, 0];
                    if (e[1] !== t) return [0, 1];
                    let n = 2;
                    for (; e[n] === t; ) ++n;
                    return [n - 1, n];
                  }),
                  (t.toSibling = 0),
                  (t.toParent = 1),
                  (t.Manager = class {
                    constructor() {
                      this.refs = [];
                    }
                    register(e, i) {
                      if (e)
                        if (
                          ((i = void 0 === i ? t.toParent : i),
                          Array.isArray(e))
                        )
                          for (const t of e) this.register(t, i);
                        else if (a.isSchema(e))
                          for (const t of e._refs.refs)
                            t.ancestor - i >= 0 &&
                              this.refs.push({
                                ancestor: t.ancestor - i,
                                root: t.root,
                              });
                        else
                          t.isRef(e) &&
                            "value" === e.type &&
                            e.ancestor - i >= 0 &&
                            this.refs.push({
                              ancestor: e.ancestor - i,
                              root: e.root,
                            }),
                            (s = s || n(3328)),
                            s.isTemplate(e) && this.register(e.refs(), i);
                    }
                    get length() {
                      return this.refs.length;
                    }
                    clone() {
                      const e = new t.Manager();
                      return (e.refs = r(this.refs)), e;
                    }
                    reset() {
                      this.refs = [];
                    }
                    roots() {
                      return this.refs
                        .filter((e) => !e.ancestor)
                        .map((e) => e.root);
                    }
                  });
              },
              3378: (e, t, n) => {
                "use strict";
                const i = n(5107),
                  r = {};
                (r.wrap = i.string().min(1).max(2).allow(!1)),
                  (t.preferences = i
                    .object({
                      allowUnknown: i.boolean(),
                      abortEarly: i.boolean(),
                      artifacts: i.boolean(),
                      cache: i.boolean(),
                      context: i.object(),
                      convert: i.boolean(),
                      dateFormat: i.valid(
                        "date",
                        "iso",
                        "string",
                        "time",
                        "utc"
                      ),
                      debug: i.boolean(),
                      errors: {
                        escapeHtml: i.boolean(),
                        label: i.valid("path", "key", !1),
                        language: [i.string(), i.object().ref()],
                        render: i.boolean(),
                        stack: i.boolean(),
                        wrap: { label: r.wrap, array: r.wrap, string: r.wrap },
                      },
                      externals: i.boolean(),
                      messages: i.object(),
                      noDefaults: i.boolean(),
                      nonEnumerables: i.boolean(),
                      presence: i.valid("required", "optional", "forbidden"),
                      skipFunctions: i.boolean(),
                      stripUnknown: i
                        .object({ arrays: i.boolean(), objects: i.boolean() })
                        .or("arrays", "objects")
                        .allow(!0, !1),
                      warnings: i.boolean(),
                    })
                    .strict()),
                  (r.nameRx = /^[a-zA-Z0-9]\w*$/),
                  (r.rule = i.object({
                    alias: i
                      .array()
                      .items(i.string().pattern(r.nameRx))
                      .single(),
                    args: i
                      .array()
                      .items(
                        i.string(),
                        i.object({
                          name: i.string().pattern(r.nameRx).required(),
                          ref: i.boolean(),
                          assert: i
                            .alternatives([i.function(), i.object().schema()])
                            .conditional("ref", { is: !0, then: i.required() }),
                          normalize: i.function(),
                          message: i
                            .string()
                            .when("assert", {
                              is: i.function(),
                              then: i.required(),
                            }),
                        })
                      ),
                    convert: i.boolean(),
                    manifest: i.boolean(),
                    method: i.function().allow(!1),
                    multi: i.boolean(),
                    validate: i.function(),
                  })),
                  (t.extension = i
                    .object({
                      type: i
                        .alternatives([i.string(), i.object().regex()])
                        .required(),
                      args: i.function(),
                      cast: i
                        .object()
                        .pattern(
                          r.nameRx,
                          i.object({
                            from: i.function().maxArity(1).required(),
                            to: i.function().minArity(1).maxArity(2).required(),
                          })
                        ),
                      base: i
                        .object()
                        .schema()
                        .when("type", {
                          is: i.object().regex(),
                          then: i.forbidden(),
                        }),
                      coerce: [
                        i.function().maxArity(3),
                        i.object({
                          method: i.function().maxArity(3).required(),
                          from: i.array().items(i.string()).single(),
                        }),
                      ],
                      flags: i
                        .object()
                        .pattern(
                          r.nameRx,
                          i.object({ setter: i.string(), default: i.any() })
                        ),
                      manifest: { build: i.function().arity(2) },
                      messages: [i.object(), i.string()],
                      modifiers: i
                        .object()
                        .pattern(
                          r.nameRx,
                          i.function().minArity(1).maxArity(2)
                        ),
                      overrides: i.object().pattern(r.nameRx, i.function()),
                      prepare: i.function().maxArity(3),
                      rebuild: i.function().arity(1),
                      rules: i.object().pattern(r.nameRx, r.rule),
                      terms: i
                        .object()
                        .pattern(
                          r.nameRx,
                          i.object({
                            init: i.array().allow(null).required(),
                            manifest: i
                              .object()
                              .pattern(/.+/, [
                                i.valid("schema", "single"),
                                i.object({
                                  mapped: i
                                    .object({
                                      from: i.string().required(),
                                      to: i.string().required(),
                                    })
                                    .required(),
                                }),
                              ]),
                          })
                        ),
                      validate: i.function().maxArity(3),
                    })
                    .strict()),
                  (t.extensions = i
                    .array()
                    .items(i.object(), i.function().arity(1))
                    .strict()),
                  (r.desc = {
                    buffer: i.object({ buffer: i.string() }),
                    func: i.object({
                      function: i.function().required(),
                      options: { literal: !0 },
                    }),
                    override: i.object({ override: !0 }),
                    ref: i.object({
                      ref: i
                        .object({
                          type: i.valid("value", "global", "local"),
                          path: i.array().required(),
                          separator: i.string().length(1).allow(!1),
                          ancestor: i.number().min(0).integer().allow("root"),
                          map: i.array().items(i.array().length(2)).min(1),
                          adjust: i.function(),
                          iterables: i.boolean(),
                          in: i.boolean(),
                          render: i.boolean(),
                        })
                        .required(),
                    }),
                    regex: i.object({ regex: i.string().min(3) }),
                    special: i.object({ special: i.valid("deep").required() }),
                    template: i.object({
                      template: i.string().required(),
                      options: i.object(),
                    }),
                    value: i.object({
                      value: i.alternatives([i.object(), i.array()]).required(),
                    }),
                  }),
                  (r.desc.entity = i.alternatives([
                    i.array().items(i.link("...")),
                    i.boolean(),
                    i.function(),
                    i.number(),
                    i.string(),
                    r.desc.buffer,
                    r.desc.func,
                    r.desc.ref,
                    r.desc.regex,
                    r.desc.special,
                    r.desc.template,
                    r.desc.value,
                    i.link("/"),
                  ])),
                  (r.desc.values = i
                    .array()
                    .items(
                      null,
                      i.boolean(),
                      i.function(),
                      i.number().allow(1 / 0, -1 / 0),
                      i.string().allow(""),
                      i.symbol(),
                      r.desc.buffer,
                      r.desc.func,
                      r.desc.override,
                      r.desc.ref,
                      r.desc.regex,
                      r.desc.template,
                      r.desc.value
                    )),
                  (r.desc.messages = i
                    .object()
                    .pattern(/.+/, [
                      i.string(),
                      r.desc.template,
                      i.object().pattern(/.+/, [i.string(), r.desc.template]),
                    ])),
                  (t.description = i
                    .object({
                      type: i.string().required(),
                      flags: i
                        .object({
                          cast: i.string(),
                          default: i.any(),
                          description: i.string(),
                          empty: i.link("/"),
                          failover: r.desc.entity,
                          id: i.string(),
                          label: i.string(),
                          only: !0,
                          presence: ["optional", "required", "forbidden"],
                          result: ["raw", "strip"],
                          strip: i.boolean(),
                          unit: i.string(),
                        })
                        .unknown(),
                      preferences: {
                        allowUnknown: i.boolean(),
                        abortEarly: i.boolean(),
                        artifacts: i.boolean(),
                        cache: i.boolean(),
                        convert: i.boolean(),
                        dateFormat: ["date", "iso", "string", "time", "utc"],
                        errors: {
                          escapeHtml: i.boolean(),
                          label: ["path", "key"],
                          language: [i.string(), r.desc.ref],
                          wrap: { label: r.wrap, array: r.wrap },
                        },
                        externals: i.boolean(),
                        messages: r.desc.messages,
                        noDefaults: i.boolean(),
                        nonEnumerables: i.boolean(),
                        presence: ["required", "optional", "forbidden"],
                        skipFunctions: i.boolean(),
                        stripUnknown: i
                          .object({ arrays: i.boolean(), objects: i.boolean() })
                          .or("arrays", "objects")
                          .allow(!0, !1),
                        warnings: i.boolean(),
                      },
                      allow: r.desc.values,
                      invalid: r.desc.values,
                      rules: i
                        .array()
                        .min(1)
                        .items({
                          name: i.string().required(),
                          args: i.object().min(1),
                          keep: i.boolean(),
                          message: [i.string(), r.desc.messages],
                          warn: i.boolean(),
                        }),
                      keys: i.object().pattern(/.*/, i.link("/")),
                      link: r.desc.ref,
                    })
                    .pattern(/^[a-z]\w*$/, i.any()));
              },
              493: (e, t, n) => {
                "use strict";
                const i = n(8571),
                  r = n(9621),
                  o = n(8160),
                  a = { value: Symbol("value") };
                (e.exports = a.State =
                  class {
                    constructor(e, t, n) {
                      (this.path = e),
                        (this.ancestors = t),
                        (this.mainstay = n.mainstay),
                        (this.schemas = n.schemas),
                        (this.debug = null);
                    }
                    localize(e) {
                      let t =
                          arguments.length > 1 && void 0 !== arguments[1]
                            ? arguments[1]
                            : null,
                        n =
                          arguments.length > 2 && void 0 !== arguments[2]
                            ? arguments[2]
                            : null;
                      const i = new a.State(e, t, this);
                      return (
                        n &&
                          i.schemas &&
                          (i.schemas = [a.schemas(n), ...i.schemas]),
                        i
                      );
                    }
                    nest(e, t) {
                      const n = new a.State(this.path, this.ancestors, this);
                      return (
                        (n.schemas = n.schemas && [a.schemas(e), ...n.schemas]),
                        (n.debug = t),
                        n
                      );
                    }
                    shadow(e, t) {
                      (this.mainstay.shadow =
                        this.mainstay.shadow || new a.Shadow()),
                        this.mainstay.shadow.set(this.path, e, t);
                    }
                    snapshot() {
                      this.mainstay.shadow &&
                        (this._snapshot = i(
                          this.mainstay.shadow.node(this.path)
                        ));
                    }
                    restore() {
                      this.mainstay.shadow &&
                        (this.mainstay.shadow.override(
                          this.path,
                          this._snapshot
                        ),
                        (this._snapshot = void 0));
                    }
                  }),
                  (a.schemas = function (e) {
                    return o.isSchema(e) ? { schema: e } : e;
                  }),
                  (a.Shadow = class {
                    constructor() {
                      this._values = null;
                    }
                    set(e, t, n) {
                      if (!e.length) return;
                      if ("strip" === n && "number" == typeof e[e.length - 1])
                        return;
                      this._values = this._values || new Map();
                      let i = this._values;
                      for (let r = 0; r < e.length; ++r) {
                        const t = e[r];
                        let n = i.get(t);
                        n || ((n = new Map()), i.set(t, n)), (i = n);
                      }
                      i[a.value] = t;
                    }
                    get(e) {
                      const t = this.node(e);
                      if (t) return t[a.value];
                    }
                    node(e) {
                      if (this._values)
                        return r(this._values, e, { iterables: !0 });
                    }
                    override(e, t) {
                      if (!this._values) return;
                      const n = e.slice(0, -1),
                        i = e[e.length - 1],
                        o = r(this._values, n, { iterables: !0 });
                      t ? o.set(i, t) : o && o.delete(i);
                    }
                  });
              },
              3328: (e, t, n) => {
                "use strict";
                const i = n(375),
                  r = n(8571),
                  o = n(5277),
                  a = n(1447),
                  s = n(8160),
                  l = n(6354),
                  c = n(6133),
                  p = {
                    symbol: Symbol("template"),
                    opens: new Array(1e3).join("\0"),
                    closes: new Array(1e3).join("\x01"),
                    dateFormat: {
                      date: Date.prototype.toDateString,
                      iso: Date.prototype.toISOString,
                      string: Date.prototype.toString,
                      time: Date.prototype.toTimeString,
                      utc: Date.prototype.toUTCString,
                    },
                  };
                (e.exports = p.Template =
                  class {
                    constructor(e, t) {
                      i(
                        "string" == typeof e,
                        "Template source must be a string"
                      ),
                        i(
                          !e.includes("\0") && !e.includes("\x01"),
                          "Template source cannot contain reserved control characters"
                        ),
                        (this.source = e),
                        (this.rendered = e),
                        (this._template = null),
                        (this._settings = r(t)),
                        this._parse();
                    }
                    _parse() {
                      if (!this.source.includes("{")) return;
                      const e = p.encode(this.source),
                        t = p.split(e);
                      let n = !1;
                      const i = [],
                        r = t.shift();
                      r && i.push(r);
                      for (const o of t) {
                        const e = "{" !== o[0],
                          t = e ? "}" : "}}",
                          r = o.indexOf(t);
                        if (-1 === r || "{" === o[1]) {
                          i.push(`{${p.decode(o)}`);
                          continue;
                        }
                        let a = o.slice(e ? 0 : 1, r);
                        const s = ":" === a[0];
                        s && (a = a.slice(1));
                        const l = this._ref(p.decode(a), {
                          raw: e,
                          wrapped: s,
                        });
                        i.push(l), "string" != typeof l && (n = !0);
                        const c = o.slice(r + t.length);
                        c && i.push(p.decode(c));
                      }
                      n ? (this._template = i) : (this.rendered = i.join(""));
                    }
                    static date(e, t) {
                      return p.dateFormat[t.dateFormat].call(e);
                    }
                    describe() {
                      let e =
                        arguments.length > 0 && void 0 !== arguments[0]
                          ? arguments[0]
                          : {};
                      if (!this._settings && e.compact) return this.source;
                      const t = { template: this.source };
                      return this._settings && (t.options = this._settings), t;
                    }
                    static build(e) {
                      return new p.Template(e.template, e.options);
                    }
                    isDynamic() {
                      return !!this._template;
                    }
                    static isTemplate(e) {
                      return !!e && !!e[s.symbols.template];
                    }
                    refs() {
                      if (!this._template) return;
                      const e = [];
                      for (const t of this._template)
                        "string" != typeof t && e.push(...t.refs);
                      return e;
                    }
                    resolve(e, t, n, i) {
                      return this._template && 1 === this._template.length
                        ? this._part(this._template[0], e, t, n, i, {})
                        : this.render(e, t, n, i);
                    }
                    _part(e) {
                      for (
                        var t = arguments.length,
                          n = new Array(t > 1 ? t - 1 : 0),
                          i = 1;
                        i < t;
                        i++
                      )
                        n[i - 1] = arguments[i];
                      return e.ref
                        ? e.ref.resolve(...n)
                        : e.formula.evaluate(n);
                    }
                    render(e, t, n, i) {
                      let r =
                        arguments.length > 4 && void 0 !== arguments[4]
                          ? arguments[4]
                          : {};
                      if (!this.isDynamic()) return this.rendered;
                      const a = [];
                      for (const s of this._template)
                        if ("string" == typeof s) a.push(s);
                        else {
                          const l = this._part(s, e, t, n, i, r),
                            c = p.stringify(l, e, t, n, i, r);
                          if (void 0 !== c) {
                            const e =
                              s.raw || !1 === (r.errors && r.errors.escapeHtml)
                                ? c
                                : o(c);
                            a.push(p.wrap(e, s.wrapped && n.errors.wrap.label));
                          }
                        }
                      return a.join("");
                    }
                    _ref(e, t) {
                      let { raw: n, wrapped: i } = t;
                      const r = [],
                        o = (e) => {
                          const t = c.create(e, this._settings);
                          return r.push(t), (e) => t.resolve(...e);
                        };
                      try {
                        var s = new a.Parser(e, {
                          reference: o,
                          functions: p.functions,
                          constants: p.constants,
                        });
                      } catch (t) {
                        throw (
                          ((t.message = `Invalid template variable "${e}" fails due to: ${t.message}`),
                          t)
                        );
                      }
                      if (s.single) {
                        if ("reference" === s.single.type) {
                          const e = r[0];
                          return {
                            ref: e,
                            raw: n,
                            refs: r,
                            wrapped:
                              i || ("local" === e.type && "label" === e.key),
                          };
                        }
                        return p.stringify(s.single.value);
                      }
                      return { formula: s, raw: n, refs: r };
                    }
                    toString() {
                      return this.source;
                    }
                  }),
                  (p.Template.prototype[s.symbols.template] = !0),
                  (p.Template.prototype.isImmutable = !0),
                  (p.encode = function (e) {
                    return e
                      .replace(/\\(\{+)/g, (e, t) => p.opens.slice(0, t.length))
                      .replace(/\\(\}+)/g, (e, t) =>
                        p.closes.slice(0, t.length)
                      );
                  }),
                  (p.decode = function (e) {
                    return e.replace(/\u0000/g, "{").replace(/\u0001/g, "}");
                  }),
                  (p.split = function (e) {
                    const t = [];
                    let n = "";
                    for (let i = 0; i < e.length; ++i) {
                      const r = e[i];
                      if ("{" === r) {
                        let r = "";
                        for (; i + 1 < e.length && "{" === e[i + 1]; )
                          (r += "{"), ++i;
                        t.push(n), (n = r);
                      } else n += r;
                    }
                    return t.push(n), t;
                  }),
                  (p.wrap = function (e, t) {
                    return t
                      ? 1 === t.length
                        ? `${t}${e}${t}`
                        : `${t[0]}${e}${t[1]}`
                      : e;
                  }),
                  (p.stringify = function (e, t, n, i, r) {
                    let o =
                      arguments.length > 5 && void 0 !== arguments[5]
                        ? arguments[5]
                        : {};
                    const a = typeof e,
                      s = (i && i.errors && i.errors.wrap) || {};
                    let l = !1;
                    if (
                      (c.isRef(e) &&
                        e.render &&
                        ((l = e.in),
                        (e = e.resolve(t, n, i, r, { in: e.in, ...o }))),
                      null === e)
                    )
                      return "null";
                    if ("string" === a)
                      return p.wrap(e, o.arrayItems && s.string);
                    if ("number" === a || "function" === a || "symbol" === a)
                      return e.toString();
                    if ("object" !== a) return JSON.stringify(e);
                    if (e instanceof Date) return p.Template.date(e, i);
                    if (e instanceof Map) {
                      const t = [];
                      for (const [n, i] of e.entries())
                        t.push(`${n.toString()} -> ${i.toString()}`);
                      e = t;
                    }
                    if (!Array.isArray(e)) return e.toString();
                    const u = [];
                    for (const c of e)
                      u.push(
                        p.stringify(c, t, n, i, r, { arrayItems: !0, ...o })
                      );
                    return p.wrap(u.join(", "), !l && s.array);
                  }),
                  (p.constants = {
                    true: !0,
                    false: !1,
                    null: null,
                    second: 1e3,
                    minute: 6e4,
                    hour: 36e5,
                    day: 864e5,
                  }),
                  (p.functions = {
                    if: (e, t, n) => (e ? t : n),
                    length: (e) =>
                      "string" == typeof e
                        ? e.length
                        : e && "object" == typeof e
                        ? Array.isArray(e)
                          ? e.length
                          : Object.keys(e).length
                        : null,
                    msg(e) {
                      const [t, n, i, r, o] = this,
                        a = o.messages;
                      if (!a) return "";
                      const s =
                        l.template(t, a[0], e, n, i) ||
                        l.template(t, a[1], e, n, i);
                      return s ? s.render(t, n, i, r, o) : "";
                    },
                    number: (e) =>
                      "number" == typeof e
                        ? e
                        : "string" == typeof e
                        ? parseFloat(e)
                        : "boolean" == typeof e
                        ? e
                          ? 1
                          : 0
                        : e instanceof Date
                        ? e.getTime()
                        : null,
                  });
              },
              4946: (e, t, n) => {
                "use strict";
                const i = n(375),
                  r = n(1687),
                  o = n(8068),
                  a = n(8160),
                  s = n(3292),
                  l = n(6354),
                  c = n(6133),
                  p = {};
                (e.exports = o.extend({
                  type: "alternatives",
                  flags: { match: { default: "any" } },
                  terms: { matches: { init: [], register: c.toSibling } },
                  args(e) {
                    for (
                      var t = arguments.length,
                        n = new Array(t > 1 ? t - 1 : 0),
                        i = 1;
                      i < t;
                      i++
                    )
                      n[i - 1] = arguments[i];
                    return 1 === n.length && Array.isArray(n[0])
                      ? e.try(...n[0])
                      : e.try(...n);
                  },
                  validate(e, t) {
                    const { schema: n, error: i, state: o, prefs: a } = t;
                    if (n._flags.match) {
                      const t = [],
                        s = [];
                      for (let i = 0; i < n.$_terms.matches.length; ++i) {
                        const r = n.$_terms.matches[i],
                          l = o.nest(r.schema, `match.${i}`);
                        l.snapshot();
                        const c = r.schema.$_validate(e, l, a);
                        c.errors
                          ? (s.push(c.errors), l.restore())
                          : t.push(c.value);
                      }
                      if (0 === t.length)
                        return {
                          errors: i("alternatives.any", {
                            details: s.map((e) =>
                              l.details(e, { override: !1 })
                            ),
                          }),
                        };
                      if ("one" === n._flags.match)
                        return 1 === t.length
                          ? { value: t[0] }
                          : { errors: i("alternatives.one") };
                      if (t.length !== n.$_terms.matches.length)
                        return {
                          errors: i("alternatives.all", {
                            details: s.map((e) =>
                              l.details(e, { override: !1 })
                            ),
                          }),
                        };
                      const c = (e) =>
                        e.$_terms.matches.some(
                          (e) =>
                            "object" === e.schema.type ||
                            ("alternatives" === e.schema.type && c(e.schema))
                        );
                      return c(n)
                        ? {
                            value: t.reduce((e, t) =>
                              r(e, t, { mergeArrays: !1 })
                            ),
                          }
                        : { value: t[t.length - 1] };
                    }
                    const s = [];
                    for (let r = 0; r < n.$_terms.matches.length; ++r) {
                      const t = n.$_terms.matches[r];
                      if (t.schema) {
                        const n = o.nest(t.schema, `match.${r}`);
                        n.snapshot();
                        const i = t.schema.$_validate(e, n, a);
                        if (!i.errors) return i;
                        n.restore(),
                          s.push({ schema: t.schema, reports: i.errors });
                        continue;
                      }
                      const i = t.ref ? t.ref.resolve(e, o, a) : e,
                        l = t.is ? [t] : t.switch;
                      for (let n = 0; n < l.length; ++n) {
                        const s = l[n],
                          { is: c, then: p, otherwise: u } = s,
                          d = `match.${r}${t.switch ? "." + n : ""}`;
                        if (c.$_match(i, o.nest(c, `${d}.is`), a)) {
                          if (p)
                            return p.$_validate(e, o.nest(p, `${d}.then`), a);
                        } else if (u)
                          return u.$_validate(
                            e,
                            o.nest(u, `${d}.otherwise`),
                            a
                          );
                      }
                    }
                    return p.errors(s, t);
                  },
                  rules: {
                    conditional: {
                      method(e, t) {
                        i(!this._flags._endedSwitch, "Unreachable condition"),
                          i(
                            !this._flags.match,
                            "Cannot combine match mode",
                            this._flags.match,
                            "with conditional rule"
                          ),
                          i(
                            void 0 === t.break,
                            "Cannot use break option with alternatives conditional"
                          );
                        const n = this.clone(),
                          r = s.when(n, e, t),
                          o = r.is ? [r] : r.switch;
                        for (const i of o)
                          if (i.then && i.otherwise) {
                            n.$_setFlag("_endedSwitch", !0, { clone: !1 });
                            break;
                          }
                        return n.$_terms.matches.push(r), n.$_mutateRebuild();
                      },
                    },
                    match: {
                      method(e) {
                        if (
                          (i(
                            ["any", "one", "all"].includes(e),
                            "Invalid alternatives match mode",
                            e
                          ),
                          "any" !== e)
                        )
                          for (const t of this.$_terms.matches)
                            i(
                              t.schema,
                              "Cannot combine match mode",
                              e,
                              "with conditional rules"
                            );
                        return this.$_setFlag("match", e);
                      },
                    },
                    try: {
                      method() {
                        for (
                          var e = arguments.length, t = new Array(e), n = 0;
                          n < e;
                          n++
                        )
                          t[n] = arguments[n];
                        i(t.length, "Missing alternative schemas"),
                          a.verifyFlat(t, "try"),
                          i(!this._flags._endedSwitch, "Unreachable condition");
                        const r = this.clone();
                        for (const i of t)
                          r.$_terms.matches.push({ schema: r.$_compile(i) });
                        return r.$_mutateRebuild();
                      },
                    },
                  },
                  overrides: {
                    label(e) {
                      return this.$_parent("label", e).$_modify({
                        each: (t, n) =>
                          "is" !== n.path[0] ? t.label(e) : void 0,
                        ref: !1,
                      });
                    },
                  },
                  rebuild(e) {
                    e.$_modify({
                      each: (t) => {
                        a.isSchema(t) &&
                          "array" === t.type &&
                          e.$_setFlag("_arrayItems", !0, { clone: !1 });
                      },
                    });
                  },
                  manifest: {
                    build(e, t) {
                      if (t.matches)
                        for (const n of t.matches) {
                          const {
                            schema: t,
                            ref: i,
                            is: r,
                            not: o,
                            then: a,
                            otherwise: s,
                          } = n;
                          e = t
                            ? e.try(t)
                            : i
                            ? e.conditional(i, {
                                is: r,
                                then: a,
                                not: o,
                                otherwise: s,
                                switch: n.switch,
                              })
                            : e.conditional(r, { then: a, otherwise: s });
                        }
                      return e;
                    },
                  },
                  messages: {
                    "alternatives.all":
                      "{{#label}} does not match all of the required types",
                    "alternatives.any":
                      "{{#label}} does not match any of the allowed types",
                    "alternatives.match":
                      "{{#label}} does not match any of the allowed types",
                    "alternatives.one":
                      "{{#label}} matches more than one allowed type",
                    "alternatives.types":
                      "{{#label}} must be one of {{#types}}",
                  },
                })),
                  (p.errors = function (e, t) {
                    let { error: n, state: i } = t;
                    if (!e.length) return { errors: n("alternatives.any") };
                    if (1 === e.length) return { errors: e[0].reports };
                    const r = new Set(),
                      o = [];
                    for (const { reports: a, schema: s } of e) {
                      if (a.length > 1) return p.unmatched(e, n);
                      const t = a[0];
                      if (t instanceof l.Report == 0) return p.unmatched(e, n);
                      if (t.state.path.length !== i.path.length) {
                        o.push({ type: s.type, report: t });
                        continue;
                      }
                      if ("any.only" === t.code) {
                        for (const e of t.local.valids) r.add(e);
                        continue;
                      }
                      const [c, u] = t.code.split(".");
                      "base" === u
                        ? r.add(c)
                        : o.push({ type: s.type, report: t });
                    }
                    return o.length
                      ? 1 === o.length
                        ? { errors: o[0].report }
                        : p.unmatched(e, n)
                      : { errors: n("alternatives.types", { types: [...r] }) };
                  }),
                  (p.unmatched = function (e, t) {
                    const n = [];
                    for (const i of e) n.push(...i.reports);
                    return {
                      errors: t(
                        "alternatives.match",
                        l.details(n, { override: !1 })
                      ),
                    };
                  });
              },
              8068: (e, t, n) => {
                "use strict";
                const i = n(375),
                  r = n(7629),
                  o = n(8160),
                  a = n(6914);
                e.exports = r.extend({
                  type: "any",
                  flags: { only: { default: !1 } },
                  terms: {
                    alterations: { init: null },
                    examples: { init: null },
                    externals: { init: null },
                    metas: { init: [] },
                    notes: { init: [] },
                    shared: { init: null },
                    tags: { init: [] },
                    whens: { init: null },
                  },
                  rules: {
                    custom: {
                      method(e, t) {
                        return (
                          i(
                            "function" == typeof e,
                            "Method must be a function"
                          ),
                          i(
                            void 0 === t || (t && "string" == typeof t),
                            "Description must be a non-empty string"
                          ),
                          this.$_addRule({
                            name: "custom",
                            args: { method: e, description: t },
                          })
                        );
                      },
                      validate(e, t, n) {
                        let { method: i } = n;
                        try {
                          return i(e, t);
                        } catch (e) {
                          return t.error("any.custom", { error: e });
                        }
                      },
                      args: ["method", "description"],
                      multi: !0,
                    },
                    messages: {
                      method(e) {
                        return this.prefs({ messages: e });
                      },
                    },
                    shared: {
                      method(e) {
                        i(
                          o.isSchema(e) && e._flags.id,
                          "Schema must be a schema with an id"
                        );
                        const t = this.clone();
                        return (
                          (t.$_terms.shared = t.$_terms.shared || []),
                          t.$_terms.shared.push(e),
                          t.$_mutateRegister(e),
                          t
                        );
                      },
                    },
                    warning: {
                      method(e, t) {
                        return (
                          i(e && "string" == typeof e, "Invalid warning code"),
                          this.$_addRule({
                            name: "warning",
                            args: { code: e, local: t },
                            warn: !0,
                          })
                        );
                      },
                      validate(e, t, n) {
                        let { code: i, local: r } = n;
                        return t.error(i, r);
                      },
                      args: ["code", "local"],
                      multi: !0,
                    },
                  },
                  modifiers: {
                    keep(e) {
                      let t =
                        !(arguments.length > 1 && void 0 !== arguments[1]) ||
                        arguments[1];
                      e.keep = t;
                    },
                    message(e, t) {
                      e.message = a.compile(t);
                    },
                    warn(e) {
                      let t =
                        !(arguments.length > 1 && void 0 !== arguments[1]) ||
                        arguments[1];
                      e.warn = t;
                    },
                  },
                  manifest: {
                    build(e, t) {
                      for (const n in t) {
                        const i = t[n];
                        if (
                          [
                            "examples",
                            "externals",
                            "metas",
                            "notes",
                            "tags",
                          ].includes(n)
                        )
                          for (const t of i) e = e[n.slice(0, -1)](t);
                        else if ("alterations" !== n)
                          if ("whens" !== n) {
                            if ("shared" === n)
                              for (const t of i) e = e.shared(t);
                          } else
                            for (const t of i) {
                              const {
                                ref: n,
                                is: i,
                                not: r,
                                then: o,
                                otherwise: a,
                                concat: s,
                              } = t;
                              e = s
                                ? e.concat(s)
                                : n
                                ? e.when(n, {
                                    is: i,
                                    not: r,
                                    then: o,
                                    otherwise: a,
                                    switch: t.switch,
                                    break: t.break,
                                  })
                                : e.when(i, {
                                    then: o,
                                    otherwise: a,
                                    break: t.break,
                                  });
                            }
                        else {
                          const t = {};
                          for (const { target: e, adjuster: n } of i) t[e] = n;
                          e = e.alter(t);
                        }
                      }
                      return e;
                    },
                  },
                  messages: {
                    "any.custom":
                      "{{#label}} failed custom validation because {{#error.message}}",
                    "any.default":
                      "{{#label}} threw an error when running default method",
                    "any.failover":
                      "{{#label}} threw an error when running failover method",
                    "any.invalid": "{{#label}} contains an invalid value",
                    "any.only":
                      '{{#label}} must be {if(#valids.length == 1, "", "one of ")}{{#valids}}',
                    "any.ref":
                      "{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}",
                    "any.required": "{{#label}} is required",
                    "any.unknown": "{{#label}} is not allowed",
                  },
                });
              },
              546: (e, t, n) => {
                "use strict";
                const i = n(375),
                  r = n(9474),
                  o = n(9621),
                  a = n(8068),
                  s = n(8160),
                  l = n(3292),
                  c = {};
                (e.exports = a.extend({
                  type: "array",
                  flags: { single: { default: !1 }, sparse: { default: !1 } },
                  terms: {
                    items: { init: [], manifest: "schema" },
                    ordered: { init: [], manifest: "schema" },
                    _exclusions: { init: [] },
                    _inclusions: { init: [] },
                    _requireds: { init: [] },
                  },
                  coerce: {
                    from: "object",
                    method(e, t) {
                      let { schema: n, state: i, prefs: r } = t;
                      if (!Array.isArray(e)) return;
                      const o = n.$_getRule("sort");
                      return o ? c.sort(n, e, o.args.options, i, r) : void 0;
                    },
                  },
                  validate(e, t) {
                    let { schema: n, error: i } = t;
                    if (!Array.isArray(e)) {
                      if (n._flags.single) {
                        const t = [e];
                        return (t[s.symbols.arraySingle] = !0), { value: t };
                      }
                      return { errors: i("array.base") };
                    }
                    if (n.$_getRule("items") || n.$_terms.externals)
                      return { value: e.slice() };
                  },
                  rules: {
                    has: {
                      method(e) {
                        e = this.$_compile(e, { appendPath: !0 });
                        const t = this.$_addRule({
                          name: "has",
                          args: { schema: e },
                        });
                        return t.$_mutateRegister(e), t;
                      },
                      validate(e, t, n) {
                        let { state: i, prefs: r, error: o } = t,
                          { schema: a } = n;
                        const s = [e, ...i.ancestors];
                        for (let c = 0; c < e.length; ++c) {
                          const t = i.localize([...i.path, c], s, a);
                          if (a.$_match(e[c], t, r)) return e;
                        }
                        const l = a._flags.label;
                        return l
                          ? o("array.hasKnown", { patternLabel: l })
                          : o("array.hasUnknown", null);
                      },
                      multi: !0,
                    },
                    items: {
                      method() {
                        for (
                          var e = arguments.length, t = new Array(e), n = 0;
                          n < e;
                          n++
                        )
                          t[n] = arguments[n];
                        s.verifyFlat(t, "items");
                        const i = this.$_addRule("items");
                        for (let r = 0; r < t.length; ++r) {
                          const e = s.tryWithPath(
                            () => this.$_compile(t[r]),
                            r,
                            { append: !0 }
                          );
                          i.$_terms.items.push(e);
                        }
                        return i.$_mutateRebuild();
                      },
                      validate(e, t) {
                        let {
                          schema: n,
                          error: i,
                          state: r,
                          prefs: o,
                          errorsArray: a,
                        } = t;
                        const l = n.$_terms._requireds.slice(),
                          p = n.$_terms.ordered.slice(),
                          u = [...n.$_terms._inclusions, ...l],
                          d = !e[s.symbols.arraySingle];
                        delete e[s.symbols.arraySingle];
                        const m = a();
                        let h = e.length;
                        for (let s = 0; s < h; ++s) {
                          const t = e[s];
                          let a = !1,
                            f = !1;
                          const g = d ? s : new Number(s),
                            y = [...r.path, g];
                          if (!n._flags.sparse && void 0 === t) {
                            if (
                              (m.push(
                                i(
                                  "array.sparse",
                                  { key: g, path: y, pos: s, value: void 0 },
                                  r.localize(y)
                                )
                              ),
                              o.abortEarly)
                            )
                              return m;
                            p.shift();
                            continue;
                          }
                          const b = [e, ...r.ancestors];
                          for (const e of n.$_terms._exclusions)
                            if (
                              e.$_match(t, r.localize(y, b, e), o, {
                                presence: "ignore",
                              })
                            ) {
                              if (
                                (m.push(
                                  i(
                                    "array.excludes",
                                    { pos: s, value: t },
                                    r.localize(y)
                                  )
                                ),
                                o.abortEarly)
                              )
                                return m;
                              (a = !0), p.shift();
                              break;
                            }
                          if (a) continue;
                          if (n.$_terms.ordered.length) {
                            if (p.length) {
                              const a = p.shift(),
                                l = a.$_validate(t, r.localize(y, b, a), o);
                              if (l.errors) {
                                if ((m.push(...l.errors), o.abortEarly))
                                  return m;
                              } else if ("strip" === a._flags.result)
                                c.fastSplice(e, s), --s, --h;
                              else {
                                if (!n._flags.sparse && void 0 === l.value) {
                                  if (
                                    (m.push(
                                      i(
                                        "array.sparse",
                                        {
                                          key: g,
                                          path: y,
                                          pos: s,
                                          value: void 0,
                                        },
                                        r.localize(y)
                                      )
                                    ),
                                    o.abortEarly)
                                  )
                                    return m;
                                  continue;
                                }
                                e[s] = l.value;
                              }
                              continue;
                            }
                            if (!n.$_terms.items.length) {
                              if (
                                (m.push(
                                  i("array.orderedLength", {
                                    pos: s,
                                    limit: n.$_terms.ordered.length,
                                  })
                                ),
                                o.abortEarly)
                              )
                                return m;
                              break;
                            }
                          }
                          const T = [];
                          let _ = l.length;
                          for (let p = 0; p < _; ++p) {
                            const a = r.localize(y, b, l[p]);
                            a.snapshot();
                            const u = l[p].$_validate(t, a, o);
                            if (((T[p] = u), !u.errors)) {
                              if (
                                ((e[s] = u.value),
                                (f = !0),
                                c.fastSplice(l, p),
                                --p,
                                --_,
                                !n._flags.sparse &&
                                  void 0 === u.value &&
                                  (m.push(
                                    i(
                                      "array.sparse",
                                      {
                                        key: g,
                                        path: y,
                                        pos: s,
                                        value: void 0,
                                      },
                                      r.localize(y)
                                    )
                                  ),
                                  o.abortEarly))
                              )
                                return m;
                              break;
                            }
                            a.restore();
                          }
                          if (f) continue;
                          const S =
                            (o.stripUnknown && !!o.stripUnknown.arrays) || !1;
                          _ = u.length;
                          for (const p of u) {
                            let u;
                            const d = l.indexOf(p);
                            if (-1 !== d) u = T[d];
                            else {
                              const l = r.localize(y, b, p);
                              if (
                                (l.snapshot(),
                                (u = p.$_validate(t, l, o)),
                                !u.errors)
                              ) {
                                "strip" === p._flags.result
                                  ? (c.fastSplice(e, s), --s, --h)
                                  : n._flags.sparse || void 0 !== u.value
                                  ? (e[s] = u.value)
                                  : (m.push(
                                      i(
                                        "array.sparse",
                                        {
                                          key: g,
                                          path: y,
                                          pos: s,
                                          value: void 0,
                                        },
                                        r.localize(y)
                                      )
                                    ),
                                    (a = !0)),
                                  (f = !0);
                                break;
                              }
                              l.restore();
                            }
                            if (1 === _) {
                              if (S) {
                                c.fastSplice(e, s), --s, --h, (f = !0);
                                break;
                              }
                              if ((m.push(...u.errors), o.abortEarly)) return m;
                              a = !0;
                              break;
                            }
                          }
                          if (
                            !a &&
                            (n.$_terms._inclusions.length ||
                              n.$_terms._requireds.length) &&
                            !f
                          ) {
                            if (S) {
                              c.fastSplice(e, s), --s, --h;
                              continue;
                            }
                            if (
                              (m.push(
                                i(
                                  "array.includes",
                                  { pos: s, value: t },
                                  r.localize(y)
                                )
                              ),
                              o.abortEarly)
                            )
                              return m;
                          }
                        }
                        return (
                          l.length && c.fillMissedErrors(n, m, l, e, r, o),
                          p.length &&
                            (c.fillOrderedErrors(n, m, p, e, r, o),
                            m.length || c.fillDefault(p, e, r, o)),
                          m.length ? m : e
                        );
                      },
                      priority: !0,
                      manifest: !1,
                    },
                    length: {
                      method(e) {
                        return this.$_addRule({
                          name: "length",
                          args: { limit: e },
                          operator: "=",
                        });
                      },
                      validate(e, t, n, i) {
                        let { limit: r } = n,
                          { name: o, operator: a, args: l } = i;
                        return s.compare(e.length, r, a)
                          ? e
                          : t.error("array." + o, { limit: l.limit, value: e });
                      },
                      args: [
                        {
                          name: "limit",
                          ref: !0,
                          assert: s.limit,
                          message: "must be a positive integer",
                        },
                      ],
                    },
                    max: {
                      method(e) {
                        return this.$_addRule({
                          name: "max",
                          method: "length",
                          args: { limit: e },
                          operator: "<=",
                        });
                      },
                    },
                    min: {
                      method(e) {
                        return this.$_addRule({
                          name: "min",
                          method: "length",
                          args: { limit: e },
                          operator: ">=",
                        });
                      },
                    },
                    ordered: {
                      method() {
                        for (
                          var e = arguments.length, t = new Array(e), n = 0;
                          n < e;
                          n++
                        )
                          t[n] = arguments[n];
                        s.verifyFlat(t, "ordered");
                        const i = this.$_addRule("items");
                        for (let r = 0; r < t.length; ++r) {
                          const e = s.tryWithPath(
                            () => this.$_compile(t[r]),
                            r,
                            { append: !0 }
                          );
                          c.validateSingle(e, i),
                            i.$_mutateRegister(e),
                            i.$_terms.ordered.push(e);
                        }
                        return i.$_mutateRebuild();
                      },
                    },
                    single: {
                      method(e) {
                        const t = void 0 === e || !!e;
                        return (
                          i(
                            !t || !this._flags._arrayItems,
                            "Cannot specify single rule when array has array items"
                          ),
                          this.$_setFlag("single", t)
                        );
                      },
                    },
                    sort: {
                      method() {
                        let e =
                          arguments.length > 0 && void 0 !== arguments[0]
                            ? arguments[0]
                            : {};
                        s.assertOptions(e, ["by", "order"]);
                        const t = { order: e.order || "ascending" };
                        return (
                          e.by &&
                            ((t.by = l.ref(e.by, { ancestor: 0 })),
                            i(!t.by.ancestor, "Cannot sort by ancestor")),
                          this.$_addRule({ name: "sort", args: { options: t } })
                        );
                      },
                      validate(e, t, n) {
                        let { error: i, state: r, prefs: o, schema: a } = t,
                          { options: s } = n;
                        const { value: l, errors: p } = c.sort(a, e, s, r, o);
                        if (p) return p;
                        for (let c = 0; c < e.length; ++c)
                          if (e[c] !== l[c])
                            return i("array.sort", {
                              order: s.order,
                              by: s.by ? s.by.key : "value",
                            });
                        return e;
                      },
                      convert: !0,
                    },
                    sparse: {
                      method(e) {
                        const t = void 0 === e || !!e;
                        return this._flags.sparse === t
                          ? this
                          : (t
                              ? this.clone()
                              : this.$_addRule("items")
                            ).$_setFlag("sparse", t, { clone: !1 });
                      },
                    },
                    unique: {
                      method(e) {
                        let t =
                          arguments.length > 1 && void 0 !== arguments[1]
                            ? arguments[1]
                            : {};
                        i(
                          !e || "function" == typeof e || "string" == typeof e,
                          "comparator must be a function or a string"
                        ),
                          s.assertOptions(t, ["ignoreUndefined", "separator"]);
                        const n = {
                          name: "unique",
                          args: { options: t, comparator: e },
                        };
                        if (e)
                          if ("string" == typeof e) {
                            const i = s.default(t.separator, ".");
                            n.path = i ? e.split(i) : [e];
                          } else n.comparator = e;
                        return this.$_addRule(n);
                      },
                      validate(e, t, n, a) {
                        let { state: s, error: l, schema: c } = t,
                          { comparator: p, options: u } = n,
                          { comparator: d, path: m } = a;
                        const h = {
                            string: Object.create(null),
                            number: Object.create(null),
                            undefined: Object.create(null),
                            boolean: Object.create(null),
                            object: new Map(),
                            function: new Map(),
                            custom: new Map(),
                          },
                          f = d || r,
                          g = u.ignoreUndefined;
                        for (let r = 0; r < e.length; ++r) {
                          const t = m ? o(e[r], m) : e[r],
                            n = d ? h.custom : h[typeof t];
                          if (
                            (i(
                              n,
                              "Failed to find unique map container for type",
                              typeof t
                            ),
                            n instanceof Map)
                          ) {
                            const i = n.entries();
                            let o;
                            for (; !(o = i.next()).done; )
                              if (f(o.value[0], t)) {
                                const t = s.localize(
                                    [...s.path, r],
                                    [e, ...s.ancestors]
                                  ),
                                  n = {
                                    pos: r,
                                    value: e[r],
                                    dupePos: o.value[1],
                                    dupeValue: e[o.value[1]],
                                  };
                                return (
                                  m && (n.path = p), l("array.unique", n, t)
                                );
                              }
                            n.set(t, r);
                          } else {
                            if ((!g || void 0 !== t) && void 0 !== n[t]) {
                              const i = {
                                pos: r,
                                value: e[r],
                                dupePos: n[t],
                                dupeValue: e[n[t]],
                              };
                              return (
                                m && (i.path = p),
                                l(
                                  "array.unique",
                                  i,
                                  s.localize(
                                    [...s.path, r],
                                    [e, ...s.ancestors]
                                  )
                                )
                              );
                            }
                            n[t] = r;
                          }
                        }
                        return e;
                      },
                      args: ["comparator", "options"],
                      multi: !0,
                    },
                  },
                  cast: {
                    set: { from: Array.isArray, to: (e, t) => new Set(e) },
                  },
                  rebuild(e) {
                    (e.$_terms._inclusions = []),
                      (e.$_terms._exclusions = []),
                      (e.$_terms._requireds = []);
                    for (const t of e.$_terms.items)
                      c.validateSingle(t, e),
                        "required" === t._flags.presence
                          ? e.$_terms._requireds.push(t)
                          : "forbidden" === t._flags.presence
                          ? e.$_terms._exclusions.push(t)
                          : e.$_terms._inclusions.push(t);
                    for (const t of e.$_terms.ordered) c.validateSingle(t, e);
                  },
                  manifest: {
                    build: (e, t) => (
                      t.items && (e = e.items(...t.items)),
                      t.ordered && (e = e.ordered(...t.ordered)),
                      e
                    ),
                  },
                  messages: {
                    "array.base": "{{#label}} must be an array",
                    "array.excludes": "{{#label}} contains an excluded value",
                    "array.hasKnown":
                      "{{#label}} does not contain at least one required match for type {:#patternLabel}",
                    "array.hasUnknown":
                      "{{#label}} does not contain at least one required match",
                    "array.includes":
                      "{{#label}} does not match any of the allowed types",
                    "array.includesRequiredBoth":
                      "{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)",
                    "array.includesRequiredKnowns":
                      "{{#label}} does not contain {{#knownMisses}}",
                    "array.includesRequiredUnknowns":
                      "{{#label}} does not contain {{#unknownMisses}} required value(s)",
                    "array.length": "{{#label}} must contain {{#limit}} items",
                    "array.max":
                      "{{#label}} must contain less than or equal to {{#limit}} items",
                    "array.min":
                      "{{#label}} must contain at least {{#limit}} items",
                    "array.orderedLength":
                      "{{#label}} must contain at most {{#limit}} items",
                    "array.sort":
                      "{{#label}} must be sorted in {#order} order by {{#by}}",
                    "array.sort.mismatching":
                      "{{#label}} cannot be sorted due to mismatching types",
                    "array.sort.unsupported":
                      "{{#label}} cannot be sorted due to unsupported type {#type}",
                    "array.sparse":
                      "{{#label}} must not be a sparse array item",
                    "array.unique": "{{#label}} contains a duplicate value",
                  },
                })),
                  (c.fillMissedErrors = function (e, t, n, i, r, o) {
                    const a = [];
                    let s = 0;
                    for (const l of n) {
                      const e = l._flags.label;
                      e ? a.push(e) : ++s;
                    }
                    a.length
                      ? s
                        ? t.push(
                            e.$_createError(
                              "array.includesRequiredBoth",
                              i,
                              { knownMisses: a, unknownMisses: s },
                              r,
                              o
                            )
                          )
                        : t.push(
                            e.$_createError(
                              "array.includesRequiredKnowns",
                              i,
                              { knownMisses: a },
                              r,
                              o
                            )
                          )
                      : t.push(
                          e.$_createError(
                            "array.includesRequiredUnknowns",
                            i,
                            { unknownMisses: s },
                            r,
                            o
                          )
                        );
                  }),
                  (c.fillOrderedErrors = function (e, t, n, i, r, o) {
                    const a = [];
                    for (const s of n)
                      "required" === s._flags.presence && a.push(s);
                    a.length && c.fillMissedErrors(e, t, a, i, r, o);
                  }),
                  (c.fillDefault = function (e, t, n, i) {
                    const r = [];
                    let o = !0;
                    for (let a = e.length - 1; a >= 0; --a) {
                      const s = e[a],
                        l = [t, ...n.ancestors],
                        c = s.$_validate(
                          void 0,
                          n.localize(n.path, l, s),
                          i
                        ).value;
                      if (o) {
                        if (void 0 === c) continue;
                        o = !1;
                      }
                      r.unshift(c);
                    }
                    r.length && t.push(...r);
                  }),
                  (c.fastSplice = function (e, t) {
                    let n = t;
                    for (; n < e.length; ) e[n++] = e[n];
                    --e.length;
                  }),
                  (c.validateSingle = function (e, t) {
                    ("array" === e.type || e._flags._arrayItems) &&
                      (i(
                        !t._flags.single,
                        "Cannot specify array item with single rule enabled"
                      ),
                      t.$_setFlag("_arrayItems", !0, { clone: !1 }));
                  }),
                  (c.sort = function (e, t, n, i, r) {
                    const o = "ascending" === n.order ? 1 : -1,
                      a = -1 * o,
                      s = o,
                      l = (l, p) => {
                        let u = c.compare(l, p, a, s);
                        if (null !== u) return u;
                        if (
                          (n.by &&
                            ((l = n.by.resolve(l, i, r)),
                            (p = n.by.resolve(p, i, r))),
                          (u = c.compare(l, p, a, s)),
                          null !== u)
                        )
                          return u;
                        const d = typeof l;
                        if (d !== typeof p)
                          throw e.$_createError(
                            "array.sort.mismatching",
                            t,
                            null,
                            i,
                            r
                          );
                        if ("number" !== d && "string" !== d)
                          throw e.$_createError(
                            "array.sort.unsupported",
                            t,
                            { type: d },
                            i,
                            r
                          );
                        return "number" === d ? (l - p) * o : l < p ? a : s;
                      };
                    try {
                      return { value: t.slice().sort(l) };
                    } catch (e) {
                      return { errors: e };
                    }
                  }),
                  (c.compare = function (e, t, n, i) {
                    return e === t
                      ? 0
                      : void 0 === e
                      ? 1
                      : void 0 === t
                      ? -1
                      : null === e
                      ? i
                      : null === t
                      ? n
                      : null;
                  });
              },
              4937: (e, t, n) => {
                "use strict";
                const i = n(375),
                  r = n(8068),
                  o = n(8160),
                  a = n(2036),
                  s = {
                    isBool: function (e) {
                      return "boolean" == typeof e;
                    },
                  };
                e.exports = r.extend({
                  type: "boolean",
                  flags: { sensitive: { default: !1 } },
                  terms: {
                    falsy: { init: null, manifest: "values" },
                    truthy: { init: null, manifest: "values" },
                  },
                  coerce(e, t) {
                    let { schema: n } = t;
                    if ("boolean" != typeof e) {
                      if ("string" == typeof e) {
                        const t = n._flags.sensitive ? e : e.toLowerCase();
                        e = "true" === t || ("false" !== t && e);
                      }
                      return (
                        "boolean" != typeof e &&
                          (e =
                            (n.$_terms.truthy &&
                              n.$_terms.truthy.has(
                                e,
                                null,
                                null,
                                !n._flags.sensitive
                              )) ||
                            ((!n.$_terms.falsy ||
                              !n.$_terms.falsy.has(
                                e,
                                null,
                                null,
                                !n._flags.sensitive
                              )) &&
                              e)),
                        { value: e }
                      );
                    }
                  },
                  validate(e, t) {
                    let { error: n } = t;
                    if ("boolean" != typeof e)
                      return { value: e, errors: n("boolean.base") };
                  },
                  rules: {
                    truthy: {
                      method() {
                        for (
                          var e = arguments.length, t = new Array(e), n = 0;
                          n < e;
                          n++
                        )
                          t[n] = arguments[n];
                        o.verifyFlat(t, "truthy");
                        const r = this.clone();
                        r.$_terms.truthy = r.$_terms.truthy || new a();
                        for (let o = 0; o < t.length; ++o) {
                          const e = t[o];
                          i(void 0 !== e, "Cannot call truthy with undefined"),
                            r.$_terms.truthy.add(e);
                        }
                        return r;
                      },
                    },
                    falsy: {
                      method() {
                        for (
                          var e = arguments.length, t = new Array(e), n = 0;
                          n < e;
                          n++
                        )
                          t[n] = arguments[n];
                        o.verifyFlat(t, "falsy");
                        const r = this.clone();
                        r.$_terms.falsy = r.$_terms.falsy || new a();
                        for (let o = 0; o < t.length; ++o) {
                          const e = t[o];
                          i(void 0 !== e, "Cannot call falsy with undefined"),
                            r.$_terms.falsy.add(e);
                        }
                        return r;
                      },
                    },
                    sensitive: {
                      method() {
                        let e =
                          !(arguments.length > 0 && void 0 !== arguments[0]) ||
                          arguments[0];
                        return this.$_setFlag("sensitive", e);
                      },
                    },
                  },
                  cast: {
                    number: { from: s.isBool, to: (e, t) => (e ? 1 : 0) },
                    string: {
                      from: s.isBool,
                      to: (e, t) => (e ? "true" : "false"),
                    },
                  },
                  manifest: {
                    build: (e, t) => (
                      t.truthy && (e = e.truthy(...t.truthy)),
                      t.falsy && (e = e.falsy(...t.falsy)),
                      e
                    ),
                  },
                  messages: { "boolean.base": "{{#label}} must be a boolean" },
                });
              },
              7500: (e, t, n) => {
                "use strict";
                const i = n(375),
                  r = n(8068),
                  o = n(8160),
                  a = n(3328),
                  s = {
                    isDate: function (e) {
                      return e instanceof Date;
                    },
                  };
                (e.exports = r.extend({
                  type: "date",
                  coerce: {
                    from: ["number", "string"],
                    method(e, t) {
                      let { schema: n } = t;
                      return { value: s.parse(e, n._flags.format) || e };
                    },
                  },
                  validate(e, t) {
                    let { schema: n, error: i, prefs: r } = t;
                    if (e instanceof Date && !isNaN(e.getTime())) return;
                    const o = n._flags.format;
                    return r.convert && o && "string" == typeof e
                      ? { value: e, errors: i("date.format", { format: o }) }
                      : { value: e, errors: i("date.base") };
                  },
                  rules: {
                    compare: {
                      method: !1,
                      validate(e, t, n, i) {
                        let { date: r } = n,
                          { name: a, operator: s, args: l } = i;
                        const c = "now" === r ? Date.now() : r.getTime();
                        return o.compare(e.getTime(), c, s)
                          ? e
                          : t.error("date." + a, { limit: l.date, value: e });
                      },
                      args: [
                        {
                          name: "date",
                          ref: !0,
                          normalize: (e) => ("now" === e ? e : s.parse(e)),
                          assert: (e) => null !== e,
                          message: "must have a valid date format",
                        },
                      ],
                    },
                    format: {
                      method(e) {
                        return (
                          i(
                            ["iso", "javascript", "unix"].includes(e),
                            "Unknown date format",
                            e
                          ),
                          this.$_setFlag("format", e)
                        );
                      },
                    },
                    greater: {
                      method(e) {
                        return this.$_addRule({
                          name: "greater",
                          method: "compare",
                          args: { date: e },
                          operator: ">",
                        });
                      },
                    },
                    iso: {
                      method() {
                        return this.format("iso");
                      },
                    },
                    less: {
                      method(e) {
                        return this.$_addRule({
                          name: "less",
                          method: "compare",
                          args: { date: e },
                          operator: "<",
                        });
                      },
                    },
                    max: {
                      method(e) {
                        return this.$_addRule({
                          name: "max",
                          method: "compare",
                          args: { date: e },
                          operator: "<=",
                        });
                      },
                    },
                    min: {
                      method(e) {
                        return this.$_addRule({
                          name: "min",
                          method: "compare",
                          args: { date: e },
                          operator: ">=",
                        });
                      },
                    },
                    timestamp: {
                      method() {
                        let e =
                          arguments.length > 0 && void 0 !== arguments[0]
                            ? arguments[0]
                            : "javascript";
                        return (
                          i(
                            ["javascript", "unix"].includes(e),
                            '"type" must be one of "javascript, unix"'
                          ),
                          this.format(e)
                        );
                      },
                    },
                  },
                  cast: {
                    number: { from: s.isDate, to: (e, t) => e.getTime() },
                    string: {
                      from: s.isDate,
                      to(e, t) {
                        let { prefs: n } = t;
                        return a.date(e, n);
                      },
                    },
                  },
                  messages: {
                    "date.base": "{{#label}} must be a valid date",
                    "date.format":
                      '{{#label}} must be in {msg("date.format." + #format) || #format} format',
                    "date.greater":
                      "{{#label}} must be greater than {{:#limit}}",
                    "date.less": "{{#label}} must be less than {{:#limit}}",
                    "date.max":
                      "{{#label}} must be less than or equal to {{:#limit}}",
                    "date.min":
                      "{{#label}} must be greater than or equal to {{:#limit}}",
                    "date.format.iso": "ISO 8601 date",
                    "date.format.javascript":
                      "timestamp or number of milliseconds",
                    "date.format.unix": "timestamp or number of seconds",
                  },
                })),
                  (s.parse = function (e, t) {
                    if (e instanceof Date) return e;
                    if ("string" != typeof e && (isNaN(e) || !isFinite(e)))
                      return null;
                    if (/^\s*$/.test(e)) return null;
                    if ("iso" === t)
                      return o.isIsoDate(e) ? s.date(e.toString()) : null;
                    const n = e;
                    if (
                      ("string" == typeof e &&
                        /^[+-]?\d+(\.\d+)?$/.test(e) &&
                        (e = parseFloat(e)),
                      t)
                    ) {
                      if ("javascript" === t) return s.date(1 * e);
                      if ("unix" === t) return s.date(1e3 * e);
                      if ("string" == typeof n) return null;
                    }
                    return s.date(e);
                  }),
                  (s.date = function (e) {
                    const t = new Date(e);
                    return isNaN(t.getTime()) ? null : t;
                  });
              },
              390: (e, t, n) => {
                "use strict";
                const i = n(375),
                  r = n(7824);
                e.exports = r.extend({
                  type: "function",
                  properties: { typeof: "function" },
                  rules: {
                    arity: {
                      method(e) {
                        return (
                          i(
                            Number.isSafeInteger(e) && e >= 0,
                            "n must be a positive integer"
                          ),
                          this.$_addRule({ name: "arity", args: { n: e } })
                        );
                      },
                      validate(e, t, n) {
                        let { n: i } = n;
                        return e.length === i
                          ? e
                          : t.error("function.arity", { n: i });
                      },
                    },
                    class: {
                      method() {
                        return this.$_addRule("class");
                      },
                      validate: (e, t) =>
                        /^\s*class\s/.test(e.toString())
                          ? e
                          : t.error("function.class", { value: e }),
                    },
                    minArity: {
                      method(e) {
                        return (
                          i(
                            Number.isSafeInteger(e) && e > 0,
                            "n must be a strict positive integer"
                          ),
                          this.$_addRule({ name: "minArity", args: { n: e } })
                        );
                      },
                      validate(e, t, n) {
                        let { n: i } = n;
                        return e.length >= i
                          ? e
                          : t.error("function.minArity", { n: i });
                      },
                    },
                    maxArity: {
                      method(e) {
                        return (
                          i(
                            Number.isSafeInteger(e) && e >= 0,
                            "n must be a positive integer"
                          ),
                          this.$_addRule({ name: "maxArity", args: { n: e } })
                        );
                      },
                      validate(e, t, n) {
                        let { n: i } = n;
                        return e.length <= i
                          ? e
                          : t.error("function.maxArity", { n: i });
                      },
                    },
                  },
                  messages: {
                    "function.arity": "{{#label}} must have an arity of {{#n}}",
                    "function.class": "{{#label}} must be a class",
                    "function.maxArity":
                      "{{#label}} must have an arity lesser or equal to {{#n}}",
                    "function.minArity":
                      "{{#label}} must have an arity greater or equal to {{#n}}",
                  },
                });
              },
              7824: (e, t, n) => {
                "use strict";
                const i = n(978),
                  r = n(375),
                  o = n(8571),
                  a = n(3652),
                  s = n(8068),
                  l = n(8160),
                  c = n(3292),
                  p = n(6354),
                  u = n(6133),
                  d = n(3328),
                  m = {
                    renameDefaults: { alias: !1, multiple: !1, override: !1 },
                  };
                (e.exports = s.extend({
                  type: "_keys",
                  properties: { typeof: "object" },
                  flags: { unknown: { default: !1 } },
                  terms: {
                    dependencies: { init: null },
                    keys: {
                      init: null,
                      manifest: { mapped: { from: "schema", to: "key" } },
                    },
                    patterns: { init: null },
                    renames: { init: null },
                  },
                  args: (e, t) => e.keys(t),
                  validate(e, t) {
                    let { schema: n, error: i, state: r, prefs: o } = t;
                    if (
                      !e ||
                      typeof e !== n.$_property("typeof") ||
                      Array.isArray(e)
                    )
                      return {
                        value: e,
                        errors: i("object.base", {
                          type: n.$_property("typeof"),
                        }),
                      };
                    if (
                      !(
                        n.$_terms.renames ||
                        n.$_terms.dependencies ||
                        n.$_terms.keys ||
                        n.$_terms.patterns ||
                        n.$_terms.externals
                      )
                    )
                      return;
                    e = m.clone(e, o);
                    const a = [];
                    if (n.$_terms.renames && !m.rename(n, e, r, o, a))
                      return { value: e, errors: a };
                    if (
                      !n.$_terms.keys &&
                      !n.$_terms.patterns &&
                      !n.$_terms.dependencies
                    )
                      return { value: e, errors: a };
                    const s = new Set(Object.keys(e));
                    if (n.$_terms.keys) {
                      const t = [e, ...r.ancestors];
                      for (const i of n.$_terms.keys) {
                        const n = i.key,
                          l = e[n];
                        s.delete(n);
                        const c = r.localize([...r.path, n], t, i),
                          p = i.schema.$_validate(l, c, o);
                        if (p.errors) {
                          if (o.abortEarly)
                            return { value: e, errors: p.errors };
                          void 0 !== p.value && (e[n] = p.value),
                            a.push(...p.errors);
                        } else
                          "strip" === i.schema._flags.result ||
                          (void 0 === p.value && void 0 !== l)
                            ? delete e[n]
                            : void 0 !== p.value && (e[n] = p.value);
                      }
                    }
                    if (s.size || n._flags._hasPatternMatch) {
                      const t = m.unknown(n, e, s, a, r, o);
                      if (t) return t;
                    }
                    if (n.$_terms.dependencies)
                      for (const l of n.$_terms.dependencies) {
                        if (
                          null !== l.key &&
                          !1 ===
                            m.isPresent(l.options)(
                              l.key.resolve(e, r, o, null, { shadow: !1 })
                            )
                        )
                          continue;
                        const t = m.dependencies[l.rel](n, l, e, r, o);
                        if (t) {
                          const i = n.$_createError(t.code, e, t.context, r, o);
                          if (o.abortEarly) return { value: e, errors: i };
                          a.push(i);
                        }
                      }
                    return { value: e, errors: a };
                  },
                  rules: {
                    and: {
                      method() {
                        for (
                          var e = arguments.length, t = new Array(e), n = 0;
                          n < e;
                          n++
                        )
                          t[n] = arguments[n];
                        return (
                          l.verifyFlat(t, "and"),
                          m.dependency(this, "and", null, t)
                        );
                      },
                    },
                    append: {
                      method(e) {
                        return null == e || 0 === Object.keys(e).length
                          ? this
                          : this.keys(e);
                      },
                    },
                    assert: {
                      method(e, t, n) {
                        d.isTemplate(e) || (e = c.ref(e)),
                          r(
                            void 0 === n || "string" == typeof n,
                            "Message must be a string"
                          ),
                          (t = this.$_compile(t, { appendPath: !0 }));
                        const i = this.$_addRule({
                          name: "assert",
                          args: { subject: e, schema: t, message: n },
                        });
                        return i.$_mutateRegister(e), i.$_mutateRegister(t), i;
                      },
                      validate(e, t, n) {
                        let { error: i, prefs: r, state: o } = t,
                          { subject: a, schema: s, message: l } = n;
                        const c = a.resolve(e, o, r),
                          p = u.isRef(a) ? a.absolute(o) : [];
                        return s.$_match(
                          c,
                          o.localize(p, [e, ...o.ancestors], s),
                          r
                        )
                          ? e
                          : i("object.assert", { subject: a, message: l });
                      },
                      args: ["subject", "schema", "message"],
                      multi: !0,
                    },
                    instance: {
                      method(e, t) {
                        return (
                          r(
                            "function" == typeof e,
                            "constructor must be a function"
                          ),
                          (t = t || e.name),
                          this.$_addRule({
                            name: "instance",
                            args: { constructor: e, name: t },
                          })
                        );
                      },
                      validate(e, t, n) {
                        let { constructor: i, name: r } = n;
                        return e instanceof i
                          ? e
                          : t.error("object.instance", { type: r, value: e });
                      },
                      args: ["constructor", "name"],
                    },
                    keys: {
                      method(e) {
                        r(
                          void 0 === e || "object" == typeof e,
                          "Object schema must be a valid object"
                        ),
                          r(
                            !l.isSchema(e),
                            "Object schema cannot be a joi schema"
                          );
                        const t = this.clone();
                        if (e)
                          if (Object.keys(e).length) {
                            t.$_terms.keys = t.$_terms.keys
                              ? t.$_terms.keys.filter(
                                  (t) => !e.hasOwnProperty(t.key)
                                )
                              : new m.Keys();
                            for (const n in e)
                              l.tryWithPath(
                                () =>
                                  t.$_terms.keys.push({
                                    key: n,
                                    schema: this.$_compile(e[n]),
                                  }),
                                n
                              );
                          } else t.$_terms.keys = new m.Keys();
                        else t.$_terms.keys = null;
                        return t.$_mutateRebuild();
                      },
                    },
                    length: {
                      method(e) {
                        return this.$_addRule({
                          name: "length",
                          args: { limit: e },
                          operator: "=",
                        });
                      },
                      validate(e, t, n, i) {
                        let { limit: r } = n,
                          { name: o, operator: a, args: s } = i;
                        return l.compare(Object.keys(e).length, r, a)
                          ? e
                          : t.error("object." + o, {
                              limit: s.limit,
                              value: e,
                            });
                      },
                      args: [
                        {
                          name: "limit",
                          ref: !0,
                          assert: l.limit,
                          message: "must be a positive integer",
                        },
                      ],
                    },
                    max: {
                      method(e) {
                        return this.$_addRule({
                          name: "max",
                          method: "length",
                          args: { limit: e },
                          operator: "<=",
                        });
                      },
                    },
                    min: {
                      method(e) {
                        return this.$_addRule({
                          name: "min",
                          method: "length",
                          args: { limit: e },
                          operator: ">=",
                        });
                      },
                    },
                    nand: {
                      method() {
                        for (
                          var e = arguments.length, t = new Array(e), n = 0;
                          n < e;
                          n++
                        )
                          t[n] = arguments[n];
                        return (
                          l.verifyFlat(t, "nand"),
                          m.dependency(this, "nand", null, t)
                        );
                      },
                    },
                    or: {
                      method() {
                        for (
                          var e = arguments.length, t = new Array(e), n = 0;
                          n < e;
                          n++
                        )
                          t[n] = arguments[n];
                        return (
                          l.verifyFlat(t, "or"),
                          m.dependency(this, "or", null, t)
                        );
                      },
                    },
                    oxor: {
                      method() {
                        for (
                          var e = arguments.length, t = new Array(e), n = 0;
                          n < e;
                          n++
                        )
                          t[n] = arguments[n];
                        return m.dependency(this, "oxor", null, t);
                      },
                    },
                    pattern: {
                      method(e, t) {
                        let n =
                          arguments.length > 2 && void 0 !== arguments[2]
                            ? arguments[2]
                            : {};
                        const i = e instanceof RegExp;
                        i || (e = this.$_compile(e, { appendPath: !0 })),
                          r(void 0 !== t, "Invalid rule"),
                          l.assertOptions(n, ["fallthrough", "matches"]),
                          i &&
                            r(
                              !e.flags.includes("g") && !e.flags.includes("y"),
                              "pattern should not use global or sticky mode"
                            ),
                          (t = this.$_compile(t, { appendPath: !0 }));
                        const o = this.clone();
                        o.$_terms.patterns = o.$_terms.patterns || [];
                        const a = { [i ? "regex" : "schema"]: e, rule: t };
                        return (
                          n.matches &&
                            ((a.matches = this.$_compile(n.matches)),
                            "array" !== a.matches.type &&
                              (a.matches = a.matches.$_root
                                .array()
                                .items(a.matches)),
                            o.$_mutateRegister(a.matches),
                            o.$_setFlag("_hasPatternMatch", !0, { clone: !1 })),
                          n.fallthrough && (a.fallthrough = !0),
                          o.$_terms.patterns.push(a),
                          o.$_mutateRegister(t),
                          o
                        );
                      },
                    },
                    ref: {
                      method() {
                        return this.$_addRule("ref");
                      },
                      validate: (e, t) =>
                        u.isRef(e)
                          ? e
                          : t.error("object.refType", { value: e }),
                    },
                    regex: {
                      method() {
                        return this.$_addRule("regex");
                      },
                      validate: (e, t) =>
                        e instanceof RegExp
                          ? e
                          : t.error("object.regex", { value: e }),
                    },
                    rename: {
                      method(e, t) {
                        let n =
                          arguments.length > 2 && void 0 !== arguments[2]
                            ? arguments[2]
                            : {};
                        r(
                          "string" == typeof e || e instanceof RegExp,
                          "Rename missing the from argument"
                        ),
                          r(
                            "string" == typeof t || t instanceof d,
                            "Invalid rename to argument"
                          ),
                          r(t !== e, "Cannot rename key to same name:", e),
                          l.assertOptions(n, [
                            "alias",
                            "ignoreUndefined",
                            "override",
                            "multiple",
                          ]);
                        const o = this.clone();
                        o.$_terms.renames = o.$_terms.renames || [];
                        for (const i of o.$_terms.renames)
                          r(
                            i.from !== e,
                            "Cannot rename the same key multiple times"
                          );
                        return (
                          t instanceof d && o.$_mutateRegister(t),
                          o.$_terms.renames.push({
                            from: e,
                            to: t,
                            options: i(m.renameDefaults, n),
                          }),
                          o
                        );
                      },
                    },
                    schema: {
                      method() {
                        let e =
                          arguments.length > 0 && void 0 !== arguments[0]
                            ? arguments[0]
                            : "any";
                        return this.$_addRule({
                          name: "schema",
                          args: { type: e },
                        });
                      },
                      validate(e, t, n) {
                        let { type: i } = n;
                        return !l.isSchema(e) || ("any" !== i && e.type !== i)
                          ? t.error("object.schema", { type: i })
                          : e;
                      },
                    },
                    unknown: {
                      method(e) {
                        return this.$_setFlag("unknown", !1 !== e);
                      },
                    },
                    with: {
                      method(e, t) {
                        let n =
                          arguments.length > 2 && void 0 !== arguments[2]
                            ? arguments[2]
                            : {};
                        return m.dependency(this, "with", e, t, n);
                      },
                    },
                    without: {
                      method(e, t) {
                        let n =
                          arguments.length > 2 && void 0 !== arguments[2]
                            ? arguments[2]
                            : {};
                        return m.dependency(this, "without", e, t, n);
                      },
                    },
                    xor: {
                      method() {
                        for (
                          var e = arguments.length, t = new Array(e), n = 0;
                          n < e;
                          n++
                        )
                          t[n] = arguments[n];
                        return (
                          l.verifyFlat(t, "xor"),
                          m.dependency(this, "xor", null, t)
                        );
                      },
                    },
                  },
                  overrides: {
                    default(e, t) {
                      return (
                        void 0 === e && (e = l.symbols.deepDefault),
                        this.$_parent("default", e, t)
                      );
                    },
                  },
                  rebuild(e) {
                    if (e.$_terms.keys) {
                      const t = new a.Sorter();
                      for (const n of e.$_terms.keys)
                        l.tryWithPath(
                          () =>
                            t.add(n, {
                              after: n.schema.$_rootReferences(),
                              group: n.key,
                            }),
                          n.key
                        );
                      e.$_terms.keys = new m.Keys(...t.nodes);
                    }
                  },
                  manifest: {
                    build(e, t) {
                      if ((t.keys && (e = e.keys(t.keys)), t.dependencies))
                        for (const {
                          rel: n,
                          key: i = null,
                          peers: r,
                          options: o,
                        } of t.dependencies)
                          e = m.dependency(e, n, i, r, o);
                      if (t.patterns)
                        for (const {
                          regex: n,
                          schema: i,
                          rule: r,
                          fallthrough: o,
                          matches: a,
                        } of t.patterns)
                          e = e.pattern(n || i, r, {
                            fallthrough: o,
                            matches: a,
                          });
                      if (t.renames)
                        for (const { from: n, to: i, options: r } of t.renames)
                          e = e.rename(n, i, r);
                      return e;
                    },
                  },
                  messages: {
                    "object.and":
                      "{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}",
                    "object.assert":
                      '{{#label}} is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}',
                    "object.base": "{{#label}} must be of type {{#type}}",
                    "object.instance":
                      "{{#label}} must be an instance of {{:#type}}",
                    "object.length":
                      '{{#label}} must have {{#limit}} key{if(#limit == 1, "", "s")}',
                    "object.max":
                      '{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}',
                    "object.min":
                      '{{#label}} must have at least {{#limit}} key{if(#limit == 1, "", "s")}',
                    "object.missing":
                      "{{#label}} must contain at least one of {{#peersWithLabels}}",
                    "object.nand":
                      "{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}",
                    "object.oxor":
                      "{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}",
                    "object.pattern.match":
                      "{{#label}} keys failed to match pattern requirements",
                    "object.refType": "{{#label}} must be a Joi reference",
                    "object.regex": "{{#label}} must be a RegExp object",
                    "object.rename.multiple":
                      "{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}",
                    "object.rename.override":
                      "{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists",
                    "object.schema":
                      "{{#label}} must be a Joi schema of {{#type}} type",
                    "object.unknown": "{{#label}} is not allowed",
                    "object.with":
                      "{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}",
                    "object.without":
                      "{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}",
                    "object.xor":
                      "{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}",
                  },
                })),
                  (m.clone = function (e, t) {
                    if ("object" == typeof e) {
                      if (t.nonEnumerables) return o(e, { shallow: !0 });
                      const n = Object.create(Object.getPrototypeOf(e));
                      return Object.assign(n, e), n;
                    }
                    const n = function () {
                      for (
                        var t = arguments.length, n = new Array(t), i = 0;
                        i < t;
                        i++
                      )
                        n[i] = arguments[i];
                      return e.apply(this, n);
                    };
                    return (
                      (n.prototype = o(e.prototype)),
                      Object.defineProperty(n, "name", {
                        value: e.name,
                        writable: !1,
                      }),
                      Object.defineProperty(n, "length", {
                        value: e.length,
                        writable: !1,
                      }),
                      Object.assign(n, e),
                      n
                    );
                  }),
                  (m.dependency = function (e, t, n, i, o) {
                    r(
                      null === n || "string" == typeof n,
                      t,
                      "key must be a strings"
                    ),
                      o ||
                        (o =
                          i.length > 1 && "object" == typeof i[i.length - 1]
                            ? i.pop()
                            : {}),
                      l.assertOptions(o, ["separator", "isPresent"]),
                      (i = [].concat(i));
                    const a = l.default(o.separator, "."),
                      s = [];
                    for (const l of i)
                      r("string" == typeof l, t, "peers must be strings"),
                        s.push(
                          c.ref(l, { separator: a, ancestor: 0, prefix: !1 })
                        );
                    null !== n &&
                      (n = c.ref(n, { separator: a, ancestor: 0, prefix: !1 }));
                    const p = e.clone();
                    return (
                      (p.$_terms.dependencies = p.$_terms.dependencies || []),
                      p.$_terms.dependencies.push(
                        new m.Dependency(t, n, s, i, o)
                      ),
                      p
                    );
                  }),
                  (m.dependencies = {
                    and(e, t, n, i, r) {
                      const o = [],
                        a = [],
                        s = t.peers.length,
                        l = m.isPresent(t.options);
                      for (const c of t.peers)
                        !1 === l(c.resolve(n, i, r, null, { shadow: !1 }))
                          ? o.push(c.key)
                          : a.push(c.key);
                      if (o.length !== s && a.length !== s)
                        return {
                          code: "object.and",
                          context: {
                            present: a,
                            presentWithLabels: m.keysToLabels(e, a),
                            missing: o,
                            missingWithLabels: m.keysToLabels(e, o),
                          },
                        };
                    },
                    nand(e, t, n, i, r) {
                      const o = [],
                        a = m.isPresent(t.options);
                      for (const c of t.peers)
                        a(c.resolve(n, i, r, null, { shadow: !1 })) &&
                          o.push(c.key);
                      if (o.length !== t.peers.length) return;
                      const s = t.paths[0],
                        l = t.paths.slice(1);
                      return {
                        code: "object.nand",
                        context: {
                          main: s,
                          mainWithLabel: m.keysToLabels(e, s),
                          peers: l,
                          peersWithLabels: m.keysToLabels(e, l),
                        },
                      };
                    },
                    or(e, t, n, i, r) {
                      const o = m.isPresent(t.options);
                      for (const a of t.peers)
                        if (o(a.resolve(n, i, r, null, { shadow: !1 }))) return;
                      return {
                        code: "object.missing",
                        context: {
                          peers: t.paths,
                          peersWithLabels: m.keysToLabels(e, t.paths),
                        },
                      };
                    },
                    oxor(e, t, n, i, r) {
                      const o = [],
                        a = m.isPresent(t.options);
                      for (const l of t.peers)
                        a(l.resolve(n, i, r, null, { shadow: !1 })) &&
                          o.push(l.key);
                      if (!o.length || 1 === o.length) return;
                      const s = {
                        peers: t.paths,
                        peersWithLabels: m.keysToLabels(e, t.paths),
                      };
                      return (
                        (s.present = o),
                        (s.presentWithLabels = m.keysToLabels(e, o)),
                        { code: "object.oxor", context: s }
                      );
                    },
                    with(e, t, n, i, r) {
                      const o = m.isPresent(t.options);
                      for (const a of t.peers)
                        if (!1 === o(a.resolve(n, i, r, null, { shadow: !1 })))
                          return {
                            code: "object.with",
                            context: {
                              main: t.key.key,
                              mainWithLabel: m.keysToLabels(e, t.key.key),
                              peer: a.key,
                              peerWithLabel: m.keysToLabels(e, a.key),
                            },
                          };
                    },
                    without(e, t, n, i, r) {
                      const o = m.isPresent(t.options);
                      for (const a of t.peers)
                        if (o(a.resolve(n, i, r, null, { shadow: !1 })))
                          return {
                            code: "object.without",
                            context: {
                              main: t.key.key,
                              mainWithLabel: m.keysToLabels(e, t.key.key),
                              peer: a.key,
                              peerWithLabel: m.keysToLabels(e, a.key),
                            },
                          };
                    },
                    xor(e, t, n, i, r) {
                      const o = [],
                        a = m.isPresent(t.options);
                      for (const l of t.peers)
                        a(l.resolve(n, i, r, null, { shadow: !1 })) &&
                          o.push(l.key);
                      if (1 === o.length) return;
                      const s = {
                        peers: t.paths,
                        peersWithLabels: m.keysToLabels(e, t.paths),
                      };
                      return 0 === o.length
                        ? { code: "object.missing", context: s }
                        : ((s.present = o),
                          (s.presentWithLabels = m.keysToLabels(e, o)),
                          { code: "object.xor", context: s });
                    },
                  }),
                  (m.keysToLabels = function (e, t) {
                    return Array.isArray(t)
                      ? t.map((t) => e.$_mapLabels(t))
                      : e.$_mapLabels(t);
                  }),
                  (m.isPresent = function (e) {
                    return "function" == typeof e.isPresent
                      ? e.isPresent
                      : (e) => void 0 !== e;
                  }),
                  (m.rename = function (e, t, n, i, r) {
                    const o = {};
                    for (const a of e.$_terms.renames) {
                      const s = [],
                        l = "string" != typeof a.from;
                      if (l)
                        for (const e in t) {
                          if (void 0 === t[e] && a.options.ignoreUndefined)
                            continue;
                          if (e === a.to) continue;
                          const n = a.from.exec(e);
                          n && s.push({ from: e, to: a.to, match: n });
                        }
                      else
                        !Object.prototype.hasOwnProperty.call(t, a.from) ||
                          (void 0 === t[a.from] && a.options.ignoreUndefined) ||
                          s.push(a);
                      for (const c of s) {
                        const s = c.from;
                        let p = c.to;
                        if (
                          (p instanceof d && (p = p.render(t, n, i, c.match)),
                          s !== p)
                        ) {
                          if (
                            !a.options.multiple &&
                            o[p] &&
                            (r.push(
                              e.$_createError(
                                "object.rename.multiple",
                                t,
                                { from: s, to: p, pattern: l },
                                n,
                                i
                              )
                            ),
                            i.abortEarly)
                          )
                            return !1;
                          if (
                            Object.prototype.hasOwnProperty.call(t, p) &&
                            !a.options.override &&
                            !o[p] &&
                            (r.push(
                              e.$_createError(
                                "object.rename.override",
                                t,
                                { from: s, to: p, pattern: l },
                                n,
                                i
                              )
                            ),
                            i.abortEarly)
                          )
                            return !1;
                          void 0 === t[s] ? delete t[p] : (t[p] = t[s]),
                            (o[p] = !0),
                            a.options.alias || delete t[s];
                        }
                      }
                    }
                    return !0;
                  }),
                  (m.unknown = function (e, t, n, i, r, o) {
                    if (e.$_terms.patterns) {
                      let a = !1;
                      const s = e.$_terms.patterns.map((e) => {
                          if (e.matches) return (a = !0), [];
                        }),
                        l = [t, ...r.ancestors];
                      for (const c of n) {
                        const a = t[c],
                          p = [...r.path, c];
                        for (let u = 0; u < e.$_terms.patterns.length; ++u) {
                          const d = e.$_terms.patterns[u];
                          if (d.regex) {
                            const e = d.regex.test(c);
                            if (
                              (r.mainstay.tracer.debug(
                                r,
                                "rule",
                                `pattern.${u}`,
                                e ? "pass" : "error"
                              ),
                              !e)
                            )
                              continue;
                          } else if (
                            !d.schema.$_match(
                              c,
                              r.nest(d.schema, `pattern.${u}`),
                              o
                            )
                          )
                            continue;
                          n.delete(c);
                          const m = r.localize(p, l, {
                              schema: d.rule,
                              key: c,
                            }),
                            h = d.rule.$_validate(a, m, o);
                          if (h.errors) {
                            if (o.abortEarly)
                              return { value: t, errors: h.errors };
                            i.push(...h.errors);
                          }
                          if (
                            (d.matches && s[u].push(c),
                            (t[c] = h.value),
                            !d.fallthrough)
                          )
                            break;
                        }
                      }
                      if (a)
                        for (let n = 0; n < s.length; ++n) {
                          const a = s[n];
                          if (!a) continue;
                          const c = e.$_terms.patterns[n].matches,
                            u = r.localize(r.path, l, c),
                            d = c.$_validate(a, u, o);
                          if (d.errors) {
                            const n = p.details(d.errors, { override: !1 });
                            n.matches = a;
                            const s = e.$_createError(
                              "object.pattern.match",
                              t,
                              n,
                              r,
                              o
                            );
                            if (o.abortEarly) return { value: t, errors: s };
                            i.push(s);
                          }
                        }
                    }
                    if (n.size && (e.$_terms.keys || e.$_terms.patterns)) {
                      if (
                        (o.stripUnknown && !e._flags.unknown) ||
                        o.skipFunctions
                      ) {
                        const e = !(
                          !o.stripUnknown ||
                          (!0 !== o.stripUnknown && !o.stripUnknown.objects)
                        );
                        for (const i of n)
                          e
                            ? (delete t[i], n.delete(i))
                            : "function" == typeof t[i] && n.delete(i);
                      }
                      if (!l.default(e._flags.unknown, o.allowUnknown))
                        for (const a of n) {
                          const n = r.localize([...r.path, a], []),
                            s = e.$_createError(
                              "object.unknown",
                              t[a],
                              { child: a },
                              n,
                              o,
                              { flags: !1 }
                            );
                          if (o.abortEarly) return { value: t, errors: s };
                          i.push(s);
                        }
                    }
                  }),
                  (m.Dependency = class {
                    constructor(e, t, n, i, r) {
                      (this.rel = e),
                        (this.key = t),
                        (this.peers = n),
                        (this.paths = i),
                        (this.options = r);
                    }
                    describe() {
                      const e = { rel: this.rel, peers: this.paths };
                      return (
                        null !== this.key && (e.key = this.key.key),
                        "." !== this.peers[0].separator &&
                          (e.options = {
                            ...e.options,
                            separator: this.peers[0].separator,
                          }),
                        this.options.isPresent &&
                          (e.options = {
                            ...e.options,
                            isPresent: this.options.isPresent,
                          }),
                        e
                      );
                    }
                  }),
                  (m.Keys = class extends Array {
                    concat(e) {
                      const t = this.slice(),
                        n = new Map();
                      for (let i = 0; i < t.length; ++i) n.set(t[i].key, i);
                      for (const i of e) {
                        const e = i.key,
                          r = n.get(e);
                        void 0 !== r
                          ? (t[r] = {
                              key: e,
                              schema: t[r].schema.concat(i.schema),
                            })
                          : t.push(i);
                      }
                      return t;
                    }
                  });
              },
              8785: (e, t, n) => {
                "use strict";
                const i = n(375),
                  r = n(8068),
                  o = n(8160),
                  a = n(3292),
                  s = n(6354),
                  l = {};
                (e.exports = r.extend({
                  type: "link",
                  properties: { schemaChain: !0 },
                  terms: {
                    link: { init: null, manifest: "single", register: !1 },
                  },
                  args: (e, t) => e.ref(t),
                  validate(e, t) {
                    let { schema: n, state: r, prefs: o } = t;
                    i(n.$_terms.link, "Uninitialized link schema");
                    const a = l.generate(n, e, r, o),
                      s = n.$_terms.link[0].ref;
                    return a.$_validate(
                      e,
                      r.nest(a, `link:${s.display}:${a.type}`),
                      o
                    );
                  },
                  generate: (e, t, n, i) => l.generate(e, t, n, i),
                  rules: {
                    ref: {
                      method(e) {
                        i(!this.$_terms.link, "Cannot reinitialize schema"),
                          (e = a.ref(e)),
                          i(
                            "value" === e.type || "local" === e.type,
                            "Invalid reference type:",
                            e.type
                          ),
                          i(
                            "local" === e.type ||
                              "root" === e.ancestor ||
                              e.ancestor > 0,
                            "Link cannot reference itself"
                          );
                        const t = this.clone();
                        return (t.$_terms.link = [{ ref: e }]), t;
                      },
                    },
                    relative: {
                      method() {
                        let e =
                          !(arguments.length > 0 && void 0 !== arguments[0]) ||
                          arguments[0];
                        return this.$_setFlag("relative", e);
                      },
                    },
                  },
                  overrides: {
                    concat(e) {
                      i(this.$_terms.link, "Uninitialized link schema"),
                        i(o.isSchema(e), "Invalid schema object"),
                        i(
                          "link" !== e.type,
                          "Cannot merge type link with another link"
                        );
                      const t = this.clone();
                      return (
                        t.$_terms.whens || (t.$_terms.whens = []),
                        t.$_terms.whens.push({ concat: e }),
                        t.$_mutateRebuild()
                      );
                    },
                  },
                  manifest: {
                    build: (e, t) => (
                      i(t.link, "Invalid link description missing link"),
                      e.ref(t.link)
                    ),
                  },
                })),
                  (l.generate = function (e, t, n, i) {
                    let r = n.mainstay.links.get(e);
                    if (r) return r._generate(t, n, i).schema;
                    const o = e.$_terms.link[0].ref,
                      { perspective: a, path: s } = l.perspective(o, n);
                    l.assert(
                      a,
                      "which is outside of schema boundaries",
                      o,
                      e,
                      n,
                      i
                    );
                    try {
                      r = s.length ? a.$_reach(s) : a;
                    } catch (t) {
                      l.assert(!1, "to non-existing schema", o, e, n, i);
                    }
                    return (
                      l.assert(
                        "link" !== r.type,
                        "which is another link",
                        o,
                        e,
                        n,
                        i
                      ),
                      e._flags.relative || n.mainstay.links.set(e, r),
                      r._generate(t, n, i).schema
                    );
                  }),
                  (l.perspective = function (e, t) {
                    if ("local" === e.type) {
                      for (const { schema: n, key: i } of t.schemas) {
                        if ((n._flags.id || i) === e.path[0])
                          return { perspective: n, path: e.path.slice(1) };
                        if (n.$_terms.shared)
                          for (const t of n.$_terms.shared)
                            if (t._flags.id === e.path[0])
                              return { perspective: t, path: e.path.slice(1) };
                      }
                      return { perspective: null, path: null };
                    }
                    return "root" === e.ancestor
                      ? {
                          perspective: t.schemas[t.schemas.length - 1].schema,
                          path: e.path,
                        }
                      : {
                          perspective:
                            t.schemas[e.ancestor] &&
                            t.schemas[e.ancestor].schema,
                          path: e.path,
                        };
                  }),
                  (l.assert = function (e, t, n, r, o, a) {
                    e ||
                      i(
                        !1,
                        `"${s.label(
                          r._flags,
                          o,
                          a
                        )}" contains link reference "${n.display}" ${t}`
                      );
                  });
              },
              3832: (e, t, n) => {
                "use strict";
                const i = n(375),
                  r = n(8068),
                  o = n(8160),
                  a = {
                    numberRx:
                      /^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,
                    precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/,
                    exponentialPartRegex: /[eE][+-]?\d+$/,
                    leadingSignAndZerosRegex: /^[+-]?(0*)?/,
                    dotRegex: /\./,
                    trailingZerosRegex: /0+$/,
                  };
                (e.exports = r.extend({
                  type: "number",
                  flags: { unsafe: { default: !1 } },
                  coerce: {
                    from: "string",
                    method(e, t) {
                      let { schema: n, error: i } = t;
                      if (!e.match(a.numberRx)) return;
                      e = e.trim();
                      const r = { value: parseFloat(e) };
                      if ((0 === r.value && (r.value = 0), !n._flags.unsafe))
                        if (e.match(/e/i)) {
                          if (
                            a.extractSignificantDigits(e) !==
                            a.extractSignificantDigits(String(r.value))
                          )
                            return (r.errors = i("number.unsafe")), r;
                        } else {
                          const t = r.value.toString();
                          if (t.match(/e/i)) return r;
                          if (t !== a.normalizeDecimal(e))
                            return (r.errors = i("number.unsafe")), r;
                        }
                      return r;
                    },
                  },
                  validate(e, t) {
                    let { schema: n, error: i, prefs: r } = t;
                    if (e === 1 / 0 || e === -1 / 0)
                      return { value: e, errors: i("number.infinity") };
                    if (!o.isNumber(e))
                      return { value: e, errors: i("number.base") };
                    const a = { value: e };
                    if (r.convert) {
                      const e = n.$_getRule("precision");
                      if (e) {
                        const t = Math.pow(10, e.args.limit);
                        a.value = Math.round(a.value * t) / t;
                      }
                    }
                    return (
                      0 === a.value && (a.value = 0),
                      !n._flags.unsafe &&
                        (e > Number.MAX_SAFE_INTEGER ||
                          e < Number.MIN_SAFE_INTEGER) &&
                        (a.errors = i("number.unsafe")),
                      a
                    );
                  },
                  rules: {
                    compare: {
                      method: !1,
                      validate(e, t, n, i) {
                        let { limit: r } = n,
                          { name: a, operator: s, args: l } = i;
                        return o.compare(e, r, s)
                          ? e
                          : t.error("number." + a, {
                              limit: l.limit,
                              value: e,
                            });
                      },
                      args: [
                        {
                          name: "limit",
                          ref: !0,
                          assert: o.isNumber,
                          message: "must be a number",
                        },
                      ],
                    },
                    greater: {
                      method(e) {
                        return this.$_addRule({
                          name: "greater",
                          method: "compare",
                          args: { limit: e },
                          operator: ">",
                        });
                      },
                    },
                    integer: {
                      method() {
                        return this.$_addRule("integer");
                      },
                      validate: (e, t) =>
                        Math.trunc(e) - e == 0 ? e : t.error("number.integer"),
                    },
                    less: {
                      method(e) {
                        return this.$_addRule({
                          name: "less",
                          method: "compare",
                          args: { limit: e },
                          operator: "<",
                        });
                      },
                    },
                    max: {
                      method(e) {
                        return this.$_addRule({
                          name: "max",
                          method: "compare",
                          args: { limit: e },
                          operator: "<=",
                        });
                      },
                    },
                    min: {
                      method(e) {
                        return this.$_addRule({
                          name: "min",
                          method: "compare",
                          args: { limit: e },
                          operator: ">=",
                        });
                      },
                    },
                    multiple: {
                      method(e) {
                        return this.$_addRule({
                          name: "multiple",
                          args: { base: e },
                        });
                      },
                      validate(e, t, n, i) {
                        let { base: r } = n;
                        return (e * (1 / r)) % 1 == 0
                          ? e
                          : t.error("number.multiple", {
                              multiple: i.args.base,
                              value: e,
                            });
                      },
                      args: [
                        {
                          name: "base",
                          ref: !0,
                          assert: (e) =>
                            "number" == typeof e && isFinite(e) && e > 0,
                          message: "must be a positive number",
                        },
                      ],
                      multi: !0,
                    },
                    negative: {
                      method() {
                        return this.sign("negative");
                      },
                    },
                    port: {
                      method() {
                        return this.$_addRule("port");
                      },
                      validate: (e, t) =>
                        Number.isSafeInteger(e) && e >= 0 && e <= 65535
                          ? e
                          : t.error("number.port"),
                    },
                    positive: {
                      method() {
                        return this.sign("positive");
                      },
                    },
                    precision: {
                      method(e) {
                        return (
                          i(
                            Number.isSafeInteger(e),
                            "limit must be an integer"
                          ),
                          this.$_addRule({
                            name: "precision",
                            args: { limit: e },
                          })
                        );
                      },
                      validate(e, t, n) {
                        let { limit: i } = n;
                        const r = e.toString().match(a.precisionRx);
                        return Math.max(
                          (r[1] ? r[1].length : 0) -
                            (r[2] ? parseInt(r[2], 10) : 0),
                          0
                        ) <= i
                          ? e
                          : t.error("number.precision", { limit: i, value: e });
                      },
                      convert: !0,
                    },
                    sign: {
                      method(e) {
                        return (
                          i(
                            ["negative", "positive"].includes(e),
                            "Invalid sign",
                            e
                          ),
                          this.$_addRule({ name: "sign", args: { sign: e } })
                        );
                      },
                      validate(e, t, n) {
                        let { sign: i } = n;
                        return ("negative" === i && e < 0) ||
                          ("positive" === i && e > 0)
                          ? e
                          : t.error(`number.${i}`);
                      },
                    },
                    unsafe: {
                      method() {
                        let e =
                          !(arguments.length > 0 && void 0 !== arguments[0]) ||
                          arguments[0];
                        return (
                          i("boolean" == typeof e, "enabled must be a boolean"),
                          this.$_setFlag("unsafe", e)
                        );
                      },
                    },
                  },
                  cast: {
                    string: {
                      from: (e) => "number" == typeof e,
                      to: (e, t) => e.toString(),
                    },
                  },
                  messages: {
                    "number.base": "{{#label}} must be a number",
                    "number.greater":
                      "{{#label}} must be greater than {{#limit}}",
                    "number.infinity": "{{#label}} cannot be infinity",
                    "number.integer": "{{#label}} must be an integer",
                    "number.less": "{{#label}} must be less than {{#limit}}",
                    "number.max":
                      "{{#label}} must be less than or equal to {{#limit}}",
                    "number.min":
                      "{{#label}} must be greater than or equal to {{#limit}}",
                    "number.multiple":
                      "{{#label}} must be a multiple of {{#multiple}}",
                    "number.negative": "{{#label}} must be a negative number",
                    "number.port": "{{#label}} must be a valid port",
                    "number.positive": "{{#label}} must be a positive number",
                    "number.precision":
                      "{{#label}} must have no more than {{#limit}} decimal places",
                    "number.unsafe": "{{#label}} must be a safe number",
                  },
                })),
                  (a.extractSignificantDigits = function (e) {
                    return e
                      .replace(a.exponentialPartRegex, "")
                      .replace(a.dotRegex, "")
                      .replace(a.trailingZerosRegex, "")
                      .replace(a.leadingSignAndZerosRegex, "");
                  }),
                  (a.normalizeDecimal = function (e) {
                    return (
                      (e = e
                        .replace(/^\+/, "")
                        .replace(/\.0*$/, "")
                        .replace(/^(-?)\.([^\.]*)$/, "$10.$2")
                        .replace(/^(-?)0+([0-9])/, "$1$2")).includes(".") &&
                        e.endsWith("0") &&
                        (e = e.replace(/0+$/, "")),
                      "-0" === e ? "0" : e
                    );
                  });
              },
              8966: (e, t, n) => {
                "use strict";
                const i = n(7824);
                e.exports = i.extend({
                  type: "object",
                  cast: {
                    map: {
                      from: (e) => e && "object" == typeof e,
                      to: (e, t) => new Map(Object.entries(e)),
                    },
                  },
                });
              },
              7417: (e, t, n) => {
                "use strict";
                const i = n(375),
                  r = n(5380),
                  o = n(1745),
                  a = n(9959),
                  s = n(6064),
                  l = n(9926),
                  c = n(5752),
                  p = n(8068),
                  u = n(8160),
                  d = {
                    tlds: l instanceof Set && {
                      tlds: { allow: l, deny: null },
                    },
                    base64Regex: {
                      true: {
                        true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,
                        false:
                          /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/,
                      },
                      false: {
                        true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,
                        false:
                          /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/,
                      },
                    },
                    dataUriRegex:
                      /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,
                    hexRegex: /^[a-f0-9]+$/i,
                    ipRegex: a.regex({ cidr: "forbidden" }).regex,
                    isoDurationRegex:
                      /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,
                    guidBrackets: { "{": "}", "[": "]", "(": ")", "": "" },
                    guidVersions: {
                      uuidv1: "1",
                      uuidv2: "2",
                      uuidv3: "3",
                      uuidv4: "4",
                      uuidv5: "5",
                    },
                    guidSeparators: new Set([void 0, !0, !1, "-", ":"]),
                    normalizationForms: ["NFC", "NFD", "NFKC", "NFKD"],
                  };
                (e.exports = p.extend({
                  type: "string",
                  flags: {
                    insensitive: { default: !1 },
                    truncate: { default: !1 },
                  },
                  terms: { replacements: { init: null } },
                  coerce: {
                    from: "string",
                    method(e, t) {
                      let { schema: n, state: i, prefs: r } = t;
                      const o = n.$_getRule("normalize");
                      o && (e = e.normalize(o.args.form));
                      const a = n.$_getRule("case");
                      a &&
                        (e =
                          "upper" === a.args.direction
                            ? e.toLocaleUpperCase()
                            : e.toLocaleLowerCase());
                      const s = n.$_getRule("trim");
                      if (
                        (s && s.args.enabled && (e = e.trim()),
                        n.$_terms.replacements)
                      )
                        for (const c of n.$_terms.replacements)
                          e = e.replace(c.pattern, c.replacement);
                      const l = n.$_getRule("hex");
                      if (
                        (l &&
                          l.args.options.byteAligned &&
                          e.length % 2 != 0 &&
                          (e = `0${e}`),
                        n.$_getRule("isoDate"))
                      ) {
                        const t = d.isoDate(e);
                        t && (e = t);
                      }
                      if (n._flags.truncate) {
                        const t = n.$_getRule("max");
                        if (t) {
                          let o = t.args.limit;
                          if (
                            u.isResolvable(o) &&
                            ((o = o.resolve(e, i, r)), !u.limit(o))
                          )
                            return {
                              value: e,
                              errors: n.$_createError(
                                "any.ref",
                                o,
                                {
                                  ref: t.args.limit,
                                  arg: "limit",
                                  reason: "must be a positive integer",
                                },
                                i,
                                r
                              ),
                            };
                          e = e.slice(0, o);
                        }
                      }
                      return { value: e };
                    },
                  },
                  validate(e, t) {
                    let { schema: n, error: i } = t;
                    if ("string" != typeof e)
                      return { value: e, errors: i("string.base") };
                    if ("" === e) {
                      const t = n.$_getRule("min");
                      if (t && 0 === t.args.limit) return;
                      return { value: e, errors: i("string.empty") };
                    }
                  },
                  rules: {
                    alphanum: {
                      method() {
                        return this.$_addRule("alphanum");
                      },
                      validate: (e, t) =>
                        /^[a-zA-Z0-9]+$/.test(e)
                          ? e
                          : t.error("string.alphanum"),
                    },
                    base64: {
                      method() {
                        let e =
                          arguments.length > 0 && void 0 !== arguments[0]
                            ? arguments[0]
                            : {};
                        return (
                          u.assertOptions(e, ["paddingRequired", "urlSafe"]),
                          (e = { urlSafe: !1, paddingRequired: !0, ...e }),
                          i(
                            "boolean" == typeof e.paddingRequired,
                            "paddingRequired must be boolean"
                          ),
                          i(
                            "boolean" == typeof e.urlSafe,
                            "urlSafe must be boolean"
                          ),
                          this.$_addRule({
                            name: "base64",
                            args: { options: e },
                          })
                        );
                      },
                      validate(e, t, n) {
                        let { options: i } = n;
                        return d.base64Regex[i.paddingRequired][i.urlSafe].test(
                          e
                        )
                          ? e
                          : t.error("string.base64");
                      },
                    },
                    case: {
                      method(e) {
                        return (
                          i(["lower", "upper"].includes(e), "Invalid case:", e),
                          this.$_addRule({
                            name: "case",
                            args: { direction: e },
                          })
                        );
                      },
                      validate(e, t, n) {
                        let { direction: i } = n;
                        return ("lower" === i && e === e.toLocaleLowerCase()) ||
                          ("upper" === i && e === e.toLocaleUpperCase())
                          ? e
                          : t.error(`string.${i}case`);
                      },
                      convert: !0,
                    },
                    creditCard: {
                      method() {
                        return this.$_addRule("creditCard");
                      },
                      validate(e, t) {
                        let n = e.length,
                          i = 0,
                          r = 1;
                        for (; n--; ) {
                          const t = e.charAt(n) * r;
                          (i += t - 9 * (t > 9)), (r ^= 3);
                        }
                        return i > 0 && i % 10 == 0
                          ? e
                          : t.error("string.creditCard");
                      },
                    },
                    dataUri: {
                      method() {
                        let e =
                          arguments.length > 0 && void 0 !== arguments[0]
                            ? arguments[0]
                            : {};
                        return (
                          u.assertOptions(e, ["paddingRequired"]),
                          (e = { paddingRequired: !0, ...e }),
                          i(
                            "boolean" == typeof e.paddingRequired,
                            "paddingRequired must be boolean"
                          ),
                          this.$_addRule({
                            name: "dataUri",
                            args: { options: e },
                          })
                        );
                      },
                      validate(e, t, n) {
                        let { options: i } = n;
                        const r = e.match(d.dataUriRegex);
                        if (r) {
                          if (!r[2]) return e;
                          if ("base64" !== r[2]) return e;
                          if (d.base64Regex[i.paddingRequired].false.test(r[3]))
                            return e;
                        }
                        return t.error("string.dataUri");
                      },
                    },
                    domain: {
                      method(e) {
                        e &&
                          u.assertOptions(e, [
                            "allowFullyQualified",
                            "allowUnicode",
                            "maxDomainSegments",
                            "minDomainSegments",
                            "tlds",
                          ]);
                        const t = d.addressOptions(e);
                        return this.$_addRule({
                          name: "domain",
                          args: { options: e },
                          address: t,
                        });
                      },
                      validate(e, t, n, i) {
                        let { address: o } = i;
                        return r.isValid(e, o) ? e : t.error("string.domain");
                      },
                    },
                    email: {
                      method() {
                        let e =
                          arguments.length > 0 && void 0 !== arguments[0]
                            ? arguments[0]
                            : {};
                        u.assertOptions(e, [
                          "allowFullyQualified",
                          "allowUnicode",
                          "ignoreLength",
                          "maxDomainSegments",
                          "minDomainSegments",
                          "multiple",
                          "separator",
                          "tlds",
                        ]),
                          i(
                            void 0 === e.multiple ||
                              "boolean" == typeof e.multiple,
                            "multiple option must be an boolean"
                          );
                        const t = d.addressOptions(e),
                          n = new RegExp(
                            `\\s*[${e.separator ? s(e.separator) : ","}]\\s*`
                          );
                        return this.$_addRule({
                          name: "email",
                          args: { options: e },
                          regex: n,
                          address: t,
                        });
                      },
                      validate(e, t, n, i) {
                        let { options: r } = n,
                          { regex: a, address: s } = i;
                        const l = r.multiple ? e.split(a) : [e],
                          c = [];
                        for (const p of l) o.isValid(p, s) || c.push(p);
                        return c.length
                          ? t.error("string.email", { value: e, invalids: c })
                          : e;
                      },
                    },
                    guid: {
                      alias: "uuid",
                      method() {
                        let e =
                          arguments.length > 0 && void 0 !== arguments[0]
                            ? arguments[0]
                            : {};
                        u.assertOptions(e, ["version", "separator"]);
                        let t = "";
                        if (e.version) {
                          const n = [].concat(e.version);
                          i(
                            n.length >= 1,
                            "version must have at least 1 valid version specified"
                          );
                          const r = new Set();
                          for (let e = 0; e < n.length; ++e) {
                            const o = n[e];
                            i(
                              "string" == typeof o,
                              "version at position " + e + " must be a string"
                            );
                            const a = d.guidVersions[o.toLowerCase()];
                            i(
                              a,
                              "version at position " +
                                e +
                                " must be one of " +
                                Object.keys(d.guidVersions).join(", ")
                            ),
                              i(
                                !r.has(a),
                                "version at position " +
                                  e +
                                  " must not be a duplicate"
                              ),
                              (t += a),
                              r.add(a);
                          }
                        }
                        i(
                          d.guidSeparators.has(e.separator),
                          'separator must be one of true, false, "-", or ":"'
                        );
                        const n =
                            void 0 === e.separator
                              ? "[:-]?"
                              : !0 === e.separator
                              ? "[:-]"
                              : !1 === e.separator
                              ? "[]?"
                              : `\\${e.separator}`,
                          r = new RegExp(
                            `^([\\[{\\(]?)[0-9A-F]{8}(${n})[0-9A-F]{4}\\2?[${
                              t || "0-9A-F"
                            }][0-9A-F]{3}\\2?[${
                              t ? "89AB" : "0-9A-F"
                            }][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`,
                            "i"
                          );
                        return this.$_addRule({
                          name: "guid",
                          args: { options: e },
                          regex: r,
                        });
                      },
                      validate(e, t, n, i) {
                        let { regex: r } = i;
                        const o = r.exec(e);
                        return o
                          ? d.guidBrackets[o[1]] !== o[o.length - 1]
                            ? t.error("string.guid")
                            : e
                          : t.error("string.guid");
                      },
                    },
                    hex: {
                      method() {
                        let e =
                          arguments.length > 0 && void 0 !== arguments[0]
                            ? arguments[0]
                            : {};
                        return (
                          u.assertOptions(e, ["byteAligned"]),
                          (e = { byteAligned: !1, ...e }),
                          i(
                            "boolean" == typeof e.byteAligned,
                            "byteAligned must be boolean"
                          ),
                          this.$_addRule({ name: "hex", args: { options: e } })
                        );
                      },
                      validate(e, t, n) {
                        let { options: i } = n;
                        return d.hexRegex.test(e)
                          ? i.byteAligned && e.length % 2 != 0
                            ? t.error("string.hexAlign")
                            : e
                          : t.error("string.hex");
                      },
                    },
                    hostname: {
                      method() {
                        return this.$_addRule("hostname");
                      },
                      validate: (e, t) =>
                        r.isValid(e, { minDomainSegments: 1 }) ||
                        d.ipRegex.test(e)
                          ? e
                          : t.error("string.hostname"),
                    },
                    insensitive: {
                      method() {
                        return this.$_setFlag("insensitive", !0);
                      },
                    },
                    ip: {
                      method() {
                        let e =
                          arguments.length > 0 && void 0 !== arguments[0]
                            ? arguments[0]
                            : {};
                        u.assertOptions(e, ["cidr", "version"]);
                        const { cidr: t, versions: n, regex: i } = a.regex(e),
                          r = e.version ? n : void 0;
                        return this.$_addRule({
                          name: "ip",
                          args: { options: { cidr: t, version: r } },
                          regex: i,
                        });
                      },
                      validate(e, t, n, i) {
                        let { options: r } = n,
                          { regex: o } = i;
                        return o.test(e)
                          ? e
                          : r.version
                          ? t.error("string.ipVersion", {
                              value: e,
                              cidr: r.cidr,
                              version: r.version,
                            })
                          : t.error("string.ip", { value: e, cidr: r.cidr });
                      },
                    },
                    isoDate: {
                      method() {
                        return this.$_addRule("isoDate");
                      },
                      validate(e, t) {
                        let { error: n } = t;
                        return d.isoDate(e) ? e : n("string.isoDate");
                      },
                    },
                    isoDuration: {
                      method() {
                        return this.$_addRule("isoDuration");
                      },
                      validate: (e, t) =>
                        d.isoDurationRegex.test(e)
                          ? e
                          : t.error("string.isoDuration"),
                    },
                    length: {
                      method(e, t) {
                        return d.length(this, "length", e, "=", t);
                      },
                      validate(e, t, n, i) {
                        let { limit: r, encoding: o } = n,
                          { name: a, operator: s, args: l } = i;
                        const c = !o && e.length;
                        return u.compare(c, r, s)
                          ? e
                          : t.error("string." + a, {
                              limit: l.limit,
                              value: e,
                              encoding: o,
                            });
                      },
                      args: [
                        {
                          name: "limit",
                          ref: !0,
                          assert: u.limit,
                          message: "must be a positive integer",
                        },
                        "encoding",
                      ],
                    },
                    lowercase: {
                      method() {
                        return this.case("lower");
                      },
                    },
                    max: {
                      method(e, t) {
                        return d.length(this, "max", e, "<=", t);
                      },
                      args: ["limit", "encoding"],
                    },
                    min: {
                      method(e, t) {
                        return d.length(this, "min", e, ">=", t);
                      },
                      args: ["limit", "encoding"],
                    },
                    normalize: {
                      method() {
                        let e =
                          arguments.length > 0 && void 0 !== arguments[0]
                            ? arguments[0]
                            : "NFC";
                        return (
                          i(
                            d.normalizationForms.includes(e),
                            "normalization form must be one of " +
                              d.normalizationForms.join(", ")
                          ),
                          this.$_addRule({
                            name: "normalize",
                            args: { form: e },
                          })
                        );
                      },
                      validate(e, t, n) {
                        let { error: i } = t,
                          { form: r } = n;
                        return e === e.normalize(r)
                          ? e
                          : i("string.normalize", { value: e, form: r });
                      },
                      convert: !0,
                    },
                    pattern: {
                      alias: "regex",
                      method(e) {
                        let t =
                          arguments.length > 1 && void 0 !== arguments[1]
                            ? arguments[1]
                            : {};
                        i(e instanceof RegExp, "regex must be a RegExp"),
                          i(
                            !e.flags.includes("g") && !e.flags.includes("y"),
                            "regex should not use global or sticky mode"
                          ),
                          "string" == typeof t && (t = { name: t }),
                          u.assertOptions(t, ["invert", "name"]);
                        const n = [
                          "string.pattern",
                          t.invert ? ".invert" : "",
                          t.name ? ".name" : ".base",
                        ].join("");
                        return this.$_addRule({
                          name: "pattern",
                          args: { regex: e, options: t },
                          errorCode: n,
                        });
                      },
                      validate(e, t, n, i) {
                        let { regex: r, options: o } = n,
                          { errorCode: a } = i;
                        return r.test(e) ^ o.invert
                          ? e
                          : t.error(a, { name: o.name, regex: r, value: e });
                      },
                      args: ["regex", "options"],
                      multi: !0,
                    },
                    replace: {
                      method(e, t) {
                        "string" == typeof e && (e = new RegExp(s(e), "g")),
                          i(e instanceof RegExp, "pattern must be a RegExp"),
                          i(
                            "string" == typeof t,
                            "replacement must be a String"
                          );
                        const n = this.clone();
                        return (
                          n.$_terms.replacements ||
                            (n.$_terms.replacements = []),
                          n.$_terms.replacements.push({
                            pattern: e,
                            replacement: t,
                          }),
                          n
                        );
                      },
                    },
                    token: {
                      method() {
                        return this.$_addRule("token");
                      },
                      validate: (e, t) =>
                        /^\w+$/.test(e) ? e : t.error("string.token"),
                    },
                    trim: {
                      method() {
                        let e =
                          !(arguments.length > 0 && void 0 !== arguments[0]) ||
                          arguments[0];
                        return (
                          i("boolean" == typeof e, "enabled must be a boolean"),
                          this.$_addRule({ name: "trim", args: { enabled: e } })
                        );
                      },
                      validate(e, t, n) {
                        let { enabled: i } = n;
                        return i && e !== e.trim() ? t.error("string.trim") : e;
                      },
                      convert: !0,
                    },
                    truncate: {
                      method() {
                        let e =
                          !(arguments.length > 0 && void 0 !== arguments[0]) ||
                          arguments[0];
                        return (
                          i("boolean" == typeof e, "enabled must be a boolean"),
                          this.$_setFlag("truncate", e)
                        );
                      },
                    },
                    uppercase: {
                      method() {
                        return this.case("upper");
                      },
                    },
                    uri: {
                      method() {
                        let e =
                          arguments.length > 0 && void 0 !== arguments[0]
                            ? arguments[0]
                            : {};
                        u.assertOptions(e, [
                          "allowRelative",
                          "allowQuerySquareBrackets",
                          "domain",
                          "relativeOnly",
                          "scheme",
                        ]),
                          e.domain &&
                            u.assertOptions(e.domain, [
                              "allowFullyQualified",
                              "allowUnicode",
                              "maxDomainSegments",
                              "minDomainSegments",
                              "tlds",
                            ]);
                        const { regex: t, scheme: n } = c.regex(e),
                          i = e.domain ? d.addressOptions(e.domain) : null;
                        return this.$_addRule({
                          name: "uri",
                          args: { options: e },
                          regex: t,
                          domain: i,
                          scheme: n,
                        });
                      },
                      validate(e, t, n, i) {
                        let { options: o } = n,
                          { regex: a, domain: s, scheme: l } = i;
                        if (["http:/", "https:/"].includes(e))
                          return t.error("string.uri");
                        const c = a.exec(e);
                        if (c) {
                          const n = c[1] || c[2];
                          return !s ||
                            (o.allowRelative && !n) ||
                            r.isValid(n, s)
                            ? e
                            : t.error("string.domain", { value: n });
                        }
                        return o.relativeOnly
                          ? t.error("string.uriRelativeOnly")
                          : o.scheme
                          ? t.error("string.uriCustomScheme", {
                              scheme: l,
                              value: e,
                            })
                          : t.error("string.uri");
                      },
                    },
                  },
                  manifest: {
                    build(e, t) {
                      if (t.replacements)
                        for (const {
                          pattern: n,
                          replacement: i,
                        } of t.replacements)
                          e = e.replace(n, i);
                      return e;
                    },
                  },
                  messages: {
                    "string.alphanum":
                      "{{#label}} must only contain alpha-numeric characters",
                    "string.base": "{{#label}} must be a string",
                    "string.base64": "{{#label}} must be a valid base64 string",
                    "string.creditCard": "{{#label}} must be a credit card",
                    "string.dataUri":
                      "{{#label}} must be a valid dataUri string",
                    "string.domain":
                      "{{#label}} must contain a valid domain name",
                    "string.email": "{{#label}} must be a valid email",
                    "string.empty": "{{#label}} is not allowed to be empty",
                    "string.guid": "{{#label}} must be a valid GUID",
                    "string.hex":
                      "{{#label}} must only contain hexadecimal characters",
                    "string.hexAlign":
                      "{{#label}} hex decoded representation must be byte aligned",
                    "string.hostname": "{{#label}} must be a valid hostname",
                    "string.ip":
                      "{{#label}} must be a valid ip address with a {{#cidr}} CIDR",
                    "string.ipVersion":
                      "{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR",
                    "string.isoDate": "{{#label}} must be in iso format",
                    "string.isoDuration":
                      "{{#label}} must be a valid ISO 8601 duration",
                    "string.length":
                      "{{#label}} length must be {{#limit}} characters long",
                    "string.lowercase":
                      "{{#label}} must only contain lowercase characters",
                    "string.max":
                      "{{#label}} length must be less than or equal to {{#limit}} characters long",
                    "string.min":
                      "{{#label}} length must be at least {{#limit}} characters long",
                    "string.normalize":
                      "{{#label}} must be unicode normalized in the {{#form}} form",
                    "string.token":
                      "{{#label}} must only contain alpha-numeric and underscore characters",
                    "string.pattern.base":
                      "{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}",
                    "string.pattern.name":
                      "{{#label}} with value {:[.]} fails to match the {{#name}} pattern",
                    "string.pattern.invert.base":
                      "{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}",
                    "string.pattern.invert.name":
                      "{{#label}} with value {:[.]} matches the inverted {{#name}} pattern",
                    "string.trim":
                      "{{#label}} must not have leading or trailing whitespace",
                    "string.uri": "{{#label}} must be a valid uri",
                    "string.uriCustomScheme":
                      "{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern",
                    "string.uriRelativeOnly":
                      "{{#label}} must be a valid relative uri",
                    "string.uppercase":
                      "{{#label}} must only contain uppercase characters",
                  },
                })),
                  (d.addressOptions = function (e) {
                    if (!e) return e;
                    if (
                      (i(
                        void 0 === e.minDomainSegments ||
                          (Number.isSafeInteger(e.minDomainSegments) &&
                            e.minDomainSegments > 0),
                        "minDomainSegments must be a positive integer"
                      ),
                      i(
                        void 0 === e.maxDomainSegments ||
                          (Number.isSafeInteger(e.maxDomainSegments) &&
                            e.maxDomainSegments > 0),
                        "maxDomainSegments must be a positive integer"
                      ),
                      !1 === e.tlds)
                    )
                      return e;
                    if (!0 === e.tlds || void 0 === e.tlds)
                      return (
                        i(d.tlds, "Built-in TLD list disabled"),
                        Object.assign({}, e, d.tlds)
                      );
                    i(
                      "object" == typeof e.tlds,
                      "tlds must be true, false, or an object"
                    );
                    const t = e.tlds.deny;
                    if (t)
                      return (
                        Array.isArray(t) &&
                          (e = Object.assign({}, e, {
                            tlds: { deny: new Set(t) },
                          })),
                        i(
                          e.tlds.deny instanceof Set,
                          "tlds.deny must be an array, Set, or boolean"
                        ),
                        i(
                          !e.tlds.allow,
                          "Cannot specify both tlds.allow and tlds.deny lists"
                        ),
                        d.validateTlds(e.tlds.deny, "tlds.deny"),
                        e
                      );
                    const n = e.tlds.allow;
                    return n
                      ? !0 === n
                        ? (i(d.tlds, "Built-in TLD list disabled"),
                          Object.assign({}, e, d.tlds))
                        : (Array.isArray(n) &&
                            (e = Object.assign({}, e, {
                              tlds: { allow: new Set(n) },
                            })),
                          i(
                            e.tlds.allow instanceof Set,
                            "tlds.allow must be an array, Set, or boolean"
                          ),
                          d.validateTlds(e.tlds.allow, "tlds.allow"),
                          e)
                      : e;
                  }),
                  (d.validateTlds = function (e, t) {
                    for (const n of e)
                      i(
                        r.isValid(n, {
                          minDomainSegments: 1,
                          maxDomainSegments: 1,
                        }),
                        `${t} must contain valid top level domain names`
                      );
                  }),
                  (d.isoDate = function (e) {
                    if (!u.isIsoDate(e)) return null;
                    /.*T.*[+-]\d\d$/.test(e) && (e += "00");
                    const t = new Date(e);
                    return isNaN(t.getTime()) ? null : t.toISOString();
                  }),
                  (d.length = function (e, t, n, r, o) {
                    return (
                      i(!o || !1, "Invalid encoding:", o),
                      e.$_addRule({
                        name: t,
                        method: "length",
                        args: { limit: n, encoding: o },
                        operator: r,
                      })
                    );
                  });
              },
              8826: (e, t, n) => {
                "use strict";
                const i = n(375),
                  r = n(8068),
                  o = {};
                (o.Map = class extends Map {
                  slice() {
                    return new o.Map(this);
                  }
                }),
                  (e.exports = r.extend({
                    type: "symbol",
                    terms: { map: { init: new o.Map() } },
                    coerce: {
                      method(e, t) {
                        let { schema: n, error: i } = t;
                        const r = n.$_terms.map.get(e);
                        return (
                          r && (e = r),
                          n._flags.only && "symbol" != typeof e
                            ? {
                                value: e,
                                errors: i("symbol.map", { map: n.$_terms.map }),
                              }
                            : { value: e }
                        );
                      },
                    },
                    validate(e, t) {
                      let { error: n } = t;
                      if ("symbol" != typeof e)
                        return { value: e, errors: n("symbol.base") };
                    },
                    rules: {
                      map: {
                        method(e) {
                          e &&
                            !e[Symbol.iterator] &&
                            "object" == typeof e &&
                            (e = Object.entries(e)),
                            i(
                              e && e[Symbol.iterator],
                              "Iterable must be an iterable or object"
                            );
                          const t = this.clone(),
                            n = [];
                          for (const r of e) {
                            i(
                              r && r[Symbol.iterator],
                              "Entry must be an iterable"
                            );
                            const [e, o] = r;
                            i(
                              "object" != typeof e &&
                                "function" != typeof e &&
                                "symbol" != typeof e,
                              "Key must not be of type object, function, or Symbol"
                            ),
                              i("symbol" == typeof o, "Value must be a Symbol"),
                              t.$_terms.map.set(e, o),
                              n.push(o);
                          }
                          return t.valid(...n);
                        },
                      },
                    },
                    manifest: {
                      build: (e, t) => (t.map && (e = e.map(t.map)), e),
                    },
                    messages: {
                      "symbol.base": "{{#label}} must be a symbol",
                      "symbol.map": "{{#label}} must be one of {{#map}}",
                    },
                  }));
              },
              8863: (e, t, n) => {
                "use strict";
                const i = n(375),
                  r = n(8571),
                  o = n(738),
                  a = n(9621),
                  s = n(8160),
                  l = n(6354),
                  c = n(493),
                  p = { result: Symbol("result") };
                (t.entry = function (e, t, n) {
                  let r = s.defaults;
                  n &&
                    (i(
                      void 0 === n.warnings,
                      "Cannot override warnings preference in synchronous validation"
                    ),
                    i(
                      void 0 === n.artifacts,
                      "Cannot override artifacts preference in synchronous validation"
                    ),
                    (r = s.preferences(s.defaults, n)));
                  const o = p.entry(e, t, r);
                  i(
                    !o.mainstay.externals.length,
                    "Schema with external rules must use validateAsync()"
                  );
                  const a = { value: o.value };
                  return (
                    o.error && (a.error = o.error),
                    o.mainstay.warnings.length &&
                      (a.warning = l.details(o.mainstay.warnings)),
                    o.mainstay.debug && (a.debug = o.mainstay.debug),
                    o.mainstay.artifacts &&
                      (a.artifacts = o.mainstay.artifacts),
                    a
                  );
                }),
                  (t.entryAsync = async function (e, t, n) {
                    let i = s.defaults;
                    n && (i = s.preferences(s.defaults, n));
                    const r = p.entry(e, t, i),
                      o = r.mainstay;
                    if (r.error)
                      throw (o.debug && (r.error.debug = o.debug), r.error);
                    if (o.externals.length) {
                      let t = r.value;
                      for (const {
                        method: r,
                        path: s,
                        label: l,
                      } of o.externals) {
                        let o,
                          c,
                          p = t;
                        s.length &&
                          ((o = s[s.length - 1]),
                          (c = a(t, s.slice(0, -1))),
                          (p = c[o]));
                        try {
                          const e = await r(p, { prefs: n });
                          if (void 0 === e || e === p) continue;
                          c ? (c[o] = e) : (t = e);
                        } catch (e) {
                          throw (i.errors.label && (e.message += ` (${l})`), e);
                        }
                      }
                      r.value = t;
                    }
                    if (!i.warnings && !i.debug && !i.artifacts) return r.value;
                    const c = { value: r.value };
                    return (
                      o.warnings.length && (c.warning = l.details(o.warnings)),
                      o.debug && (c.debug = o.debug),
                      o.artifacts && (c.artifacts = o.artifacts),
                      c
                    );
                  }),
                  (p.entry = function (e, n, i) {
                    const { tracer: r, cleanup: o } = p.tracer(n, i),
                      a = {
                        externals: [],
                        warnings: [],
                        tracer: r,
                        debug: i.debug ? [] : null,
                        links: n._ids._schemaChain ? new Map() : null,
                      },
                      s = n._ids._schemaChain ? [{ schema: n }] : null,
                      u = new c([], [], { mainstay: a, schemas: s }),
                      d = t.validate(e, n, u, i);
                    o && n.$_root.untrace();
                    const m = l.process(d.errors, e, i);
                    return { value: d.value, error: m, mainstay: a };
                  }),
                  (p.tracer = function (e, t) {
                    return e.$_root._tracer
                      ? { tracer: e.$_root._tracer._register(e) }
                      : t.debug
                      ? (i(e.$_root.trace, "Debug mode not supported"),
                        { tracer: e.$_root.trace()._register(e), cleanup: !0 })
                      : { tracer: p.ignore };
                  }),
                  (t.validate = function (e, t, n, i) {
                    let r =
                      arguments.length > 4 && void 0 !== arguments[4]
                        ? arguments[4]
                        : {};
                    if (
                      (t.$_terms.whens && (t = t._generate(e, n, i).schema),
                      t._preferences && (i = p.prefs(t, i)),
                      t._cache && i.cache)
                    ) {
                      const i = t._cache.get(e);
                      if (
                        (n.mainstay.tracer.debug(n, "validate", "cached", !!i),
                        i)
                      )
                        return i;
                    }
                    const o = (r, o, a) => t.$_createError(r, e, o, a || n, i),
                      a = {
                        original: e,
                        prefs: i,
                        schema: t,
                        state: n,
                        error: o,
                        errorsArray: p.errorsArray,
                        warn: (e, t, i) => n.mainstay.warnings.push(o(e, t, i)),
                        message: (r, o) =>
                          t.$_createError("custom", e, o, n, i, {
                            messages: r,
                          }),
                      };
                    n.mainstay.tracer.entry(t, n);
                    const l = t._definition;
                    if (l.prepare && void 0 !== e && i.convert) {
                      const t = l.prepare(e, a);
                      if (t) {
                        if (
                          (n.mainstay.tracer.value(n, "prepare", e, t.value),
                          t.errors)
                        )
                          return p.finalize(t.value, [].concat(t.errors), a);
                        e = t.value;
                      }
                    }
                    if (
                      l.coerce &&
                      void 0 !== e &&
                      i.convert &&
                      (!l.coerce.from || l.coerce.from.includes(typeof e))
                    ) {
                      const t = l.coerce.method(e, a);
                      if (t) {
                        if (
                          (n.mainstay.tracer.value(n, "coerced", e, t.value),
                          t.errors)
                        )
                          return p.finalize(t.value, [].concat(t.errors), a);
                        e = t.value;
                      }
                    }
                    const c = t._flags.empty;
                    c &&
                      c.$_match(p.trim(e, t), n.nest(c), s.defaults) &&
                      (n.mainstay.tracer.value(n, "empty", e, void 0),
                      (e = void 0));
                    const u =
                      r.presence ||
                      t._flags.presence ||
                      (t._flags._endedSwitch ? null : i.presence);
                    if (void 0 === e) {
                      if ("forbidden" === u) return p.finalize(e, null, a);
                      if ("required" === u)
                        return p.finalize(
                          e,
                          [t.$_createError("any.required", e, null, n, i)],
                          a
                        );
                      if ("optional" === u) {
                        if (t._flags.default !== s.symbols.deepDefault)
                          return p.finalize(e, null, a);
                        n.mainstay.tracer.value(n, "default", e, {}), (e = {});
                      }
                    } else if ("forbidden" === u)
                      return p.finalize(
                        e,
                        [t.$_createError("any.unknown", e, null, n, i)],
                        a
                      );
                    const d = [];
                    if (t._valids) {
                      const r = t._valids.get(e, n, i, t._flags.insensitive);
                      if (r)
                        return (
                          i.convert &&
                            (n.mainstay.tracer.value(n, "valids", e, r.value),
                            (e = r.value)),
                          n.mainstay.tracer.filter(t, n, "valid", r),
                          p.finalize(e, null, a)
                        );
                      if (t._flags.only) {
                        const r = t.$_createError(
                          "any.only",
                          e,
                          { valids: t._valids.values({ display: !0 }) },
                          n,
                          i
                        );
                        if (i.abortEarly) return p.finalize(e, [r], a);
                        d.push(r);
                      }
                    }
                    if (t._invalids) {
                      const r = t._invalids.get(e, n, i, t._flags.insensitive);
                      if (r) {
                        n.mainstay.tracer.filter(t, n, "invalid", r);
                        const o = t.$_createError(
                          "any.invalid",
                          e,
                          { invalids: t._invalids.values({ display: !0 }) },
                          n,
                          i
                        );
                        if (i.abortEarly) return p.finalize(e, [o], a);
                        d.push(o);
                      }
                    }
                    if (l.validate) {
                      const t = l.validate(e, a);
                      if (
                        t &&
                        (n.mainstay.tracer.value(n, "base", e, t.value),
                        (e = t.value),
                        t.errors)
                      ) {
                        if (!Array.isArray(t.errors))
                          return d.push(t.errors), p.finalize(e, d, a);
                        if (t.errors.length)
                          return d.push(...t.errors), p.finalize(e, d, a);
                      }
                    }
                    return t._rules.length
                      ? p.rules(e, d, a)
                      : p.finalize(e, d, a);
                  }),
                  (p.rules = function (e, t, n) {
                    const { schema: i, state: r, prefs: o } = n;
                    for (const a of i._rules) {
                      const l = i._definition.rules[a.method];
                      if (l.convert && o.convert) {
                        r.mainstay.tracer.log(i, r, "rule", a.name, "full");
                        continue;
                      }
                      let c,
                        u = a.args;
                      if (a._resolve.length) {
                        u = Object.assign({}, u);
                        for (const t of a._resolve) {
                          const n = l.argsByName.get(t),
                            a = u[t].resolve(e, r, o),
                            p = n.normalize ? n.normalize(a) : a,
                            d = s.validateArg(p, null, n);
                          if (d) {
                            c = i.$_createError(
                              "any.ref",
                              a,
                              { arg: t, ref: u[t], reason: d },
                              r,
                              o
                            );
                            break;
                          }
                          u[t] = p;
                        }
                      }
                      c = c || l.validate(e, n, u, a);
                      const d = p.rule(c, a);
                      if (d.errors) {
                        if (
                          (r.mainstay.tracer.log(i, r, "rule", a.name, "error"),
                          a.warn)
                        ) {
                          r.mainstay.warnings.push(...d.errors);
                          continue;
                        }
                        if (o.abortEarly) return p.finalize(e, d.errors, n);
                        t.push(...d.errors);
                      } else
                        r.mainstay.tracer.log(i, r, "rule", a.name, "pass"),
                          r.mainstay.tracer.value(
                            r,
                            "rule",
                            e,
                            d.value,
                            a.name
                          ),
                          (e = d.value);
                    }
                    return p.finalize(e, t, n);
                  }),
                  (p.rule = function (e, t) {
                    return e instanceof l.Report
                      ? (p.error(e, t), { errors: [e], value: null })
                      : Array.isArray(e) && e[s.symbols.errors]
                      ? (e.forEach((e) => p.error(e, t)),
                        { errors: e, value: null })
                      : { errors: null, value: e };
                  }),
                  (p.error = function (e, t) {
                    return t.message && e._setTemplate(t.message), e;
                  }),
                  (p.finalize = function (e, t, n) {
                    t = t || [];
                    const { schema: r, state: o, prefs: a } = n;
                    if (t.length) {
                      const i = p.default("failover", void 0, t, n);
                      void 0 !== i &&
                        (o.mainstay.tracer.value(o, "failover", e, i),
                        (e = i),
                        (t = []));
                    }
                    if (t.length && r._flags.error)
                      if ("function" == typeof r._flags.error) {
                        (t = r._flags.error(t)), Array.isArray(t) || (t = [t]);
                        for (const e of t)
                          i(
                            e instanceof Error || e instanceof l.Report,
                            "error() must return an Error object"
                          );
                      } else t = [r._flags.error];
                    if (void 0 === e) {
                      const i = p.default("default", e, t, n);
                      o.mainstay.tracer.value(o, "default", e, i), (e = i);
                    }
                    if (r._flags.cast && void 0 !== e) {
                      const t = r._definition.cast[r._flags.cast];
                      if (t.from(e)) {
                        const i = t.to(e, n);
                        o.mainstay.tracer.value(o, "cast", e, i, r._flags.cast),
                          (e = i);
                      }
                    }
                    if (
                      r.$_terms.externals &&
                      a.externals &&
                      !1 !== a._externals
                    )
                      for (const { method: i } of r.$_terms.externals)
                        o.mainstay.externals.push({
                          method: i,
                          path: o.path,
                          label: l.label(r._flags, o, a),
                        });
                    const s = { value: e, errors: t.length ? t : null };
                    return (
                      r._flags.result &&
                        ((s.value =
                          "strip" === r._flags.result ? void 0 : n.original),
                        o.mainstay.tracer.value(o, r._flags.result, e, s.value),
                        o.shadow(e, r._flags.result)),
                      r._cache &&
                        !1 !== a.cache &&
                        !r._refs.length &&
                        r._cache.set(n.original, s),
                      void 0 === e ||
                        s.errors ||
                        void 0 === r._flags.artifact ||
                        ((o.mainstay.artifacts =
                          o.mainstay.artifacts || new Map()),
                        o.mainstay.artifacts.has(r._flags.artifact) ||
                          o.mainstay.artifacts.set(r._flags.artifact, []),
                        o.mainstay.artifacts
                          .get(r._flags.artifact)
                          .push(o.path)),
                      s
                    );
                  }),
                  (p.prefs = function (e, t) {
                    const n = t === s.defaults;
                    return n && e._preferences[s.symbols.prefs]
                      ? e._preferences[s.symbols.prefs]
                      : ((t = s.preferences(t, e._preferences)),
                        n && (e._preferences[s.symbols.prefs] = t),
                        t);
                  }),
                  (p.default = function (e, t, n, i) {
                    const { schema: o, state: a, prefs: l } = i,
                      c = o._flags[e];
                    if (l.noDefaults || void 0 === c) return t;
                    if ((a.mainstay.tracer.log(o, a, "rule", e, "full"), !c))
                      return c;
                    if ("function" == typeof c) {
                      const s = c.length ? [r(a.ancestors[0]), i] : [];
                      try {
                        return c(...s);
                      } catch (t) {
                        return void n.push(
                          o.$_createError(`any.${e}`, null, { error: t }, a, l)
                        );
                      }
                    }
                    return "object" != typeof c
                      ? c
                      : c[s.symbols.literal]
                      ? c.literal
                      : s.isResolvable(c)
                      ? c.resolve(t, a, l)
                      : r(c);
                  }),
                  (p.trim = function (e, t) {
                    if ("string" != typeof e) return e;
                    const n = t.$_getRule("trim");
                    return n && n.args.enabled ? e.trim() : e;
                  }),
                  (p.ignore = {
                    active: !1,
                    debug: o,
                    entry: o,
                    filter: o,
                    log: o,
                    resolve: o,
                    value: o,
                  }),
                  (p.errorsArray = function () {
                    const e = [];
                    return (e[s.symbols.errors] = !0), e;
                  });
              },
              2036: (e, t, n) => {
                "use strict";
                const i = n(375),
                  r = n(9474),
                  o = n(8160),
                  a = {};
                (e.exports = a.Values =
                  class {
                    constructor(e, t) {
                      (this._values = new Set(e)),
                        (this._refs = new Set(t)),
                        (this._lowercase = a.lowercases(e)),
                        (this._override = !1);
                    }
                    get length() {
                      return this._values.size + this._refs.size;
                    }
                    add(e, t) {
                      o.isResolvable(e)
                        ? this._refs.has(e) ||
                          (this._refs.add(e), t && t.register(e))
                        : this.has(e, null, null, !1) ||
                          (this._values.add(e),
                          "string" == typeof e &&
                            this._lowercase.set(e.toLowerCase(), e));
                    }
                    static merge(e, t, n) {
                      if (((e = e || new a.Values()), t)) {
                        if (t._override) return t.clone();
                        for (const n of [...t._values, ...t._refs]) e.add(n);
                      }
                      if (n)
                        for (const i of [...n._values, ...n._refs]) e.remove(i);
                      return e.length ? e : null;
                    }
                    remove(e) {
                      o.isResolvable(e)
                        ? this._refs.delete(e)
                        : (this._values.delete(e),
                          "string" == typeof e &&
                            this._lowercase.delete(e.toLowerCase()));
                    }
                    has(e, t, n, i) {
                      return !!this.get(e, t, n, i);
                    }
                    get(e, t, n, i) {
                      if (!this.length) return !1;
                      if (this._values.has(e)) return { value: e };
                      if ("string" == typeof e && e && i) {
                        const t = this._lowercase.get(e.toLowerCase());
                        if (t) return { value: t };
                      }
                      if (!this._refs.size && "object" != typeof e) return !1;
                      if ("object" == typeof e)
                        for (const o of this._values)
                          if (r(o, e)) return { value: o };
                      if (t)
                        for (const o of this._refs) {
                          const a = o.resolve(e, t, n, null, { in: !0 });
                          if (void 0 === a) continue;
                          const s =
                            o.in && "object" == typeof a
                              ? Array.isArray(a)
                                ? a
                                : Object.keys(a)
                              : [a];
                          for (const t of s)
                            if (typeof t == typeof e)
                              if (i && e && "string" == typeof e) {
                                if (t.toLowerCase() === e.toLowerCase())
                                  return { value: t, ref: o };
                              } else if (r(t, e)) return { value: t, ref: o };
                        }
                      return !1;
                    }
                    override() {
                      this._override = !0;
                    }
                    values(e) {
                      if (e && e.display) {
                        const e = [];
                        for (const t of [...this._values, ...this._refs])
                          void 0 !== t && e.push(t);
                        return e;
                      }
                      return Array.from([...this._values, ...this._refs]);
                    }
                    clone() {
                      const e = new a.Values(this._values, this._refs);
                      return (e._override = this._override), e;
                    }
                    concat(e) {
                      i(!e._override, "Cannot concat override set of values");
                      const t = new a.Values(
                        [...this._values, ...e._values],
                        [...this._refs, ...e._refs]
                      );
                      return (t._override = this._override), t;
                    }
                    describe() {
                      const e = [];
                      this._override && e.push({ override: !0 });
                      for (const t of this._values.values())
                        e.push(t && "object" == typeof t ? { value: t } : t);
                      for (const t of this._refs.values()) e.push(t.describe());
                      return e;
                    }
                  }),
                  (a.Values.prototype[o.symbols.values] = !0),
                  (a.Values.prototype.slice = a.Values.prototype.clone),
                  (a.lowercases = function (e) {
                    const t = new Map();
                    if (e)
                      for (const n of e)
                        "string" == typeof n && t.set(n.toLowerCase(), n);
                    return t;
                  });
              },
              978: (e, t, n) => {
                "use strict";
                const i = n(375),
                  r = n(8571),
                  o = n(1687),
                  a = n(9621),
                  s = {};
                (e.exports = function (e, t) {
                  let n =
                    arguments.length > 2 && void 0 !== arguments[2]
                      ? arguments[2]
                      : {};
                  if (
                    (i(
                      e && "object" == typeof e,
                      "Invalid defaults value: must be an object"
                    ),
                    i(
                      !t || !0 === t || "object" == typeof t,
                      "Invalid source value: must be true, falsy or an object"
                    ),
                    i(
                      "object" == typeof n,
                      "Invalid options: must be an object"
                    ),
                    !t)
                  )
                    return null;
                  if (n.shallow) return s.applyToDefaultsWithShallow(e, t, n);
                  const a = r(e);
                  if (!0 === t) return a;
                  const l = void 0 !== n.nullOverride && n.nullOverride;
                  return o(a, t, { nullOverride: l, mergeArrays: !1 });
                }),
                  (s.applyToDefaultsWithShallow = function (e, t, n) {
                    const l = n.shallow;
                    i(Array.isArray(l), "Invalid keys");
                    const c = new Map(),
                      p = !0 === t ? null : new Set();
                    for (let i of l) {
                      i = Array.isArray(i) ? i : i.split(".");
                      const n = a(e, i);
                      n && "object" == typeof n
                        ? c.set(n, (p && a(t, i)) || n)
                        : p && p.add(i);
                    }
                    const u = r(e, {}, c);
                    if (!p) return u;
                    for (const i of p) s.reachCopy(u, t, i);
                    const d = void 0 !== n.nullOverride && n.nullOverride;
                    return o(u, t, { nullOverride: d, mergeArrays: !1 });
                  }),
                  (s.reachCopy = function (e, t, n) {
                    for (const o of n) {
                      if (!(o in t)) return;
                      const e = t[o];
                      if ("object" != typeof e || null === e) return;
                      t = e;
                    }
                    const i = t;
                    let r = e;
                    for (let o = 0; o < n.length - 1; ++o) {
                      const e = n[o];
                      "object" != typeof r[e] && (r[e] = {}), (r = r[e]);
                    }
                    r[n[n.length - 1]] = i;
                  });
              },
              375: (e, t, n) => {
                "use strict";
                const i = n(7916);
                e.exports = function (e) {
                  if (!e) {
                    for (
                      var t = arguments.length,
                        n = new Array(t > 1 ? t - 1 : 0),
                        r = 1;
                      r < t;
                      r++
                    )
                      n[r - 1] = arguments[r];
                    if (1 === n.length && n[0] instanceof Error) throw n[0];
                    throw new i(n);
                  }
                };
              },
              8571: (e, t, n) => {
                "use strict";
                const i = n(9621),
                  r = n(4277),
                  o = n(7043),
                  a = {
                    needsProtoHack: new Set([
                      r.set,
                      r.map,
                      r.weakSet,
                      r.weakMap,
                    ]),
                  };
                (e.exports = a.clone =
                  function (e) {
                    let t =
                        arguments.length > 1 && void 0 !== arguments[1]
                          ? arguments[1]
                          : {},
                      n =
                        arguments.length > 2 && void 0 !== arguments[2]
                          ? arguments[2]
                          : null;
                    if ("object" != typeof e || null === e) return e;
                    let i = a.clone,
                      s = n;
                    if (t.shallow) {
                      if (!0 !== t.shallow) return a.cloneWithShallow(e, t);
                      i = (e) => e;
                    } else if (s) {
                      const t = s.get(e);
                      if (t) return t;
                    } else s = new Map();
                    const l = r.getInternalProto(e);
                    if (l === r.buffer) return !1;
                    if (l === r.date) return new Date(e.getTime());
                    if (l === r.regex) return new RegExp(e);
                    const c = a.base(e, l, t);
                    if (c === e) return e;
                    if ((s && s.set(e, c), l === r.set))
                      for (const r of e) c.add(i(r, t, s));
                    else if (l === r.map)
                      for (const [r, o] of e) c.set(r, i(o, t, s));
                    const p = o.keys(e, t);
                    for (const o of p) {
                      if ("__proto__" === o) continue;
                      if (l === r.array && "length" === o) {
                        c.length = e.length;
                        continue;
                      }
                      const n = Object.getOwnPropertyDescriptor(e, o);
                      n
                        ? n.get || n.set
                          ? Object.defineProperty(c, o, n)
                          : n.enumerable
                          ? (c[o] = i(e[o], t, s))
                          : Object.defineProperty(c, o, {
                              enumerable: !1,
                              writable: !0,
                              configurable: !0,
                              value: i(e[o], t, s),
                            })
                        : Object.defineProperty(c, o, {
                            enumerable: !0,
                            writable: !0,
                            configurable: !0,
                            value: i(e[o], t, s),
                          });
                    }
                    return c;
                  }),
                  (a.cloneWithShallow = function (e, t) {
                    const n = t.shallow;
                    (t = Object.assign({}, t)).shallow = !1;
                    const r = new Map();
                    for (const o of n) {
                      const t = i(e, o);
                      ("object" != typeof t && "function" != typeof t) ||
                        r.set(t, t);
                    }
                    return a.clone(e, t, r);
                  }),
                  (a.base = function (e, t, n) {
                    if (!1 === n.prototype)
                      return a.needsProtoHack.has(t)
                        ? new t.constructor()
                        : t === r.array
                        ? []
                        : {};
                    const i = Object.getPrototypeOf(e);
                    if (i && i.isImmutable) return e;
                    if (t === r.array) {
                      const e = [];
                      return i !== t && Object.setPrototypeOf(e, i), e;
                    }
                    if (a.needsProtoHack.has(t)) {
                      const e = new i.constructor();
                      return i !== t && Object.setPrototypeOf(e, i), e;
                    }
                    return Object.create(i);
                  });
              },
              9474: (e, t, n) => {
                "use strict";
                const i = n(4277),
                  r = { mismatched: null };
                (e.exports = function (e, t, n) {
                  return (
                    (n = Object.assign({ prototype: !0 }, n)),
                    !!r.isDeepEqual(e, t, n, [])
                  );
                }),
                  (r.isDeepEqual = function (e, t, n, o) {
                    if (e === t) return 0 !== e || 1 / e == 1 / t;
                    const a = typeof e;
                    if (a !== typeof t) return !1;
                    if (null === e || null === t) return !1;
                    if ("function" === a) {
                      if (!n.deepFunction || e.toString() !== t.toString())
                        return !1;
                    } else if ("object" !== a) return e != e && t != t;
                    const s = r.getSharedType(e, t, !!n.prototype);
                    switch (s) {
                      case i.buffer:
                        return !1;
                      case i.promise:
                        return e === t;
                      case i.regex:
                        return e.toString() === t.toString();
                      case r.mismatched:
                        return !1;
                    }
                    for (let i = o.length - 1; i >= 0; --i)
                      if (o[i].isSame(e, t)) return !0;
                    o.push(new r.SeenEntry(e, t));
                    try {
                      return !!r.isDeepEqualObj(s, e, t, n, o);
                    } finally {
                      o.pop();
                    }
                  }),
                  (r.getSharedType = function (e, t, n) {
                    if (n)
                      return Object.getPrototypeOf(e) !==
                        Object.getPrototypeOf(t)
                        ? r.mismatched
                        : i.getInternalProto(e);
                    const o = i.getInternalProto(e);
                    return o !== i.getInternalProto(t) ? r.mismatched : o;
                  }),
                  (r.valueOf = function (e) {
                    const t = e.valueOf;
                    if (void 0 === t) return e;
                    try {
                      return t.call(e);
                    } catch (e) {
                      return e;
                    }
                  }),
                  (r.hasOwnEnumerableProperty = function (e, t) {
                    return Object.prototype.propertyIsEnumerable.call(e, t);
                  }),
                  (r.isSetSimpleEqual = function (e, t) {
                    for (const n of Set.prototype.values.call(e))
                      if (!Set.prototype.has.call(t, n)) return !1;
                    return !0;
                  }),
                  (r.isDeepEqualObj = function (e, t, n, o, a) {
                    const {
                        isDeepEqual: s,
                        valueOf: l,
                        hasOwnEnumerableProperty: c,
                      } = r,
                      { keys: p, getOwnPropertySymbols: u } = Object;
                    if (e === i.array) {
                      if (!o.part) {
                        if (t.length !== n.length) return !1;
                        for (let e = 0; e < t.length; ++e)
                          if (!s(t[e], n[e], o, a)) return !1;
                        return !0;
                      }
                      for (const e of t)
                        for (const t of n) if (s(e, t, o, a)) return !0;
                    } else if (e === i.set) {
                      if (t.size !== n.size) return !1;
                      if (!r.isSetSimpleEqual(t, n)) {
                        const e = new Set(Set.prototype.values.call(n));
                        for (const n of Set.prototype.values.call(t)) {
                          if (e.delete(n)) continue;
                          let t = !1;
                          for (const i of e)
                            if (s(n, i, o, a)) {
                              e.delete(i), (t = !0);
                              break;
                            }
                          if (!t) return !1;
                        }
                      }
                    } else if (e === i.map) {
                      if (t.size !== n.size) return !1;
                      for (const [e, i] of Map.prototype.entries.call(t)) {
                        if (void 0 === i && !Map.prototype.has.call(n, e))
                          return !1;
                        if (!s(i, Map.prototype.get.call(n, e), o, a))
                          return !1;
                      }
                    } else if (
                      e === i.error &&
                      (t.name !== n.name || t.message !== n.message)
                    )
                      return !1;
                    const d = l(t),
                      m = l(n);
                    if ((t !== d || n !== m) && !s(d, m, o, a)) return !1;
                    const h = p(t);
                    if (!o.part && h.length !== p(n).length && !o.skip)
                      return !1;
                    let f = 0;
                    for (const i of h)
                      if (o.skip && o.skip.includes(i)) void 0 === n[i] && ++f;
                      else {
                        if (!c(n, i)) return !1;
                        if (!s(t[i], n[i], o, a)) return !1;
                      }
                    if (!o.part && h.length - f !== p(n).length) return !1;
                    if (!1 !== o.symbols) {
                      const e = u(t),
                        i = new Set(u(n));
                      for (const r of e) {
                        if (!o.skip || !o.skip.includes(r))
                          if (c(t, r)) {
                            if (!c(n, r)) return !1;
                            if (!s(t[r], n[r], o, a)) return !1;
                          } else if (c(n, r)) return !1;
                        i.delete(r);
                      }
                      for (const t of i) if (c(n, t)) return !1;
                    }
                    return !0;
                  }),
                  (r.SeenEntry = class {
                    constructor(e, t) {
                      (this.obj = e), (this.ref = t);
                    }
                    isSame(e, t) {
                      return this.obj === e && this.ref === t;
                    }
                  });
              },
              7916: (e, t, n) => {
                "use strict";
                const i = n(8761);
                e.exports = class extends Error {
                  constructor(e) {
                    super(
                      e
                        .filter((e) => "" !== e)
                        .map((e) =>
                          "string" == typeof e
                            ? e
                            : e instanceof Error
                            ? e.message
                            : i(e)
                        )
                        .join(" ") || "Unknown error"
                    ),
                      "function" == typeof Error.captureStackTrace &&
                        Error.captureStackTrace(this, t.assert);
                  }
                };
              },
              5277: (e) => {
                "use strict";
                const t = {};
                (e.exports = function (e) {
                  if (!e) return "";
                  let n = "";
                  for (let i = 0; i < e.length; ++i) {
                    const r = e.charCodeAt(i);
                    t.isSafe(r) ? (n += e[i]) : (n += t.escapeHtmlChar(r));
                  }
                  return n;
                }),
                  (t.escapeHtmlChar = function (e) {
                    return (
                      t.namedHtml.get(e) ||
                      (e >= 256
                        ? "&#" + e + ";"
                        : `&#x${e.toString(16).padStart(2, "0")};`)
                    );
                  }),
                  (t.isSafe = function (e) {
                    return t.safeCharCodes.has(e);
                  }),
                  (t.namedHtml = new Map([
                    [38, "&amp;"],
                    [60, "&lt;"],
                    [62, "&gt;"],
                    [34, "&quot;"],
                    [160, "&nbsp;"],
                    [162, "&cent;"],
                    [163, "&pound;"],
                    [164, "&curren;"],
                    [169, "&copy;"],
                    [174, "&reg;"],
                  ])),
                  (t.safeCharCodes = (function () {
                    const e = new Set();
                    for (let t = 32; t < 123; ++t)
                      (t >= 97 ||
                        (t >= 65 && t <= 90) ||
                        (t >= 48 && t <= 57) ||
                        32 === t ||
                        46 === t ||
                        44 === t ||
                        45 === t ||
                        58 === t ||
                        95 === t) &&
                        e.add(t);
                    return e;
                  })());
              },
              6064: (e) => {
                "use strict";
                e.exports = function (e) {
                  return e.replace(
                    /[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g,
                    "\\$&"
                  );
                };
              },
              738: (e) => {
                "use strict";
                e.exports = function () {};
              },
              1687: (e, t, n) => {
                "use strict";
                const i = n(375),
                  r = n(8571),
                  o = n(7043),
                  a = {};
                e.exports = a.merge = function (e, t, n) {
                  if (
                    (i(
                      e && "object" == typeof e,
                      "Invalid target value: must be an object"
                    ),
                    i(
                      null == t || "object" == typeof t,
                      "Invalid source value: must be null, undefined, or an object"
                    ),
                    !t)
                  )
                    return e;
                  if (
                    ((n = Object.assign(
                      { nullOverride: !0, mergeArrays: !0 },
                      n
                    )),
                    Array.isArray(t))
                  ) {
                    i(Array.isArray(e), "Cannot merge array onto an object"),
                      n.mergeArrays || (e.length = 0);
                    for (let i = 0; i < t.length; ++i)
                      e.push(r(t[i], { symbols: n.symbols }));
                    return e;
                  }
                  const s = o.keys(t, n);
                  for (let i = 0; i < s.length; ++i) {
                    const o = s[i];
                    if (
                      "__proto__" === o ||
                      !Object.prototype.propertyIsEnumerable.call(t, o)
                    )
                      continue;
                    const l = t[o];
                    if (l && "object" == typeof l) {
                      if (e[o] === l) continue;
                      !e[o] ||
                      "object" != typeof e[o] ||
                      Array.isArray(e[o]) !== Array.isArray(l) ||
                      l instanceof Date ||
                      l instanceof RegExp
                        ? (e[o] = r(l, { symbols: n.symbols }))
                        : a.merge(e[o], l, n);
                    } else (null != l || n.nullOverride) && (e[o] = l);
                  }
                  return e;
                };
              },
              9621: (e, t, n) => {
                "use strict";
                const i = n(375),
                  r = {};
                (e.exports = function (e, t, n) {
                  if (!1 === t || null == t) return e;
                  "string" == typeof (n = n || {}) && (n = { separator: n });
                  const o = Array.isArray(t);
                  i(
                    !o || !n.separator,
                    "Separator option is not valid for array-based chain"
                  );
                  const a = o ? t : t.split(n.separator || ".");
                  let s = e;
                  for (let l = 0; l < a.length; ++l) {
                    let e = a[l];
                    const o = n.iterables && r.iterables(s);
                    if (Array.isArray(s) || "set" === o) {
                      const t = Number(e);
                      Number.isInteger(t) && (e = t < 0 ? s.length + t : t);
                    }
                    if (
                      !s ||
                      ("function" == typeof s && !1 === n.functions) ||
                      (!o && void 0 === s[e])
                    ) {
                      i(
                        !n.strict || l + 1 === a.length,
                        "Missing segment",
                        e,
                        "in reach path ",
                        t
                      ),
                        i(
                          "object" == typeof s ||
                            !0 === n.functions ||
                            "function" != typeof s,
                          "Invalid segment",
                          e,
                          "in reach path ",
                          t
                        ),
                        (s = n.default);
                      break;
                    }
                    s = o ? ("set" === o ? [...s][e] : s.get(e)) : s[e];
                  }
                  return s;
                }),
                  (r.iterables = function (e) {
                    return e instanceof Set
                      ? "set"
                      : e instanceof Map
                      ? "map"
                      : void 0;
                  });
              },
              8761: (e) => {
                "use strict";
                e.exports = function () {
                  try {
                    return JSON.stringify(...arguments);
                  } catch (e) {
                    return "[Cannot display object: " + e.message + "]";
                  }
                };
              },
              4277: (e, t) => {
                "use strict";
                const n = {};
                (t = e.exports =
                  {
                    array: Array.prototype,
                    buffer: !1,
                    date: Date.prototype,
                    error: Error.prototype,
                    generic: Object.prototype,
                    map: Map.prototype,
                    promise: Promise.prototype,
                    regex: RegExp.prototype,
                    set: Set.prototype,
                    weakMap: WeakMap.prototype,
                    weakSet: WeakSet.prototype,
                  }),
                  (n.typeMap = new Map([
                    ["[object Error]", t.error],
                    ["[object Map]", t.map],
                    ["[object Promise]", t.promise],
                    ["[object Set]", t.set],
                    ["[object WeakMap]", t.weakMap],
                    ["[object WeakSet]", t.weakSet],
                  ])),
                  (t.getInternalProto = function (e) {
                    if (Array.isArray(e)) return t.array;
                    if (e instanceof Date) return t.date;
                    if (e instanceof RegExp) return t.regex;
                    if (e instanceof Error) return t.error;
                    const i = Object.prototype.toString.call(e);
                    return n.typeMap.get(i) || t.generic;
                  });
              },
              7043: (e, t) => {
                "use strict";
                t.keys = function (e) {
                  return !1 !==
                    (arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : {}
                    ).symbols
                    ? Reflect.ownKeys(e)
                    : Object.getOwnPropertyNames(e);
                };
              },
              3652: (e, t, n) => {
                "use strict";
                const i = n(375),
                  r = {};
                (t.Sorter = class {
                  constructor() {
                    (this._items = []), (this.nodes = []);
                  }
                  add(e, t) {
                    const n = [].concat((t = t || {}).before || []),
                      r = [].concat(t.after || []),
                      o = t.group || "?",
                      a = t.sort || 0;
                    i(!n.includes(o), `Item cannot come before itself: ${o}`),
                      i(
                        !n.includes("?"),
                        "Item cannot come before unassociated items"
                      ),
                      i(!r.includes(o), `Item cannot come after itself: ${o}`),
                      i(
                        !r.includes("?"),
                        "Item cannot come after unassociated items"
                      ),
                      Array.isArray(e) || (e = [e]);
                    for (const i of e) {
                      const e = {
                        seq: this._items.length,
                        sort: a,
                        before: n,
                        after: r,
                        group: o,
                        node: i,
                      };
                      this._items.push(e);
                    }
                    if (!t.manual) {
                      const e = this._sort();
                      i(
                        e,
                        "item",
                        "?" !== o ? `added into group ${o}` : "",
                        "created a dependencies error"
                      );
                    }
                    return this.nodes;
                  }
                  merge(e) {
                    Array.isArray(e) || (e = [e]);
                    for (const n of e)
                      if (n)
                        for (const e of n._items)
                          this._items.push(Object.assign({}, e));
                    this._items.sort(r.mergeSort);
                    for (let n = 0; n < this._items.length; ++n)
                      this._items[n].seq = n;
                    const t = this._sort();
                    return (
                      i(t, "merge created a dependencies error"), this.nodes
                    );
                  }
                  sort() {
                    const e = this._sort();
                    return (
                      i(e, "sort created a dependencies error"), this.nodes
                    );
                  }
                  _sort() {
                    const e = {},
                      t = Object.create(null),
                      n = Object.create(null);
                    for (const s of this._items) {
                      const i = s.seq,
                        r = s.group;
                      (n[r] = n[r] || []), n[r].push(i), (e[i] = s.before);
                      for (const e of s.after)
                        (t[e] = t[e] || []), t[e].push(i);
                    }
                    for (const s in e) {
                      const t = [];
                      for (const i in e[s]) {
                        const r = e[s][i];
                        (n[r] = n[r] || []), t.push(...n[r]);
                      }
                      e[s] = t;
                    }
                    for (const s in t)
                      if (n[s]) for (const i of n[s]) e[i].push(...t[s]);
                    const i = {};
                    for (const s in e) {
                      const t = e[s];
                      for (const e of t) (i[e] = i[e] || []), i[e].push(s);
                    }
                    const r = {},
                      o = [];
                    for (let s = 0; s < this._items.length; ++s) {
                      let e = s;
                      if (i[s]) {
                        e = null;
                        for (let t = 0; t < this._items.length; ++t) {
                          if (!0 === r[t]) continue;
                          i[t] || (i[t] = []);
                          const n = i[t].length;
                          let o = 0;
                          for (let e = 0; e < n; ++e) r[i[t][e]] && ++o;
                          if (o === n) {
                            e = t;
                            break;
                          }
                        }
                      }
                      null !== e && ((r[e] = !0), o.push(e));
                    }
                    if (o.length !== this._items.length) return !1;
                    const a = {};
                    for (const s of this._items) a[s.seq] = s;
                    (this._items = []), (this.nodes = []);
                    for (const s of o) {
                      const e = a[s];
                      this.nodes.push(e.node), this._items.push(e);
                    }
                    return !0;
                  }
                }),
                  (r.mergeSort = (e, t) =>
                    e.sort === t.sort ? 0 : e.sort < t.sort ? -1 : 1);
              },
              5380: (e, t, n) => {
                "use strict";
                const i = n(443),
                  r = n(2178),
                  o = {
                    minDomainSegments: 2,
                    nonAsciiRx: /[^\x00-\x7f]/,
                    domainControlRx: /[\x00-\x20@\:\/\\#!\$&\'\(\)\*\+,;=\?]/,
                    tldSegmentRx: /^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
                    domainSegmentRx:
                      /^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
                    URL: i.URL || URL,
                  };
                (t.analyze = function (e) {
                  let t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : {};
                  if (!e) return r.code("DOMAIN_NON_EMPTY_STRING");
                  if ("string" != typeof e)
                    throw new Error("Invalid input: domain must be a string");
                  if (e.length > 256) return r.code("DOMAIN_TOO_LONG");
                  if (o.nonAsciiRx.test(e)) {
                    if (!1 === t.allowUnicode)
                      return r.code("DOMAIN_INVALID_UNICODE_CHARS");
                    e = e.normalize("NFC");
                  }
                  if (o.domainControlRx.test(e))
                    return r.code("DOMAIN_INVALID_CHARS");
                  (e = o.punycode(e)),
                    t.allowFullyQualified &&
                      "." === e[e.length - 1] &&
                      (e = e.slice(0, -1));
                  const n = t.minDomainSegments || o.minDomainSegments,
                    i = e.split(".");
                  if (i.length < n) return r.code("DOMAIN_SEGMENTS_COUNT");
                  if (t.maxDomainSegments && i.length > t.maxDomainSegments)
                    return r.code("DOMAIN_SEGMENTS_COUNT_MAX");
                  const a = t.tlds;
                  if (a) {
                    const e = i[i.length - 1].toLowerCase();
                    if (
                      (a.deny && a.deny.has(e)) ||
                      (a.allow && !a.allow.has(e))
                    )
                      return r.code("DOMAIN_FORBIDDEN_TLDS");
                  }
                  for (let s = 0; s < i.length; ++s) {
                    const e = i[s];
                    if (!e.length) return r.code("DOMAIN_EMPTY_SEGMENT");
                    if (e.length > 63) return r.code("DOMAIN_LONG_SEGMENT");
                    if (s < i.length - 1) {
                      if (!o.domainSegmentRx.test(e))
                        return r.code("DOMAIN_INVALID_CHARS");
                    } else if (!o.tldSegmentRx.test(e))
                      return r.code("DOMAIN_INVALID_TLDS_CHARS");
                  }
                  return null;
                }),
                  (t.isValid = function (e, n) {
                    return !t.analyze(e, n);
                  }),
                  (o.punycode = function (e) {
                    e.includes("%") && (e = e.replace(/%/g, "%25"));
                    try {
                      return new o.URL(`http://${e}`).host;
                    } catch (t) {
                      return e;
                    }
                  });
              },
              1745: (e, t, n) => {
                "use strict";
                const i = n(9848),
                  r = n(5380),
                  o = n(2178),
                  a = {
                    nonAsciiRx: /[^\x00-\x7f]/,
                    encoder: new (i.TextEncoder || TextEncoder)(),
                  };
                (t.analyze = function (e, t) {
                  return a.email(e, t);
                }),
                  (t.isValid = function (e, t) {
                    return !a.email(e, t);
                  }),
                  (a.email = function (e) {
                    let t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : {};
                    if ("string" != typeof e)
                      throw new Error("Invalid input: email must be a string");
                    if (!e) return o.code("EMPTY_STRING");
                    const n = !a.nonAsciiRx.test(e);
                    if (!n) {
                      if (!1 === t.allowUnicode)
                        return o.code("FORBIDDEN_UNICODE");
                      e = e.normalize("NFC");
                    }
                    const i = e.split("@");
                    if (2 !== i.length)
                      return i.length > 2
                        ? o.code("MULTIPLE_AT_CHAR")
                        : o.code("MISSING_AT_CHAR");
                    const [s, l] = i;
                    if (!s) return o.code("EMPTY_LOCAL");
                    if (!t.ignoreLength) {
                      if (e.length > 254) return o.code("ADDRESS_TOO_LONG");
                      if (a.encoder.encode(s).length > 64)
                        return o.code("LOCAL_TOO_LONG");
                    }
                    return a.local(s, n) || r.analyze(l, t);
                  }),
                  (a.local = function (e, t) {
                    const n = e.split(".");
                    for (const i of n) {
                      if (!i.length) return o.code("EMPTY_LOCAL_SEGMENT");
                      if (t) {
                        if (!a.atextRx.test(i))
                          return o.code("INVALID_LOCAL_CHARS");
                      } else
                        for (const e of i) {
                          if (a.atextRx.test(e)) continue;
                          const t = a.binary(e);
                          if (!a.atomRx.test(t))
                            return o.code("INVALID_LOCAL_CHARS");
                        }
                    }
                  }),
                  (a.binary = function (e) {
                    return Array.from(a.encoder.encode(e))
                      .map((e) => String.fromCharCode(e))
                      .join("");
                  }),
                  (a.atextRx = /^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/),
                  (a.atomRx = new RegExp(
                    [
                      "(?:[\\xc2-\\xdf][\\x80-\\xbf])",
                      "(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})",
                      "(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})",
                    ].join("|")
                  ));
              },
              2178: (e, t) => {
                "use strict";
                (t.codes = {
                  EMPTY_STRING: "Address must be a non-empty string",
                  FORBIDDEN_UNICODE:
                    "Address contains forbidden Unicode characters",
                  MULTIPLE_AT_CHAR:
                    "Address cannot contain more than one @ character",
                  MISSING_AT_CHAR: "Address must contain one @ character",
                  EMPTY_LOCAL: "Address local part cannot be empty",
                  ADDRESS_TOO_LONG: "Address too long",
                  LOCAL_TOO_LONG: "Address local part too long",
                  EMPTY_LOCAL_SEGMENT:
                    "Address local part contains empty dot-separated segment",
                  INVALID_LOCAL_CHARS:
                    "Address local part contains invalid character",
                  DOMAIN_NON_EMPTY_STRING: "Domain must be a non-empty string",
                  DOMAIN_TOO_LONG: "Domain too long",
                  DOMAIN_INVALID_UNICODE_CHARS:
                    "Domain contains forbidden Unicode characters",
                  DOMAIN_INVALID_CHARS: "Domain contains invalid character",
                  DOMAIN_INVALID_TLDS_CHARS:
                    "Domain contains invalid tld character",
                  DOMAIN_SEGMENTS_COUNT:
                    "Domain lacks the minimum required number of segments",
                  DOMAIN_SEGMENTS_COUNT_MAX:
                    "Domain contains too many segments",
                  DOMAIN_FORBIDDEN_TLDS: "Domain uses forbidden TLD",
                  DOMAIN_EMPTY_SEGMENT:
                    "Domain contains empty dot-separated segment",
                  DOMAIN_LONG_SEGMENT:
                    "Domain contains dot-separated segment that is too long",
                }),
                  (t.code = function (e) {
                    return { code: e, error: t.codes[e] };
                  });
              },
              9959: (e, t, n) => {
                "use strict";
                const i = n(375),
                  r = n(5752);
                t.regex = function () {
                  let e =
                    arguments.length > 0 && void 0 !== arguments[0]
                      ? arguments[0]
                      : {};
                  i(
                    void 0 === e.cidr || "string" == typeof e.cidr,
                    "options.cidr must be a string"
                  );
                  const t = e.cidr ? e.cidr.toLowerCase() : "optional";
                  i(
                    ["required", "optional", "forbidden"].includes(t),
                    "options.cidr must be one of required, optional, forbidden"
                  ),
                    i(
                      void 0 === e.version ||
                        "string" == typeof e.version ||
                        Array.isArray(e.version),
                      "options.version must be a string or an array of string"
                    );
                  let n = e.version || ["ipv4", "ipv6", "ipvfuture"];
                  Array.isArray(n) || (n = [n]),
                    i(
                      n.length >= 1,
                      "options.version must have at least 1 version specified"
                    );
                  for (let r = 0; r < n.length; ++r)
                    i(
                      "string" == typeof n[r],
                      "options.version must only contain strings"
                    ),
                      (n[r] = n[r].toLowerCase()),
                      i(
                        ["ipv4", "ipv6", "ipvfuture"].includes(n[r]),
                        "options.version contains unknown version " +
                          n[r] +
                          " - must be one of ipv4, ipv6, ipvfuture"
                      );
                  n = Array.from(new Set(n));
                  const o = `(?:${n
                      .map((e) => {
                        if ("forbidden" === t) return r.ip[e];
                        const n = `\\/${
                          "ipv4" === e ? r.ip.v4Cidr : r.ip.v6Cidr
                        }`;
                        return "required" === t
                          ? `${r.ip[e]}${n}`
                          : `${r.ip[e]}(?:${n})?`;
                      })
                      .join("|")})`,
                    a = new RegExp(`^${o}$`);
                  return { cidr: t, versions: n, regex: a, raw: o };
                };
              },
              5752: (e, t, n) => {
                "use strict";
                const i = n(375),
                  r = n(6064),
                  o = {
                    generate: function () {
                      const e = {},
                        t = "\\dA-Fa-f",
                        n = "[" + t + "]",
                        i = "\\w-\\.~",
                        r = "!\\$&'\\(\\)\\*\\+,;=",
                        o = "%" + t,
                        a = i + o + r + ":@",
                        s = "[" + a + "]",
                        l =
                          "(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
                      e.ipv4address = "(?:" + l + "\\.){3}" + l;
                      const c = n + "{1,4}",
                        p = "(?:" + c + ":" + c + "|" + e.ipv4address + ")",
                        u = "(?:" + c + ":){6}" + p,
                        d = "::(?:" + c + ":){5}" + p,
                        m = "(?:" + c + ")?::(?:" + c + ":){4}" + p,
                        h =
                          "(?:(?:" +
                          c +
                          ":){0,1}" +
                          c +
                          ")?::(?:" +
                          c +
                          ":){3}" +
                          p,
                        f =
                          "(?:(?:" +
                          c +
                          ":){0,2}" +
                          c +
                          ")?::(?:" +
                          c +
                          ":){2}" +
                          p,
                        g = "(?:(?:" + c + ":){0,3}" + c + ")?::" + c + ":" + p,
                        y = "(?:(?:" + c + ":){0,4}" + c + ")?::" + p;
                      (e.ipv4Cidr = "(?:\\d|[1-2]\\d|3[0-2])"),
                        (e.ipv6Cidr =
                          "(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])"),
                        (e.ipv6address =
                          "(?:" +
                          u +
                          "|" +
                          d +
                          "|" +
                          m +
                          "|" +
                          h +
                          "|" +
                          f +
                          "|" +
                          g +
                          "|" +
                          y +
                          "|(?:(?:[\\dA-Fa-f]{1,4}:){0,5}[\\dA-Fa-f]{1,4})?::[\\dA-Fa-f]{1,4}|(?:(?:[\\dA-Fa-f]{1,4}:){0,6}[\\dA-Fa-f]{1,4})?::)"),
                        (e.ipvFuture = "v" + n + "+\\.[" + i + r + ":]+"),
                        (e.scheme = "[a-zA-Z][a-zA-Z\\d+-\\.]*"),
                        (e.schemeRegex = new RegExp(e.scheme));
                      const b = "[" + i + o + r + ":]*",
                        T =
                          "(?:\\[(?:" +
                          e.ipv6address +
                          "|" +
                          e.ipvFuture +
                          ")\\]|" +
                          e.ipv4address +
                          "|[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=]{1,255})",
                        _ = "(?:" + b + "@)?" + T + "(?::\\d*)?",
                        S = "(?:" + b + "@)?(" + T + ")(?::\\d*)?",
                        v = s + "*",
                        C = s + "+",
                        I = "(?:\\/" + v + ")*",
                        R = "\\/(?:" + C + I + ")?",
                        x = C + I,
                        L = "[" + i + o + r + "@]+" + I;
                      return (
                        (e.hierPart =
                          "(?:(?:\\/\\/" +
                          _ +
                          I +
                          ")|" +
                          R +
                          "|" +
                          x +
                          "|(?:\\/\\/\\/[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=:@]*(?:\\/[\\w-\\.~%\\dA-Fa-f!\\$&'\\(\\)\\*\\+,;=:@]*)*))"),
                        (e.hierPartCapture =
                          "(?:(?:\\/\\/" + S + I + ")|" + R + "|" + x + ")"),
                        (e.relativeRef =
                          "(?:(?:\\/\\/" + _ + I + ")|" + R + "|" + L + "|)"),
                        (e.relativeRefCapture =
                          "(?:(?:\\/\\/" + S + I + ")|" + R + "|" + L + "|)"),
                        (e.query = "[" + a + "\\/\\?]*(?=#|$)"),
                        (e.queryWithSquareBrackets =
                          "[" + a + "\\[\\]\\/\\?]*(?=#|$)"),
                        (e.fragment = "[" + a + "\\/\\?]*"),
                        e
                      );
                    },
                  };
                (o.rfc3986 = o.generate()),
                  (t.ip = {
                    v4Cidr: o.rfc3986.ipv4Cidr,
                    v6Cidr: o.rfc3986.ipv6Cidr,
                    ipv4: o.rfc3986.ipv4address,
                    ipv6: o.rfc3986.ipv6address,
                    ipvfuture: o.rfc3986.ipvFuture,
                  }),
                  (o.createRegex = function (e) {
                    const t = o.rfc3986,
                      n =
                        "(?:\\?" +
                        (e.allowQuerySquareBrackets
                          ? t.queryWithSquareBrackets
                          : t.query) +
                        ")?(?:#" +
                        t.fragment +
                        ")?",
                      a = e.domain ? t.relativeRefCapture : t.relativeRef;
                    if (e.relativeOnly) return o.wrap(a + n);
                    let s = "";
                    if (e.scheme) {
                      i(
                        e.scheme instanceof RegExp ||
                          "string" == typeof e.scheme ||
                          Array.isArray(e.scheme),
                        "scheme must be a RegExp, String, or Array"
                      );
                      const n = [].concat(e.scheme);
                      i(
                        n.length >= 1,
                        "scheme must have at least 1 scheme specified"
                      );
                      const o = [];
                      for (let e = 0; e < n.length; ++e) {
                        const a = n[e];
                        i(
                          a instanceof RegExp || "string" == typeof a,
                          "scheme at position " +
                            e +
                            " must be a RegExp or String"
                        ),
                          a instanceof RegExp
                            ? o.push(a.source.toString())
                            : (i(
                                t.schemeRegex.test(a),
                                "scheme at position " +
                                  e +
                                  " must be a valid scheme"
                              ),
                              o.push(r(a)));
                      }
                      s = o.join("|");
                    }
                    const l =
                        "(?:" +
                        (s ? "(?:" + s + ")" : t.scheme) +
                        ":" +
                        (e.domain ? t.hierPartCapture : t.hierPart) +
                        ")",
                      c = e.allowRelative ? "(?:" + l + "|" + a + ")" : l;
                    return o.wrap(c + n, s);
                  }),
                  (o.wrap = function (e, t) {
                    return {
                      raw: (e = `(?=.)(?!https?:/(?:$|[^/]))(?!https?:///)(?!https?:[^/])${e}`),
                      regex: new RegExp(`^${e}$`),
                      scheme: t,
                    };
                  }),
                  (o.uriRegex = o.createRegex({})),
                  (t.regex = function () {
                    let e =
                      arguments.length > 0 && void 0 !== arguments[0]
                        ? arguments[0]
                        : {};
                    return e.scheme ||
                      e.allowRelative ||
                      e.relativeOnly ||
                      e.allowQuerySquareBrackets ||
                      e.domain
                      ? o.createRegex(e)
                      : o.uriRegex;
                  });
              },
              1447: (e, t) => {
                "use strict";
                const n = {
                  operators: [
                    "!",
                    "^",
                    "*",
                    "/",
                    "%",
                    "+",
                    "-",
                    "<",
                    "<=",
                    ">",
                    ">=",
                    "==",
                    "!=",
                    "&&",
                    "||",
                    "??",
                  ],
                  operatorCharacters: [
                    "!",
                    "^",
                    "*",
                    "/",
                    "%",
                    "+",
                    "-",
                    "<",
                    "=",
                    ">",
                    "&",
                    "|",
                    "?",
                  ],
                  operatorsOrder: [
                    ["^"],
                    ["*", "/", "%"],
                    ["+", "-"],
                    ["<", "<=", ">", ">="],
                    ["==", "!="],
                    ["&&"],
                    ["||", "??"],
                  ],
                  operatorsPrefix: ["!", "n"],
                  literals: { '"': '"', "`": "`", "'": "'", "[": "]" },
                  numberRx: /^(?:[0-9]*(\.[0-9]*)?){1}$/,
                  tokenRx: /^[\w\$\#\.\@\:\{\}]+$/,
                  symbol: Symbol("formula"),
                  settings: Symbol("settings"),
                };
                (t.Parser = class {
                  constructor(e) {
                    let t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : {};
                    if (!t[n.settings] && t.constants)
                      for (const n in t.constants) {
                        const e = t.constants[n];
                        if (
                          null !== e &&
                          !["boolean", "number", "string"].includes(typeof e)
                        )
                          throw new Error(
                            `Formula constant ${n} contains invalid ${typeof e} value type`
                          );
                      }
                    (this.settings = t[n.settings]
                      ? t
                      : Object.assign(
                          { [n.settings]: !0, constants: {}, functions: {} },
                          t
                        )),
                      (this.single = null),
                      (this._parts = null),
                      this._parse(e);
                  }
                  _parse(e) {
                    let i = [],
                      r = "",
                      o = 0,
                      a = !1;
                    const s = (e) => {
                      if (o)
                        throw new Error("Formula missing closing parenthesis");
                      const s = i.length ? i[i.length - 1] : null;
                      if (a || r || e) {
                        if (s && "reference" === s.type && ")" === e)
                          return (
                            (s.type = "function"),
                            (s.value = this._subFormula(r, s.value)),
                            void (r = "")
                          );
                        if (")" === e) {
                          const e = new t.Parser(r, this.settings);
                          i.push({ type: "segment", value: e });
                        } else if (a) {
                          if ("]" === a)
                            return (
                              i.push({ type: "reference", value: r }),
                              void (r = "")
                            );
                          i.push({ type: "literal", value: r });
                        } else if (n.operatorCharacters.includes(r))
                          s &&
                          "operator" === s.type &&
                          n.operators.includes(s.value + r)
                            ? (s.value += r)
                            : i.push({ type: "operator", value: r });
                        else if (r.match(n.numberRx))
                          i.push({ type: "constant", value: parseFloat(r) });
                        else if (void 0 !== this.settings.constants[r])
                          i.push({
                            type: "constant",
                            value: this.settings.constants[r],
                          });
                        else {
                          if (!r.match(n.tokenRx))
                            throw new Error(
                              `Formula contains invalid token: ${r}`
                            );
                          i.push({ type: "reference", value: r });
                        }
                        r = "";
                      }
                    };
                    for (const t of e)
                      a
                        ? t === a
                          ? (s(), (a = !1))
                          : (r += t)
                        : o
                        ? "(" === t
                          ? ((r += t), ++o)
                          : ")" === t
                          ? (--o, o ? (r += t) : s(t))
                          : (r += t)
                        : t in n.literals
                        ? (a = n.literals[t])
                        : "(" === t
                        ? (s(), ++o)
                        : n.operatorCharacters.includes(t)
                        ? (s(), (r = t), s())
                        : " " !== t
                        ? (r += t)
                        : s();
                    s(),
                      (i = i.map((e, t) =>
                        "operator" !== e.type ||
                        "-" !== e.value ||
                        (t && "operator" !== i[t - 1].type)
                          ? e
                          : { type: "operator", value: "n" }
                      ));
                    let l = !1;
                    for (const t of i) {
                      if ("operator" === t.type) {
                        if (n.operatorsPrefix.includes(t.value)) continue;
                        if (!l)
                          throw new Error(
                            "Formula contains an operator in invalid position"
                          );
                        if (!n.operators.includes(t.value))
                          throw new Error(
                            `Formula contains an unknown operator ${t.value}`
                          );
                      } else if (l)
                        throw new Error("Formula missing expected operator");
                      l = !l;
                    }
                    if (!l)
                      throw new Error(
                        "Formula contains invalid trailing operator"
                      );
                    1 === i.length &&
                      ["reference", "literal", "constant"].includes(
                        i[0].type
                      ) &&
                      (this.single = {
                        type: "reference" === i[0].type ? "reference" : "value",
                        value: i[0].value,
                      }),
                      (this._parts = i.map((e) => {
                        if ("operator" === e.type)
                          return n.operatorsPrefix.includes(e.value)
                            ? e
                            : e.value;
                        if ("reference" !== e.type) return e.value;
                        if (
                          this.settings.tokenRx &&
                          !this.settings.tokenRx.test(e.value)
                        )
                          throw new Error(
                            `Formula contains invalid reference ${e.value}`
                          );
                        return this.settings.reference
                          ? this.settings.reference(e.value)
                          : n.reference(e.value);
                      }));
                  }
                  _subFormula(e, i) {
                    const r = this.settings.functions[i];
                    if ("function" != typeof r)
                      throw new Error(`Formula contains unknown function ${i}`);
                    let o = [];
                    if (e) {
                      let t = "",
                        r = 0,
                        a = !1;
                      const s = () => {
                        if (!t)
                          throw new Error(
                            `Formula contains function ${i} with invalid arguments ${e}`
                          );
                        o.push(t), (t = "");
                      };
                      for (let i = 0; i < e.length; ++i) {
                        const o = e[i];
                        a
                          ? ((t += o), o === a && (a = !1))
                          : o in n.literals && !r
                          ? ((t += o), (a = n.literals[o]))
                          : "," !== o || r
                          ? ((t += o), "(" === o ? ++r : ")" === o && --r)
                          : s();
                      }
                      s();
                    }
                    return (
                      (o = o.map((e) => new t.Parser(e, this.settings))),
                      function (e) {
                        const t = [];
                        for (const n of o) t.push(n.evaluate(e));
                        return r.call(e, ...t);
                      }
                    );
                  }
                  evaluate(e) {
                    const t = this._parts.slice();
                    for (let i = t.length - 2; i >= 0; --i) {
                      const r = t[i];
                      if (r && "operator" === r.type) {
                        const o = t[i + 1];
                        t.splice(i + 1, 1);
                        const a = n.evaluate(o, e);
                        t[i] = n.single(r.value, a);
                      }
                    }
                    return (
                      n.operatorsOrder.forEach((i) => {
                        for (let r = 1; r < t.length - 1; )
                          if (i.includes(t[r])) {
                            const i = t[r],
                              o = n.evaluate(t[r - 1], e),
                              a = n.evaluate(t[r + 1], e);
                            t.splice(r, 2);
                            const s = n.calculate(i, o, a);
                            t[r - 1] = 0 === s ? 0 : s;
                          } else r += 2;
                      }),
                      n.evaluate(t[0], e)
                    );
                  }
                }),
                  (t.Parser.prototype[n.symbol] = !0),
                  (n.reference = function (e) {
                    return function (t) {
                      return t && void 0 !== t[e] ? t[e] : null;
                    };
                  }),
                  (n.evaluate = function (e, t) {
                    return null === e
                      ? null
                      : "function" == typeof e
                      ? e(t)
                      : e[n.symbol]
                      ? e.evaluate(t)
                      : e;
                  }),
                  (n.single = function (e, t) {
                    if ("!" === e) return !t;
                    const n = -t;
                    return 0 === n ? 0 : n;
                  }),
                  (n.calculate = function (e, t, i) {
                    if ("??" === e) return n.exists(t) ? t : i;
                    if ("string" == typeof t || "string" == typeof i) {
                      if ("+" === e)
                        return (
                          (t = n.exists(t) ? t : "") + (n.exists(i) ? i : "")
                        );
                    } else
                      switch (e) {
                        case "^":
                          return Math.pow(t, i);
                        case "*":
                          return t * i;
                        case "/":
                          return t / i;
                        case "%":
                          return t % i;
                        case "+":
                          return t + i;
                        case "-":
                          return t - i;
                      }
                    switch (e) {
                      case "<":
                        return t < i;
                      case "<=":
                        return t <= i;
                      case ">":
                        return t > i;
                      case ">=":
                        return t >= i;
                      case "==":
                        return t === i;
                      case "!=":
                        return t !== i;
                      case "&&":
                        return t && i;
                      case "||":
                        return t || i;
                    }
                    return null;
                  }),
                  (n.exists = function (e) {
                    return null != e;
                  });
              },
              9926: () => {},
              5688: () => {},
              9708: () => {},
              1152: () => {},
              443: () => {},
              9848: () => {},
              5934: (e) => {
                "use strict";
                e.exports = { version: "17.8.3" };
              },
            }),
            (t = {}),
            (function n(i) {
              var r = t[i];
              if (void 0 !== r) return r.exports;
              var o = (t[i] = { exports: {} });
              return e[i](o, o.exports, n), o.exports;
            })(5107)
          );
          var e, t;
        }),
        (e.exports = t());
    },
    934210: function (e) {
      function t(e) {
        return e ? (Array.isArray(e) ? e.map(t) : String(e).trim()) : null;
      }
      function n(e) {
        var t = e.indexOf("#");
        return t > -1 ? e.substr(0, t) : e;
      }
      function i(e) {
        var t = String(e).indexOf(":");
        return !e || t < 0 ? null : [e.slice(0, t), e.slice(t + 1)];
      }
      function r(e) {
        var t = e.toLowerCase(),
          n = t.indexOf("/");
        return n > -1 && (t = t.substr(0, n)), t.trim();
      }
      function o(e) {
        try {
          return a(encodeURI(e).replace(/%25/g, "%"));
        } catch (t) {
          return e;
        }
      }
      function a(e) {
        return e.replace(/%[0-9a-fA-F]{2}/g, function (e) {
          return e.toUpperCase();
        });
      }
      function s(e, t) {
        var n = new Array(t.length + 1),
          i = 1;
        n[0] = 0;
        for (var r = 0; r < e.length; r++) {
          if ("$" === e[r] && r + 1 === e.length) return n[i - 1] === t.length;
          if ("*" == e[r]) {
            i = t.length - n[0] + 1;
            for (var o = 1; o < i; o++) n[o] = n[o - 1] + 1;
          } else {
            var a = 0;
            for (o = 0; o < i; o++)
              n[o] < t.length && t[n[o]] === e[r] && (n[a++] = n[o] + 1);
            if (0 == a) return !1;
            i = a;
          }
        }
        return !0;
      }
      function l(e) {
        try {
          return (
            (e = new URL(e, "http://robots-relative.samclarke.com/")).port ||
              (e.port = "https:" === e.protocol ? 443 : 80),
            e
          );
        } catch (t) {
          return null;
        }
      }
      function c(e, o) {
        (this._url = l(e) || {}),
          (this._rules = Object.create(null)),
          (this._sitemaps = []),
          (this._preferredHost = null),
          (function (e, o) {
            for (
              var a = e
                  .split(/\r\n|\r|\n/)
                  .map(n)
                  .map(i)
                  .map(t),
                s = [],
                l = !0,
                c = 0;
              c < a.length;
              c++
            ) {
              var p = a[c];
              if (p && p[0]) {
                switch (p[0].toLowerCase()) {
                  case "user-agent":
                    l && (s.length = 0), p[1] && s.push(r(p[1]));
                    break;
                  case "disallow":
                    o.addRule(s, p[1], !1, c + 1);
                    break;
                  case "allow":
                    o.addRule(s, p[1], !0, c + 1);
                    break;
                  case "crawl-delay":
                    o.setCrawlDelay(s, p[1]);
                    break;
                  case "sitemap":
                    p[1] && o.addSitemap(p[1]);
                    break;
                  case "host":
                    p[1] && o.setPreferredHost(p[1].toLowerCase());
                }
                l = "user-agent" !== p[0].toLowerCase();
              }
            }
          })(o || "", this);
      }
      (c.prototype.addRule = function (e, t, n, i) {
        var r = this._rules;
        e.forEach(function (e) {
          (r[e] = r[e] || []),
            t && r[e].push({ pattern: o(t), allow: n, lineNumber: i });
        });
      }),
        (c.prototype.setCrawlDelay = function (e, t) {
          var n = this._rules,
            i = Number(t);
          e.forEach(function (e) {
            (n[e] = n[e] || []), isNaN(i) || (n[e].crawlDelay = i);
          });
        }),
        (c.prototype.addSitemap = function (e) {
          this._sitemaps.push(e);
        }),
        (c.prototype.setPreferredHost = function (e) {
          this._preferredHost = e;
        }),
        (c.prototype._getRule = function (e, t) {
          var n = l(e) || {},
            i = r(t || "*");
          if (
            n.protocol === this._url.protocol &&
            n.hostname === this._url.hostname &&
            n.port === this._url.port
          ) {
            var o = this._rules[i] || this._rules["*"] || [],
              c = (function (e, t) {
                for (var n = null, i = 0; i < t.length; i++) {
                  var r = t[i];
                  s(r.pattern, e) &&
                    (!n ||
                      r.pattern.length > n.pattern.length ||
                      (r.pattern.length == n.pattern.length &&
                        r.allow &&
                        !n.allow)) &&
                    (n = r);
                }
                return n;
              })(a(n.pathname + n.search), o);
            return c;
          }
        }),
        (c.prototype.isAllowed = function (e, t) {
          var n = this._getRule(e, t);
          if ("undefined" !== typeof n) return !n || n.allow;
        }),
        (c.prototype.getMatchingLineNumber = function (e, t) {
          var n = this._getRule(e, t);
          return n ? n.lineNumber : -1;
        }),
        (c.prototype.isDisallowed = function (e, t) {
          return !this.isAllowed(e, t);
        }),
        (c.prototype.getCrawlDelay = function (e) {
          var t = r(e || "*");
          return (this._rules[t] || this._rules["*"] || {}).crawlDelay;
        }),
        (c.prototype.getPreferredHost = function () {
          return this._preferredHost;
        }),
        (c.prototype.getSitemaps = function () {
          return this._sitemaps.slice(0);
        }),
        (e.exports = c);
    },
    991790: function (e, t, n) {
      var i = n(934210);
      e.exports = function (e, t) {
        return new i(e, t);
      };
    },
  },
]);
